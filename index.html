<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NYM</title>
    <meta name="description"
        content="NYM App - Nostr Ynstant Messenger. Ephemeral anonymous messaging. Bridged with Bitchat geohash channels.">
    <link rel="manifest"
        href="data:application/json;base64,eyJuYW1lIjoiTllNIC0gTm9zdHIgWW5zdGFudCBNZXNzZW5nZXIiLCJzaG9ydF9uYW1lIjoiTllNIiwic3RhcnRfdXJsIjoiaHR0cHM6Ly9ueW0uYmFyLyIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwidGhlbWVfY29sb3IiOiIjMDAwMDAwIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwMDAwMDAiLCJpY29ucyI6W3sic3JjIjoiaHR0cHM6Ly9ueW0uYmFyL2ltYWdlcy9OWU0taWNvbi5wbmciLCJzaXplcyI6IjE5MngxOTIiLCJ0eXBlIjoiaW1hZ2UvcG5nIn0seyJzcmMiOiJodHRwczovL255bS5iYXIvaW1hZ2VzL05ZTS1pY29uLnBuZyIsInNpemVzIjoiNTEyeDUxMiIsInR5cGUiOiJpbWFnZS9wbmcifV19">
    <link rel="icon" type="image/x-icon" href="https://nym.bar/images/favicon.ico">
    <link rel="icon" type="image/png" sizes="192x192" href="https://nym.bar/images/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="https://nym.bar/images/android-chrome-512x512.png">
    <link rel="apple-touch-icon" sizes="192x192" href="https://nym.bar/images/android-chrome-192x192.png">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Anonymously Chat with NYM">
    <meta property="og:description"
        content="Ephemeral anonymous messaging over Nostr. Bridged with Bitchat geohash channels.">
    <meta property="og:image" content="https://nym.bar/images/NYM-favicon.png">
    <meta property="og:url" content="https://app.nym.bar">
    <meta property="og:type" content="website">
    <link rel="icon" href="https://nym.bar/images/NYM-favicon.png" type="image/png">
    <link rel="canonical" href="https://app.nym.bar/">
    <meta name="theme-color" content="#000000">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="NYM">
    <link rel="apple-touch-icon" href="https://nym.bar/images/NYM-favicon.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00ff00;
            --secondary: #00ffff;
            --warning: #ffff00;
            --danger: #ff0000;
            --purple: #ff00ff;
            --blue: #0080ff;
            --lightning: #f7931a;
            --bg: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #111111;
            --text: #00ff00;
            --text-dim: #008800;
            --text-bright: #00ffaa;
            --border: #00ff00;
            --font-mono: 'Courier New', 'Consolas', 'Monaco', monospace;
            --viewport-height: 100vh;
        }

        body {
            font-family: var(--font-mono);
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 255, 0, 0.03) 2px,
                    rgba(0, 255, 0, 0.03) 4px);
            pointer-events: none;
            z-index: 0;
        }

        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.4) 100%);
            pointer-events: none;
            z-index: 0;
        }

        .mobile-overlay {
            display: none;
            position: unset;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
        }

        .mobile-overlay.active {
            display: block;
        }

        .container {
            display: flex;
            height: 100vh;
            position: relative;
            z-index: 1;
        }

        .sidebar {
            width: 240px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s;
            position: relative;
            z-index: 2;
            overflow-y: auto;
            height: 100vh;
        }

        .sidebar-header {
            padding: 20px 15px;
            border-bottom: 1px solid var(--border);
            text-align: center;
            background: var(--bg-tertiary);
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
            text-shadow: 0 0 10px var(--primary);
            margin-bottom: 5px;
            letter-spacing: 4px;
        }

        .tagline {
            font-size: 10px;
            color: var(--text-dim);
            letter-spacing: 1px;
        }

        .nym-display {
            margin-top: 15px;
            padding: 8px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .nym-display:hover {
            border-color: var(--primary);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .nym-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .nym-value {
            font-size: 14px;
            color: var(--text-bright);
            margin-top: 3px;
            overflow: hidden;
            text-overflow: ellipsis;
            word-break: break-all;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--primary);
            animation: pulse 2s infinite;
            box-shadow: 0 0 5px var(--primary);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(0.9);
            }
        }

        .nav-section {
            padding: 15px 10px 10px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.2);
        }

        .nav-title {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            padding-left: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-title-text {
            flex: 1;
        }

        .search-icon,
        .discover-icon {
            cursor: pointer;
            padding: 2px 5px;
            transition: all 0.2s;
            width: 20px;
            height: 20px;
        }

        .search-icon:hover svg,
        .discover-icon:hover svg {
            stroke: var(--primary);
        }

        .search-icon svg,
        .discover-icon svg {
            width: 14px;
            height: 14px;
            stroke: var(--text-dim);
            stroke-width: 2;
            fill: none;
            transition: stroke 0.2s;
        }

        .search-input {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 8px;
            font-family: var(--font-mono);
            font-size: 12px;
            outline: none;
            margin-bottom: 10px;
            display: none;
        }

        .search-input.active {
            display: block;
        }

        .search-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .view-more-btn {
            padding: 8px 10px;
            margin: 5px 10px;
            text-align: center;
            color: var(--text-dim);
            border: 1px solid var(--border);
            cursor: pointer;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            display: block !important;
        }

        .view-more-btn:hover {
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.1);
            color: var(--text);
        }

        .list-collapsed .list-item:nth-child(n+21) {
            display: none !important;
        }

        .list-expanded .view-more-btn {
            display: none;
        }

        .list-expanded .list-item {
            display: flex !important;
        }

        .channel-list,
        .pm-list {
            max-height: none;
            overflow-y: visible;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .channel-item,
        .pm-item {
            padding: 8px 10px;
            margin: 3px 0;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            pointer-events: auto;
            z-index: 1;
            min-height: 35px;
        }

        .channel-item.pinned {
            order: -1;
            background: rgba(255, 215, 0, 0.05);
            border-color: rgba(255, 215, 0, 0.3);
        }

        .channel-item:hover,
        .pm-item:hover {
            border-color: var(--border);
            background: rgba(0, 255, 0, 0.1);
            padding-left: 15px;
        }

        .channel-item.active,
        .pm-item.active {
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.2);
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.1);
        }

        .channel-item.active::before,
        .pm-item.active::before {
            content: "▶";
            position: absolute;
            left: -2px;
            color: var(--primary);
            animation: blink 1s infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        .channel-name,
        .pm-name {
            flex: 1;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            min-width: 0;
            max-width: 100%;
            display: block;
            white-space: normal;
            line-height: 1.3;
        }

        .channel-badges {
            display: flex;
            gap: 5px;
            align-items: center;
            pointer-events: none;
            flex-shrink: 0;
            margin-left: 5px;
        }

        .channel-badges>* {
            pointer-events: auto;
        }


        .pin-btn {
            font-size: 12px;
            color: var(--text-dim);
            padding: 2px;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
        }

        .pin-btn:hover {
            opacity: 1;
        }

        .pin-btn.pinned {
            opacity: 1;
            color: var(--warning);
        }

        .pin-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        .std-badge {
            font-size: 9px;
            color: var(--blue);
            background: var(--bg);
            padding: 2px 4px;
            border: 1px solid var(--blue);
            border-radius: 3px;
        }

        .geohash-badge {
            font-size: 9px;
            color: var(--warning);
            background: var(--bg);
            padding: 2px 4px;
            border: 1px solid var(--warning);
            border-radius: 3px;
        }

        .pm-badge {
            font-size: 9px;
            color: var(--purple);
            background: var(--bg);
            padding: 2px 4px;
            border: 1px solid var(--purple);
            border-radius: 3px;
        }

        .delete-pm {
            font-size: 10px;
            color: var(--danger);
            padding: 2px 5px;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .delete-pm:hover {
            opacity: 1;
        }

        .unread-badge {
            background: var(--danger);
            color: var(--bg);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            animation: glow 1s infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 3px var(--danger);
            }

            to {
                box-shadow: 0 0 8px var(--danger);
            }
        }

        .sidebar-actions {
            display: none;
            padding: 15px 10px;
            border-top: 1px solid var(--border);
            gap: 5px;
            flex-direction: column;
        }

        .sidebar-actions .icon-btn {
            width: 100%;
            padding: 10px;
            text-align: center;
        }

        .user-list {
            flex: 0 1 auto;
            overflow-y: visible;
            padding: 10px;
            min-height: 0;
        }

        .user-item {
            padding: 6px 10px;
            font-size: 12px;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .user-item .nym-suffix,
        .pm-name .nym-suffix {
            opacity: 0.7;
            font-size: 0.9em;
            font-weight: 100;
        }

        .user-item span:last-child,
        .pm-name {
            color: var(--text-dim);
        }

        .user-item:hover span:last-child {
            color: var(--text);
        }

        .user-item span:last-child {
            word-break: break-word;
            overflow-wrap: break-word;
            flex: 1;
            min-width: 0;
        }

        .user-item:hover {
            color: var(--text);
            background: rgba(0, 255, 0, 0.05);
        }

        .user-item.search-hidden {
            display: none !important;
        }

        .user-status {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--primary);
        }

        .user-status.away {
            background: var(--warning);
        }

        .user-status.offline {
            background: var(--text-dim);
        }

        .context-menu {
            position: fixed;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3);
            z-index: 1000;
            display: none;
            min-width: 150px;
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text);
            transition: all 0.2s;
            border-bottom: 1px solid rgba(0, 255, 0, 0.1);
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: rgba(0, 255, 0, 0.1);
            color: var(--primary);
            padding-left: 20px;
        }

        .context-menu-item.danger {
            color: var(--danger);
        }

        .context-menu-item.danger:hover {
            background: rgba(255, 0, 0, 0.1);
            color: var(--danger);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: var(--bg);
        }

        .chat-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
        }

        .channel-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .channel-title {
            font-size: 18px;
            color: var(--primary);
        }

        .channel-meta {
            font-size: 11px;
            color: var(--text-dim);
        }

        .header-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .icon-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 12px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .icon-btn:hover {
            background: var(--primary);
            color: var(--bg);
            box-shadow: 0 0 10px var(--primary);
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 14px;
        }

        .message {
            display: flex;
            gap: 10px;
            padding: 8px 10px;
            border-left: 2px solid transparent;
            transition: all 0.2s;
            animation: messageIn 0.3s;
            position: relative;
            flex-wrap: wrap;
            align-items: flex-start;
        }

        .message.blocked {
            display: none;
        }

        .message.flooded {
            opacity: 0.3;
            filter: blur(2px);
        }

        .message.mentioned {
            background: rgba(0, 255, 255, 0.08);
            border-left-color: var(--secondary);
        }

        .message.self {
            background: rgba(0, 255, 255, 0.08);
            border-left-color: #FFFFFF;
        }

        .message.pm {
            border-left-color: transparent;
            background: transparent;
        }

        .message.pm:hover {
            border-left-color: var(--purple);
            background: rgba(255, 0, 255, 0.05);
        }

        @keyframes messageIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .message:hover {
            background: rgba(0, 255, 0, 0.05);
            border-left-color: var(--primary);
        }

        .message:hover .reaction-btn {
            opacity: 1;
        }

        .zap-badge {
            background: linear-gradient(135deg, rgba(247, 147, 26, 0.3), rgba(247, 147, 26, 0.2));
            border: 1px solid var(--lightning);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: var(--lightning);
            font-weight: bold;
            animation: zapGlow 2s infinite;
        }

        @keyframes zapGlow {

            0%,
            100% {
                box-shadow: 0 0 5px rgba(247, 147, 26, 0.3);
            }

            50% {
                box-shadow: 0 0 10px rgba(247, 147, 26, 0.5);
            }
        }

        .zap-icon {
            width: 14px;
            height: 14px;
            fill: var(--lightning);
        }

        .zap-modal .modal-content {
            max-width: 400px;
        }

        .zap-amounts {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .zap-amount-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 15px 10px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 14px;
            transition: all 0.2s;
            text-align: center;
            position: relative;
        }

        .zap-amount-btn:hover {
            border-color: var(--lightning);
            background: rgba(247, 147, 26, 0.1);
        }

        .zap-amount-btn.selected {
            border-color: var(--lightning);
            background: rgba(247, 147, 26, 0.2);
            box-shadow: 0 0 10px rgba(247, 147, 26, 0.3);
        }

        .zap-amount-btn .sats {
            display: block;
            font-size: 18px;
            font-weight: bold;
            color: var(--lightning);
        }

        .zap-custom-amount {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .zap-custom-amount input {
            flex: 1;
        }

        .zap-comment {
            margin-top: 20px;
        }

        .zap-invoice {
            background: var(--bg);
            border: 1px solid var(--lightning);
            padding: 15px;
            margin: 20px 0;
            word-break: break-all;
            font-size: 12px;
            color: var(--text-dim);
            position: relative;
        }

        .zap-invoice-qr {
            text-align: center;
            margin: 20px 0;
        }

        .zap-invoice-qr canvas {
            border: 2px solid var(--lightning);
            padding: 10px;
            background: white;
        }

        .zap-invoice-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .zap-status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid var(--border);
            background: var(--bg);
        }

        .zap-status.checking {
            border-color: var(--warning);
            color: var(--warning);
        }

        .zap-status.paid {
            border-color: var(--primary);
            color: var(--primary);
            animation: zapSuccess 0.5s;
        }

        @keyframes zapSuccess {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .context-menu-item.lightning {
            color: var(--lightning);
        }

        .context-menu-item.lightning:hover {
            background: rgba(247, 147, 26, 0.1);
            color: var(--lightning);
        }

        .lightning-address-display {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: var(--lightning);
            margin-top: 5px;
        }

        .lightning-address-display svg {
            width: 12px;
            height: 12px;
            fill: var(--lightning);
        }

        .add-zap-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.6;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .add-zap-btn:hover {
            opacity: 1;
            border-color: var(--lightning);
            background: rgba(247, 147, 26, 0.1);
        }

        .add-zap-btn svg {
            width: 16px;
            height: 16px;
        }

        .reaction-btn {
            position: absolute;
            right: 10px;
            top: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 4px 8px;
            cursor: pointer;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reaction-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--primary);
        }

        .reaction-btn svg {
            width: 16px;
            height: 16px;
            stroke: var(--text);
            fill: none;
        }

        .reactions-row {
            width: 100%;
            display: flex;
            gap: 5px;
            margin-top: 5px;
            margin-left: auto;
            align-items: center;
            flex-wrap: wrap;
        }

        .reaction-badge {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 3px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            user-select: none;
        }

        .reaction-badge:hover {
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.1);
            transform: scale(1.05);
        }

        .reaction-badge:active {
            transform: scale(0.95);
        }

        .reaction-badge.user-reacted {
            background: rgba(0, 255, 0, 0.2);
            border-color: var(--primary);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .reaction-badge[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 4px 8px;
            font-size: 10px;
            white-space: nowrap;
            margin-bottom: 4px;
            z-index: 1000;
            pointer-events: none;
        }

        .add-reaction-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.6;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .add-reaction-btn:hover {
            opacity: 1;
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.1);
        }

        .add-reaction-btn svg {
            width: 16px;
            height: 16px;
            stroke: var(--text);
            stroke-width: 2;
            fill: none;
        }

        .message-time {
            color: var(--text-dim);
            font-size: 12px;
            min-width: 50px;
        }

        .message-author {
            color: var(--secondary);
            min-width: 120px;
            font-weight: bold;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
        }

        .nym-suffix {
            opacity: 0.7;
            font-size: 0.9em;
            font-weight: 100;
        }

        .message-author:hover {
            text-decoration: underline;
        }

        .message-author.self {
            color: var(--primary);
        }

        .message-author.self .nym-suffix {
            color: var(--primary);
        }

        .message-content {
            flex: 1;
            word-wrap: break-word;
            word-break: break-word;
            color: var(--text);
            overflow-wrap: anywhere;
        }

        .message-quote {
            background: var(--bg-tertiary);
            border-left: 3px solid var(--primary);
            padding: 5px 10px;
            margin: 5px 0;
            font-size: 12px;
            color: var(--text-dim);
            font-style: italic;
            word-wrap: break-word;
            overflow-wrap: anywhere;
            max-width: 100%;
        }

        .message-content a {
            color: var(--secondary);
            text-decoration: underline;
        }

        .message-content .channel-link {
            color: var(--secondary);
            cursor: pointer;
            text-decoration: underline;
        }

        .message-content .channel-link:hover {
            color: var(--primary);
        }

        .message-content img {
            max-width: 300px;
            max-height: 300px;
            display: block;
            margin: 10px 0;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .message-content img:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .message-content strong {
            color: var(--text-bright);
            font-weight: bold;
        }

        .message-content em {
            font-style: italic;
            color: var(--text);
        }

        .message-content code {
            background: var(--bg-tertiary);
            padding: 2px 4px;
            font-family: var(--font-mono);
            color: var(--secondary);
            word-break: break-word;
        }

        .message-content pre {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            padding: 10px;
            margin: 10px 0;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-width: 100%;
            word-wrap: break-word;
        }

        .message-content blockquote {
            border-left: 3px solid var(--primary);
            padding-left: 10px;
            margin: 10px 0;
            color: var(--text-dim);
        }

        .message-content h1,
        .message-content h2,
        .message-content h3 {
            color: var(--primary);
            margin: 10px 0;
        }

        .message-content ul,
        .message-content ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .message-content del {
            text-decoration: line-through;
            color: var(--text-dim);
        }

        .system-message {
            white-space: pre-line;
            color: var(--warning);
            font-style: italic;
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-top: 1px dashed var(--text-dim);
            border-bottom: 1px dashed var(--text-dim);
        }

        .action-message {
            color: var(--purple);
            font-style: italic;
        }

        .typing-indicator {
            padding: 5px 20px;
            color: var(--text-dim);
            font-size: 12px;
            min-height: 20px;
            font-style: italic;
        }

        .input-container {
            padding: 15px;
            border-top: 1px solid var(--border);
            background: var(--bg-secondary);
            display: flex;
            gap: 10px;
            align-items: stretch;
            position: relative;
            position: sticky;
            bottom: 0;
            z-index: 100;
        }

        .input-wrapper {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
        }

        .message-input {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px;
            font-family: var(--font-mono);
            font-size: 16px;
            outline: none;
            resize: vertical;
            min-height: 40px;
            max-height: 120px;
        }

        .message-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        .char-counter {
            position: absolute;
            bottom: -18px;
            right: 5px;
            font-size: 10px;
            color: var(--text-dim);
        }

        .input-buttons {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .send-btn {
            background: var(--bg);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 10px 20px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            height: 40px;
        }

        .send-btn:hover:not(:disabled) {
            background: var(--primary);
            color: var(--bg);
            box-shadow: 0 0 15px var(--primary);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .icon-btn.input-btn {
            height: 40px;
            padding: 0 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-btn.input-btn svg {
            width: 18px;
            height: 18px;
            stroke: var(--text);
            stroke-width: 2;
            fill: none;
        }

        .icon-btn.input-btn:hover svg {
            stroke: var(--bg);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 2px solid var(--primary);
            padding: 30px;
            max-width: 500px;
            width: 90%;
            animation: modalIn 0.3s;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
            max-height: 90vh;
            overflow-y: auto;
        }

        @keyframes modalIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .modal-header {
            font-size: 20px;
            color: var(--primary);
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--primary);
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-dim);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px;
            font-family: var(--font-mono);
            font-size: 16px;
            outline: none;
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            border-color: var(--primary);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .form-hint {
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 5px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .blocked-list,
        .keyword-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border);
            padding: 10px;
            background: var(--bg);
        }

        .blocked-item,
        .keyword-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin: 2px 0;
        }

        .blocked-item:hover,
        .keyword-item:hover {
            background: rgba(0, 255, 0, 0.1);
        }

        .unblock-btn,
        .remove-keyword-btn {
            padding: 2px 8px;
            font-size: 10px;
            background: var(--bg);
            border: 1px solid var(--danger);
            color: var(--danger);
            cursor: pointer;
        }

        .unblock-btn:hover,
        .remove-keyword-btn:hover {
            background: var(--danger);
            color: var(--bg);
        }

        .search-create-prompt {
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            margin-top: 5px;
            font-size: 12px;
            color: var(--text-bright);
            cursor: pointer;
        }

        .search-create-prompt:hover {
            background: rgba(0, 255, 0, 0.1);
            border-color: var(--primary);
        }

        .image-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .image-modal.active {
            display: flex;
        }

        .image-modal img {
            max-width: 90%;
            max-height: 90%;
            border: 2px solid var(--primary);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }

        .image-modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: var(--primary);
            font-size: 30px;
            cursor: pointer;
            background: var(--bg);
            border: 2px solid var(--primary);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-modal-close:hover {
            background: var(--primary);
            color: var(--bg);
        }

        .mobile-menu-toggle {
            display: none;
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 2;
            background: var(--bg-secondary);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 10px;
            cursor: pointer;
            font-size: 20px;
        }

        .nick-edit-modal {
            display: none;
        }

        .nick-edit-modal.active {
            display: flex;
        }

        .autocomplete-dropdown,
        .emoji-autocomplete {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            max-height: 150px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 -5px 20px rgba(0, 255, 0, 0.2);
            margin-bottom: 5px;
        }

        .autocomplete-dropdown.active,
        .emoji-autocomplete.active {
            display: block;
        }

        .autocomplete-item .nym-suffix {
            opacity: 0.7;
            font-size: 0.9em;
            font-weight: 100;
        }

        .autocomplete-item strong {
            color: var(--primary);
        }

        .autocomplete-item,
        .emoji-item {
            padding: 8px 10px;
            cursor: pointer;
            color: var(--text-dim);
            transition: all 0.2s;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected,
        .emoji-item:hover,
        .emoji-item.selected {
            background: rgba(0, 255, 0, 0.1);
            color: var(--text);
        }

        .autocomplete-item strong {
            color: var(--primary);
        }

        .emoji-item {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .emoji-item-emoji {
            font-size: 18px;
        }

        .emoji-item-name {
            font-size: 12px;
        }

        .command-palette {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 5px;
            display: none;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 -5px 20px rgba(0, 255, 0, 0.2);
            margin-bottom: 5px;
        }

        .command-palette.active {
            display: block;
        }

        .command-item {
            padding: 8px 10px;
            cursor: pointer;
            color: var(--text-dim);
            display: flex;
            justify-content: space-between;
            transition: all 0.2s;
        }

        .command-item:hover,
        .command-item.selected {
            background: rgba(0, 255, 0, 0.1);
            color: var(--text);
        }

        .command-item:active {
            background: rgba(0, 255, 0, 0.2);
        }

        .command-name {
            color: var(--primary);
            font-weight: bold;
        }

        .command-desc {
            font-size: 12px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 15px 20px;
            max-width: 350px;
            animation: slideIn 0.3s;
            z-index: 2000;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.4);
        }

        @keyframes slideIn {
            from {
                transform: translateX(120%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification-title {
            color: var(--primary);
            margin-bottom: 5px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
        }

        .notification-body {
            color: var(--text);
            font-size: 13px;
        }

        .notification-time {
            color: var(--text-dim);
            font-size: 10px;
            margin-top: 5px;
        }

        .file-input {
            display: none;
        }

        .upload-progress {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 10px;
            margin-bottom: 5px;
            display: none;
        }

        .upload-progress.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            transition: width 0.3s;
        }

        .reaction-picker,
        .enhanced-emoji-modal {
            position: absolute;
            bottom: calc(100% + 5px);
            right: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 10px;
            display: none;
            box-shadow: 0 -5px 20px rgba(0, 255, 0, 0.2);
            z-index: 600;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
        }

        .reaction-picker.active,
        .enhanced-emoji-modal.active {
            display: block;
        }

        .emoji-modal-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 10px;
        }

        .emoji-search-input {
            flex: 1;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 5px;
            font-size: 12px;
            outline: none;
        }

        .emoji-section {
            margin-bottom: 15px;
        }

        .emoji-section-title {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
        }

        .reaction-emoji,
        .emoji-option {
            background: var(--bg);
            border: 1px solid transparent;
            padding: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
            text-align: center;
        }

        .reaction-emoji:hover,
        .emoji-option:hover {
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.1);
            transform: scale(1.2);
        }

        .verified-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            margin-left: 5px;
            margin-right: 5px;
            position: relative;
            cursor: help;
            transition: transform 0.2s, box-shadow 0.2s;
            vertical-align: middle;
        }

        .verified-badge::before {
            content: "";
            position: absolute;
            inset: 0;
            background: var(--primary);
            --lobes: conic-gradient(from 0deg,
                    #000 0 22.5deg, transparent 22.5deg 45deg,
                    #000 45deg 67.5deg, transparent 67.5deg 90deg,
                    #000 90deg 112.5deg, transparent 112.5deg 135deg,
                    #000 135deg 157.5deg, transparent 157.5deg 180deg,
                    #000 180deg 202.5deg, transparent 202.5deg 225deg,
                    #000 225deg 247.5deg, transparent 247.5deg 270deg,
                    #000 270deg 292.5deg, transparent 292.5deg 315deg,
                    #000 315deg 337.5deg, transparent 337.5deg 360deg);
            --round: radial-gradient(circle at 50% 50%, #000 70%, transparent 71%);
            -webkit-mask: var(--lobes), var(--round);
            -webkit-mask-composite: source-in;
            mask: var(--lobes);
            mask-composite: intersect;
        }

        .verified-badge::after {
            content: "✔";
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -52%);
            font-size: 25px;
            font-weight: 900;
            color: #1DA1F2;
            line-height: 1;
        }

        .verified-badge:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px var(--primary);
        }

        .share-channel-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.2s, transform 0.2s;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .share-channel-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .share-channel-btn svg {
            fill: var(--primary);
        }

        .share-modal {
            max-width: 500px;
        }

        .share-url-container {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            align-items: stretch;
        }

        .share-url-input {
            flex: 1;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px;
            font-family: var(--font-mono);
            font-size: 14px;
            outline: none;
        }

        .share-url-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .copy-url-btn {
            background: var(--bg);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 10px 20px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .copy-url-btn:hover {
            background: var(--primary);
            color: var(--bg);
            box-shadow: 0 0 10px var(--primary);
        }

        .copy-url-btn.copied {
            background: var(--primary);
            color: var(--bg);
        }

        .share-options {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .share-option-btn {
            flex: 1;
            padding: 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .share-option-btn:hover {
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.1);
        }

        .share-option-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .list-item.search-hidden {
            display: none !important;
        }

        .message-content img.blurred {
            filter: blur(20px);
            transition: filter 0.3s ease;
        }

        .message-content img.blurred:hover {
            filter: blur(10px);
        }

        .message-time {
            cursor: help;
            position: relative;
        }

        .message-time:hover::after {
            content: attr(data-full-time);
            position: absolute;
            bottom: 100%;
            left: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 4px 8px;
            font-size: 11px;
            white-space: nowrap;
            margin-bottom: 4px;
            z-index: 1000;
            pointer-events: none;
        }

        .context-menu-item.moderation {
            border-top: 1px solid rgba(0, 255, 0, 0.1);
        }

        .context-menu-item.moderation:first-of-type {
            border-top: 1px solid var(--border);
            margin-top: 5px;
            padding-top: 5px;
        }

        .context-menu-item[style*="COMMUNITY MODERATION"] {
            font-size: 10px !important;
            color: var(--text-dim) !important;
            padding: 5px 15px !important;
            cursor: default !important;
        }

        .context-menu-item[style*="COMMUNITY MODERATION"]:hover {
            background: none !important;
            padding-left: 15px !important;
        }

        .channel-option-btn:hover {
            background: var(--secondary) !important;
            color: var(--bg) !important;
        }

        .channel-option-btn:hover span {
            color: var(--bg) !important;
        }

        .geohash-explorer-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .geohash-explorer-modal.active {
            display: flex;
        }

        .geohash-explorer-content {
            width: 90%;
            height: 90%;
            max-width: 1200px;
            max-height: 800px;
            background: var(--bg-secondary);
            border: 2px solid var(--primary);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .geohash-explorer-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-tertiary);
        }

        .geohash-explorer-title {
            font-size: 18px;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .geohash-explorer-close {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 5px 15px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .geohash-explorer-close:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: var(--bg);
            box-shadow: 0 0 10px var(--primary);
        }

        .geohash-explorer-body {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .geohash-globe-container {
            width: 100%;
            height: 100%;
            position: relative;
            background: #000000;
            overflow: hidden;
        }

        #globeViz {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        .geohash-controls,
        .geohash-legend,
        .geohash-info-panel {
            position: absolute;
            z-index: 10;
        }

        .geohash-globe-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .geohash-globe-canvas:active {
            cursor: grabbing;
        }

        .geohash-info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--primary);
            padding: 15px;
            max-width: 300px;
            font-size: 12px;
            color: var(--text);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .geohash-info-title {
            color: var(--primary);
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: lowercase;
            letter-spacing: 1px;
        }

        .geohash-info-item {
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(0, 255, 0, 0.2);
        }

        .geohash-info-item:last-child {
            border-bottom: none;
        }

        .geohash-join-btn {
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            background: var(--bg);
            border: 1px solid var(--primary);
            color: var(--primary);
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .geohash-join-btn:hover {
            background: var(--primary);
            color: var(--bg);
            box-shadow: 0 0 10px var(--primary);
        }

        .geohash-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .geohash-control-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 12px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 11px;
            transition: all 0.2s;
        }

        .geohash-control-btn:hover {
            border-color: var(--primary);
            background: var(--primary);
            color: var(--bg);
            box-shadow: 0 0 10px var(--primary);
        }

        .geohash-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--border);
            padding: 10px;
            font-size: 10px;
        }

        .geohash-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }

        .geohash-legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .tutorial-overlay {
            position: fixed;
            inset: 0;
            z-index: 999999;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .tutorial-overlay.active {
            display: flex;
        }

        .tutorial-highlight {
            position: fixed;
            border: 2px solid var(--secondary);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), 0 0 0 9999px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            pointer-events: none;
            z-index: 999999;
            transition: all 0.2s ease;
        }

        .tutorial-card {
            position: fixed;
            max-width: min(420px, 92vw);
            background: var(--bg-secondary);
            border: 2px solid var(--primary);
            color: var(--text);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.4);
            font-family: var(--font-mono);
            padding: 16px;
            z-index: 1000000;
            pointer-events: auto;
        }

        .tutorial-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 8px;
        }

        .tutorial-title {
            color: var(--primary);
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-size: 14px;
        }

        .tutorial-skip {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 6px 10px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tutorial-skip:hover {
            color: var(--text);
            border-color: var(--primary);
        }

        .tutorial-body {
            font-size: 13px;
            line-height: 1.4;
            color: var(--text);
        }

        .tutorial-progress {
            margin-top: 10px;
            font-size: 11px;
            color: var(--text-dim);
        }

        .tutorial-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .tutorial-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 14px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tutorial-btn:hover {
            background: var(--primary);
            color: var(--bg);
            box-shadow: 0 0 10px var(--primary);
        }

        @media (max-width: 768px) {
            .tutorial-card {
                max-width: 94vw;
                padding: 14px;
            }

            .tutorial-body {
                font-size: 13px;
            }

            .geohash-explorer-content {
                width: 100%;
                height: 100%;
                max-width: 100%;
                max-height: 100%;
            }

            .geohash-info-panel {
                position: fixed;
                bottom: 60px;
                top: auto;
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .geohash-controls {
                bottom: 10px;
                left: 10px;
            }

            .geohash-legend {
                bottom: 10px;
                right: 10px;
                font-size: 9px;
                padding: 8px;
            }

            pre {
                font-size: 10px;
            }

            .nav-section {
                flex-shrink: 0;
            }

            .channel-list,
            .pm-list {
                max-height: none;
                overflow-y: visible;
            }

            .user-list {
                flex: 1 1 auto;
                overflow-y: visible;
                max-height: none;
            }

            #userListContent {
                max-height: none;
            }

            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100%;
                z-index: 9999;
                transform: translateX(-100%);
                width: 280px;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                height: 100vh;
            }

            .sidebar-header {
                border-bottom: 0px;
            }

            .sidebar.open {
                transform: translateX(0);
                box-shadow: 5px 0 20px rgba(0, 0, 0, 0.8);
            }

            .sidebar-actions {
                display: flex;
            }

            .mobile-menu-toggle {
                display: block;
            }

            .main-content {
                display: flex;
                flex-direction: column;
                height: 100%;
                position: relative;
            }

            .input-container {
                position: relative;
                bottom: auto;
                left: auto;
                right: auto;
                flex-shrink: 0;
                padding: 10px;
                flex-direction: column;
                gap: 10px;
                background: var(--bg-secondary);
                border-top: 2px solid var(--border);
                z-index: 500;
                max-height: 200px;
            }

            .container {
                height: 100vh;
                height: var(--viewport-height, 100vh);
            }

            .messages-container {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding: 10px 5px;
                padding-bottom: 10px;
                margin-bottom: 0;
            }

            @supports (-webkit-touch-callout: none) {
                .input-container {
                    padding-bottom: calc(10px + env(safe-area-inset-bottom));
                }
            }

            .message-input {
                font-size: 16px !important;
                min-height: 44px;
                max-height: 100px;
                -webkit-appearance: none;
                border-radius: 0;
            }

            .message-input:focus {
                font-size: 16px !important;
                outline: none;
                border-color: var(--primary);
                box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            }

            .modal-content {
                margin: 20px;
            }

            .header-actions {
                display: none;
            }

            .chat-header {
                padding: 15px 10px;
                padding-top: 30px;
            }

            .input-wrapper {
                width: 100%;
            }

            .input-buttons {
                width: 100%;
                display: flex;
                justify-content: space-between;
                gap: 10px;
            }

            .icon-btn.input-btn {
                flex: 1;
            }

            .send-btn {
                flex: 2;
                padding: 10px;
                font-size: 11px;
            }

            .zap-amounts {
                grid-template-columns: repeat(2, 1fr);
            }

            .reaction-btn {
                display: none;
            }

            .message {
                flex-direction: column;
                gap: 5px;
            }

            .message-time,
            .message-author {
                display: inline;
                margin-right: 10px;
            }

            .message-content {
                width: 100%;
                margin-top: 5px;
            }

            .message-content img {
                max-width: 100%;
            }

            .emoji-picker,
            .enhanced-emoji-modal {
                position: fixed;
                bottom: auto;
                top: auto;
                left: 50%;
                transform: translateX(-50%);
                bottom: 60px;
                right: auto;
                margin-bottom: 0;
                margin-top: 0;
                max-width: 90%;
                z-index: 1000;
            }

            .emoji-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .emoji-picker {
            position: absolute;
            bottom: 100%;
            right: 60px;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 10px;
            display: none;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            max-width: 320px;
            max-height: 200px;
            overflow-y: auto;
            overflow-x: scroll;
            box-shadow: 0 -5px 20px rgba(0, 255, 0, 0.2);
            margin-bottom: 5px;
            z-index: 500;
        }

        .emoji-picker.active {
            display: grid;
        }

        .emoji-btn {
            background: var(--bg);
            border: 1px solid transparent;
            padding: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .emoji-btn:hover {
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.1);
            transform: scale(1.2);
        }

        @media (max-width: 480px) {

            .emoji-picker,
            .enhanced-emoji-modal {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        .loader {
            display: inline-block;
            width: 15px;
            height: 15px;
            border: 2px solid var(--text-dim);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--text-dim);
            border: 1px solid var(--border);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        .bitchat-user-0 {
            color: #FF6B35;
        }

        .bitchat-user-1 {
            color: #F7931A;
        }

        .bitchat-user-2 {
            color: #FFD200;
        }

        .bitchat-user-3 {
            color: #cccccc;
        }

        .bitchat-user-4 {
            color: #5CB3FF;
        }

        .bitchat-user-5 {
            color: #B565FF;
        }

        .bitchat-user-6 {
            color: #C40233;
        }

        .bitchat-user-7 {
            color: #FF1493;
        }

        .bitchat-user-8 {
            color: #A3B5E0;
        }

        .bitchat-user-9 {
            color: #B491FF;
        }

        .bitchat-user-10 {
            color: #FF4500;
        }

        .bitchat-user-11 {
            color: #20B2AA;
        }

        .bitchat-user-12 {
            color: #FF69B4;
        }

        .bitchat-user-13 {
            color: #00BFBF;
        }

        .bitchat-user-14 {
            color: #FF8C00;
        }

        .bitchat-user-15 {
            color: #6B9AFF;
        }

        body.theme-ghost {
            --primary: #ffffff;
            --secondary: #cccccc;
            --warning: #888888;
            --danger: #666666;
            --purple: #999999;
            --blue: #bbbbbb;
            --lightning: #cccccc;
            --bg: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #111111;
            --text: #ffffff;
            --text-dim: #666666;
            --text-bright: #ffffff;
            --border: #333333;
        }

        body.theme-ghost::before {
            background: repeating-linear-gradient(0deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 255, 255, 0.02) 2px,
                    rgba(255, 255, 255, 0.02) 4px);
        }
    </style>
</head>

<body>
    <div class="mobile-overlay" id="mobileOverlay" onclick="nym.closeSidebar()"></div>
    <button class="mobile-menu-toggle" onclick="toggleSidebar()">☰</button>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" id="ctxReact">React</div>
        <div class="context-menu-item" id="ctxMention">Mention</div>
        <div class="context-menu-item lightning" id="ctxZap" style="display: none;">⚡ Zap</div>
        <div class="context-menu-item" id="ctxPM">Private Message</div>
        <div class="context-menu-item" id="ctxQuote">Quote Message</div>
        <div class="context-menu-item" id="ctxCopyPubkey">Copy Pubkey</div>
        <div class="context-menu-item danger" id="ctxBlock">Block User</div>
    </div>

    <div class="container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="logo">NYM</div>
                <div class="tagline">Ephemeral Nostr Chat</div>
                <div class="nym-display" onclick="editNick()">
                    <div class="nym-label">Your Nym (click to edit)</div>
                    <div class="nym-value" id="currentNym">anonymous</div>
                </div>
                <div class="status-indicator">
                    <span class="status-dot" id="statusDot"></span>
                    <span id="connectionStatus">Disconnected</span>
                </div>
            </div>

            <div class="sidebar-actions">
                <button class="icon-btn" onclick="showChannelModal(); nym.closeSidebar();">+ Channel</button>
                <button class="icon-btn" onclick="showSettings(); nym.closeSidebar();">Settings</button>
                <button class="icon-btn" onclick="showAbout(); nym.closeSidebar();">About</button>
                <button class="icon-btn" onclick="signOut(); nym.closeSidebar();" title="Logout">Logout</button>
            </div>

            <div class="nav-section">
                <div class="nav-title">
                    <span class="nav-title-text">Channels</span>
                    <span class="discover-icon" style="padding-right:30px;" onclick="nym.showGeohashExplorer()"
                        title="Explore geohash channels globally">
                        <svg viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="10" fill="none" stroke-width="2" />
                            <path
                                d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"
                                fill="none" stroke-width="2" />
                        </svg>
                    </span>
                    <span class="search-icon" onclick="toggleSearch('channelSearch')">
                        <svg viewBox="0 0 24 24">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </span>
                </div>
                <input type="text" class="search-input" id="channelSearch" placeholder="Search channels..."
                    oninput="this.value = this.value.toLowerCase(); nym.handleChannelSearch(this.value)"
                    onkeyup="nym.handleChannelSearch(this.value)">
                <div id="channelSearchResults"></div>
                <div class="channel-list" id="channelList">
                    <div class="channel-item active" data-channel="bar" data-geohash="">
                        <span class="channel-name">#bar</span>
                        <div class="channel-badges">
                            <span class="pin-btn" onclick="event.stopPropagation(); nym.togglePin('bar', '')">
                                <svg viewBox="0 0 24 24">
                                    <path d="M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z" />
                                </svg>
                            </span>
                            <span class="std-badge">EPH</span>
                            <span class="unread-badge" style="display:none">0</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="nav-section">
                <div class="nav-title">
                    <span class="nav-title-text">Private Messages</span>
                    <span class="search-icon" onclick="toggleSearch('pmSearch')">
                        <svg viewBox="0 0 24 24">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </span>
                </div>
                <input type="text" class="search-input" id="pmSearch" placeholder="Search PMs..."
                    onkeyup="nym.filterPMs(this.value)">
                <div class="pm-list" id="pmList"></div>
            </div>

            <div class="user-list" id="userList">
                <div class="nav-title">
                    <span class="nav-title-text">Active Nyms</span>
                    <span class="search-icon" onclick="toggleSearch('userSearch')">
                        <svg viewBox="0 0 24 24">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </span>
                </div>
                <input type="text" class="search-input" id="userSearch" placeholder="Search users..."
                    onkeyup="nym.filterUsers(this.value)">
                <div id="userListContent"></div>
            </div>
        </aside>

        <main class="main-content">
            <header class="chat-header">
                <div class="channel-info">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div>
                            <div class="channel-title" id="currentChannel">#bar</div>
                            <div class="channel-meta" id="channelMeta">0 nyms in channel</div>
                        </div>
                        <button class="share-channel-btn" id="shareChannelBtn" onclick="nym.shareChannel()"
                            title="Share channel URL">
                            <svg viewBox="0 0 24 24" width="20" height="20">
                                <path
                                    d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z" />
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="header-actions">
                    <button class="icon-btn" onclick="showChannelModal()">+ Channel</button>
                    <button class="icon-btn" onclick="showSettings()">Settings</button>
                    <button class="icon-btn" onclick="showAbout()">About</button>
                    <button class="icon-btn" onclick="signOut()" title="Logout">Logout</button>
                </div>
            </header>

            <div class="messages-container" id="messagesContainer">
                <div class="system-message">
                    ═══ Booting up NYM ═══
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator"></div>

            <div class="input-container">
                <div class="input-wrapper">
                    <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
                    <div class="emoji-autocomplete" id="emojiAutocomplete"></div>
                    <div class="command-palette" id="commandPalette"></div>
                    <div class="upload-progress" id="uploadProgress">
                        <div>Uploading image...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                    </div>
                    <textarea class="message-input" id="messageInput" placeholder="Type a message or / for commands..."
                        rows="1" disabled></textarea>
                </div>
                <div class="input-buttons">
                    <input type="file" class="file-input" id="fileInput" accept="image/*">
                    <button class="icon-btn input-btn" onclick="selectImage()" title="Upload Image">
                        <svg viewBox="0 0 24 24">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                    </button>
                    <button class="icon-btn input-btn" onclick="nym.toggleEmojiPicker()" title="Emoji">
                        <svg viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                            <circle cx="9" cy="9" r="1"></circle>
                            <circle cx="15" cy="9" r="1"></circle>
                        </svg>
                    </button>
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()" disabled>SEND</button>
                </div>
                <div class="emoji-picker" id="emojiPicker"></div>
            </div>
        </main>
    </div>

    <!-- Image Modal -->
    <div class="image-modal" id="imageModal" onclick="closeImageModal()">
        <span class="image-modal-close" onclick="closeImageModal()">×</span>
        <img id="modalImage" src="" alt="Expanded image">
    </div>

    <!-- Nick Edit Modal -->
    <div class="modal nick-edit-modal" id="nickEditModal">
        <div class="modal-content">
            <div class="modal-header">Change Your Nym's nickname</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">New Nym nick</label>
                    <input type="text" class="form-input" id="newNickInput" placeholder="Enter new nym" maxlength="20">
                    <div class="form-hint">Your ephemeral pseudonym nickname for this session</div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="icon-btn" onclick="closeModal('nickEditModal')">Cancel</button>
                <button class="send-btn" onclick="changeNick()">Change</button>
            </div>
        </div>
    </div>

    <!-- Initial Setup Modal -->
    <div class="modal active" id="setupModal">
        <div class="modal-content">
            <div class="modal-header">Welcome to NYM<br /><label style="color: var(--warning); margin-top:5px;"
                    class="form-label">Ephemeral, anonymous, decentralized chat</label></div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Connection Mode</label>
                    <select class="form-select" id="connectionMode">
                        <option value="ephemeral">Ephemeral (Auto-generate temporary keys)</option>
                        <option value="extension">Use Nostr Extension (Persistent identity)</option>
                        <option value="nsec">Use NSEC Private Key (Persistent identity)</option>
                    </select>
                </div>

                <!-- NSEC -->
                <div class="form-group" id="nsecGroup" style="display:none">
                    <label class="form-label">Enter your NSEC</label>
                    <input type="password" class="form-input" id="nsecInput" placeholder="nsec1...">
                    <div class="form-hint">Your private key will be stored locally</div>
                </div>

                <div class="form-group" id="nymGroup">
                    <label class="form-label">Choose Your Nym's nickname (optional)</label>
                    <input type="text" class="form-input" id="nymInput" placeholder="Leave empty for random nick"
                        maxlength="20">
                    <div class="form-hint" id="nymHint">Your ephemeral pseudonym nickname for this session</div>

                    <div id="autoEphemeralGroup" style="margin-top: 15px;">
                        <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="autoEphemeralCheckbox"
                                style="margin-right: 10px; width: auto; cursor: pointer;">
                            <span style="color: var(--text-dim);">Automatically assign new ephemeral nym on each session
                                restart to skip the welcome screen</span>
                        </label>
                    </div>
                </div>

                <div
                    style="color: var(--warning); font-size: 12px; margin-top: 15px; padding: 10px; border: 1px solid var(--warning);">
                    NOTE: Channels are bridged with Bitchat geohash. Messages are
                    public and temporary; sent across the Nostr network. Your nym exists
                    only for this session and will be burned.
                </div>
            </div>
            <div class="modal-actions" style="margin-bottom:20px;">
                <button class="send-btn" onclick="initializeNym()">Enter NYM</button>
            </div>
            <span style="color: var(--text-dim);">By entering, you agree to our <a
                    href="https://github.com/Spl0itable/NYM/blob/main/TOS.md" target="_blank" rel="noopener"
                    style="color: var(--secondary)">Terms of Service</a> and <a
                    href="https://github.com/Spl0itable/NYM/blob/main/PP.md" target="_blank" rel="noopener"
                    style="color: var(--secondary)">Privacy Policy</a>.</span>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">Settings</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Connected Relays</label>
                    <div id="connectedRelaysList"
                        style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); padding: 10px; background: var(--bg);">
                        <div style="color: var(--text-dim); font-size: 12px;">Loading relay list...</div>
                    </div>
                    <button class="icon-btn" onclick="nym.refreshRelays()"
                        style="margin-top: 10px; width: 100%;">Refresh Relay List</button>
                </div>

                <div class="form-group">
                    <label class="form-label">Sort Geohash Channels by Proximity</label>
                    <select class="form-select" id="proximitySelect">
                        <option value="false">Disabled</option>
                        <option value="true">Enabled (requires location access)</option>
                    </select>
                    <div class="form-hint">Sort geohash channels by distance from your location</div>
                </div>

                <div class="form-group">
                    <label class="form-label">⚡ Lightning Address</label>
                    <input type="text" class="form-input" id="lightningAddressInput"
                        placeholder="your@lightning-address.com">
                    <div class="form-hint">Your Lightning address for receiving zaps</div>
                </div>

                <div class="form-group">
                    <label class="form-label">Theme</label>
                    <select class="form-select" id="themeSelect">
                        <option value="bitchat">Bitchat (Multicolor)</option>
                        <option value="matrix">Matrix Green</option>
                        <option value="amber">Amber Terminal</option>
                        <option value="cyber">Cyberpunk</option>
                        <option value="hacker">Hacker Blue</option>
                        <option value="ghost">Ghost (B&W)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Disappearing PM (forward secrecy)</label>
                    <select class="form-select" id="dmForwardSecrecySelect">
                        <option value="false">Disabled</option>
                        <option value="true">Enabled</option>
                    </select>
                    <div class="form-hint">
                        When enabled, your private messages include an "expiration" tag (NIP‑40) so relays/clients can
                        delete them after the period chosen when enabled.
                    </div>
                </div>

                <div class="form-group" id="dmTTLGroup">
                    <label class="form-label">Disappear After</label>
                    <select class="form-select" id="dmTTLSelect">
                        <option value="3600">1 hour</option>
                        <option value="21600">6 hours</option>
                        <option value="86400" selected>1 day</option>
                        <option value="259200">3 days</option>
                        <option value="604800">7 days</option>
                    </select>
                    <div class="form-hint">This sets the "expiration" timestamp on each outgoing gift‑wrapped PM.</div>
                </div>

                <div class="form-group">
                    <label class="form-label">Notification Sound</label>
                    <select class="form-select" id="soundSelect">
                        <option value="beep">Classic Beep</option>
                        <option value="icq">ICQ Uh-Oh</option>
                        <option value="msn">MSN Alert</option>
                        <option value="none">Silent</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Auto-scroll Messages</label>
                    <select class="form-select" id="autoscrollSelect">
                        <option value="true">Enabled</option>
                        <option value="false">Disabled</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Show Timestamps</label>
                    <select class="form-select" id="timestampSelect">
                        <option value="true">Show</option>
                        <option value="false">Hide</option>
                    </select>
                </div>

                <div class="form-group" id="timeFormatGroup">
                    <label class="form-label">Time Format</label>
                    <select class="form-select" id="timeFormatSelect">
                        <option value="24hr" selected>24-hour (14:30)</option>
                        <option value="12hr">12-hour (2:30 PM)</option>
                    </select>
                </div>

                <div class="form-group" id="autoEphemeralSettingGroup" style="display: none;">
                    <label class="form-label">Auto Ephemeral Mode on Restart</label>
                    <select class="form-select" id="autoEphemeralSelect">
                        <option value="false">Disabled</option>
                        <option value="true">Enabled (auto sign-in)</option>
                    </select>
                    <div class="form-hint">Automatically sign in with ephemeral mode on app restart</div>
                </div>


                <div class="form-group">
                    <label class="form-label">Blur Images from Others</label>
                    <select class="form-select" id="blurImagesSelect">
                        <option value="true">Enabled (blur by default)</option>
                        <option value="false">Disabled (show all images)</option>
                    </select>
                    <div class="form-hint">Blur images shared by others until clicked. Your own images are never
                        blurred.</div>
                </div>

                <div class="form-group">
                    <label class="form-label">Blocked Keywords/Phrases</label>
                    <input type="text" class="form-input" id="newKeywordInput"
                        placeholder="Add keyword or phrase to block">
                    <button class="icon-btn" onclick="nym.addBlockedKeyword()"
                        style="margin-top: 10px; width: 100%;">Add Keyword</button>
                    <div class="keyword-list" id="keywordList" style="margin-top: 10px;">
                        <div style="color: var(--text-dim); font-size: 12px;">No blocked keywords</div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Blocked Channels</label>
                    <div class="blocked-list" id="blockedChannelsList">
                        <div style="color: var(--text-dim); font-size: 12px;">No blocked channels</div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Blocked Users</label>
                    <div class="blocked-list" id="blockedList">
                        <div style="color: var(--text-dim); font-size: 12px;">No blocked users</div>
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="icon-btn" onclick="closeModal('settingsModal')">Cancel</button>
                <button class="send-btn" onclick="saveSettings()">Save</button>
            </div>
        </div>
    </div>

    <!-- Channel Modal -->
    <div class="modal" id="channelModal">
        <div class="modal-content">
            <div class="modal-header">Join/Create Channel</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Channel Type</label>
                    <select class="form-select" id="channelTypeSelect">
                        <option value="standard">Standard Channel (Ephemeral)</option>
                        <option value="geohash">Location-based (Geohash)</option>
                        <option value="community">Community Channel (Requires Login)</option>
                    </select>
                </div>

                <div class="form-group" id="standardChannelGroup">
                    <label class="form-label">Channel Name</label>
                    <input type="text" class="form-input" id="channelNameInput" placeholder="random"
                        oninput="this.value = this.value.toLowerCase().replace(/[^a-z0-9-]/g, '')">
                    <div class="form-hint">Enter channel name without # (e.g., "random" for #random). No spaces allowed
                        - use hyphens.</div>
                </div>

                <div class="form-group" id="geohashGroup" style="display:none">
                    <label class="form-label">Geohash</label>
                    <input type="text" class="form-input" id="geohashInput" placeholder="e.g., w1, dr5r, etc."
                        maxlength="12"
                        oninput="this.value = this.value.toLowerCase().replace(/[^0-9bcdefghjkmnpqrstuvwxyz]/g, '')">
                    <div class="form-hint">Enter a geohash code (valid chars: 0-9, b-z except a,i,l,o)</div>
                </div>

                <div id="communityChannelGroup" style="display:none">
                    <div class="form-group">
                        <label class="form-label">Community Name</label>
                        <input type="text" class="form-input" id="communityNameInput" placeholder="bitcoin"
                            oninput="this.value = this.value.toLowerCase().replace(/[^a-z0-9-]/g, '')">
                        <div class="form-hint">A unique name for your community. No spaces allowed - use hyphens.</div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <textarea class="form-textarea" id="communityDescInput"
                            placeholder="Describe your community (optional)"></textarea>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Community Image URL (optional)</label>
                        <input type="text" class="form-input" id="communityImageInput"
                            placeholder="https://example.com/image.png">
                        <div class="form-hint">URL to an image representing your community</div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Privacy</label>
                        <select class="form-select" id="communityPrivacySelect">
                            <option value="public">Public (anyone can join)</option>
                            <option value="private">Private (invite only)</option>
                        </select>
                    </div>

                    <div
                        style="color: var(--warning); font-size: 11px; margin-top: 10px; padding: 8px; border: 1px solid var(--warning);">
                        NOTE: Community channels are persistent and tied to your Nostr identity. You will be the admin.
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="icon-btn" onclick="closeModal('channelModal')">Cancel</button>
                <button class="send-btn" onclick="joinOrCreateChannel()">Join/Create</button>
            </div>
        </div>
    </div>

    <!-- Community Settings Modal -->
    <div class="modal" id="communitySettingsModal">
        <div class="modal-content">
            <div class="modal-header">Community Settings</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Community Name</label>
                    <div id="communityNameDisplay" style="font-size: 16px; color: var(--primary); padding: 8px 0;">
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Community Image</label>
                    <div id="communityImagePreview" style="margin-bottom: 10px; display: none;">
                        <img id="communityImagePreviewImg" src="" alt="Community image"
                            style="max-width: 200px; max-height: 200px; border: 1px solid var(--border);">
                    </div>
                    <input type="text" class="form-input" id="communityImageEdit"
                        placeholder="https://example.com/image.png">
                    <div class="form-hint">URL to an image representing your community</div>
                </div>

                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-textarea" id="communityDescEdit"
                        placeholder="Community description"></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label">Privacy</label>
                    <select class="form-select" id="communityPrivacyEdit">
                        <option value="public">Public (anyone can join)</option>
                        <option value="private">Private (invite only)</option>
                    </select>
                    <div class="form-hint">Changing privacy will take effect immediately</div>
                </div>

                <div class="form-group">
                    <label class="form-label">Blocked Keywords/Phrases</label>
                    <input type="text" class="form-input" id="newCommunityKeywordInput"
                        placeholder="Add keyword or phrase to block">
                    <button class="icon-btn" onclick="nym.addCommunityKeyword()"
                        style="margin-top: 10px; width: 100%;">Add Keyword</button>
                    <div class="keyword-list" id="communityKeywordList"
                        style="margin-top: 10px; max-height: 150px; overflow-y: auto; border: 1px solid var(--border); padding: 10px; background: var(--bg);">
                        <div style="color: var(--text-dim); font-size: 12px;">No blocked keywords</div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Moderators</label>
                    <div id="communityModsList"
                        style="max-height: 150px; overflow-y: auto; border: 1px solid var(--border); padding: 10px; background: var(--bg);">
                        <div style="color: var(--text-dim); font-size: 12px;">Loading moderators...</div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <input type="text" class="form-input" id="addModInput" placeholder="Enter nym or nym#xxxx"
                            style="flex: 1;">
                        <button class="icon-btn" onclick="nym.addModFromSettings()">Add Mod</button>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Banned Users</label>
                    <div id="communityBansList"
                        style="max-height: 150px; overflow-y: auto; border: 1px solid var(--border); padding: 10px; background: var(--bg);">
                        <div style="color: var(--text-dim); font-size: 12px;">No banned users</div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Statistics</label>
                    <div
                        style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border);">
                        <div style="text-align: center;">
                            <div style="font-size: 20px; color: var(--primary);" id="statMembers">0</div>
                            <div style="font-size: 11px; color: var(--text-dim);">Members</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 20px; color: var(--secondary);" id="statMods">0</div>
                            <div style="font-size: 11px; color: var(--text-dim);">Moderators</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 20px; color: var(--danger);" id="statBanned">0</div>
                            <div style="font-size: 11px; color: var(--text-dim);">Banned</div>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label" style="color: var(--danger);">Danger Zone</label>
                    <button class="icon-btn" onclick="nym.deleteCommunity()"
                        style="width: 100%; background: var(--bg); border-color: var(--danger); color: var(--danger);">
                        Delete Community
                    </button>
                    <div class="form-hint" style="color: var(--danger);">This action cannot be undone</div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="icon-btn" onclick="closeModal('communitySettingsModal')">Close</button>
                <button class="send-btn" onclick="nym.saveCommunitySettings()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Zap Modal -->
    <div class="modal zap-modal" id="zapModal">
        <div class="modal-content">
            <div class="modal-header">⚡ Send Lightning Zap</div>
            <div class="modal-body">
                <div id="zapRecipientInfo" style="text-align: center; margin-bottom: 20px; color: var(--text-dim);">
                </div>

                <div id="zapAmountSection">
                    <div class="form-group">
                        <label class="form-label">Select Amount</label>
                        <div class="zap-amounts">
                            <button class="zap-amount-btn" data-amount="21">
                                <span class="sats">21</span>
                                sats
                            </button>
                            <button class="zap-amount-btn" data-amount="100">
                                <span class="sats">100</span>
                                sats
                            </button>
                            <button class="zap-amount-btn" data-amount="500">
                                <span class="sats">500</span>
                                sats
                            </button>
                            <button class="zap-amount-btn" data-amount="1000">
                                <span class="sats">1K</span>
                                sats
                            </button>
                            <button class="zap-amount-btn" data-amount="5000">
                                <span class="sats">5K</span>
                                sats
                            </button>
                            <button class="zap-amount-btn" data-amount="10000">
                                <span class="sats">10K</span>
                                sats
                            </button>
                        </div>
                    </div>

                    <div class="form-group zap-custom-amount">
                        <input type="number" class="form-input" id="zapCustomAmount" placeholder="Custom amount (sats)"
                            min="1">
                    </div>

                    <div class="form-group zap-comment">
                        <label class="form-label">Comment (optional)</label>
                        <input type="text" class="form-input" id="zapComment" placeholder="Add a comment to your zap">
                    </div>
                </div>

                <div id="zapInvoiceSection" style="display: none;">
                    <div class="zap-status checking" id="zapStatus">
                        <span class="loader"></span> Generating invoice...
                    </div>

                    <div id="zapInvoiceDisplay" style="display: none;">
                        <div class="zap-invoice-qr" id="zapQRCode"></div>
                        <div class="zap-invoice" id="zapInvoice"></div>
                        <div class="zap-invoice-actions">
                            <button class="icon-btn" onclick="nym.copyZapInvoice()" style="flex: 1;">Copy
                                Invoice</button>
                            <button class="icon-btn" onclick="nym.openInWallet()" style="flex: 1;">Open Wallet</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="icon-btn" onclick="nym.closeZapModal()">Cancel</button>
                <button class="send-btn" id="zapSendBtn" onclick="nym.generateZapInvoice()">Generate Invoice</button>
            </div>
        </div>
    </div>

    <!-- Share Channel Modal -->
    <div class="modal" id="shareModal">
        <div class="modal-content share-modal">
            <div class="modal-header">Share Channel</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Channel URL</label>
                    <div class="share-url-container">
                        <input type="text" class="share-url-input" id="shareUrlInput" readonly>
                        <button class="copy-url-btn" onclick="nym.copyShareUrl()">COPY</button>
                    </div>
                    <div class="form-hint">Share this URL to invite others to this channel</div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="icon-btn" onclick="closeModal('shareModal')">Close</button>
            </div>
        </div>
    </div>

    <!-- Geohash Explorer Modal -->
    <div class="geohash-explorer-modal" id="geohashExplorerModal">
        <div class="geohash-explorer-content">
            <div class="geohash-explorer-header">
                <div class="geohash-explorer-title">Geohash Explorer</div>
                <button class="geohash-explorer-close" onclick="nym.closeGeohashExplorer()">Close</button>
            </div>
            <div class="geohash-explorer-body">
                <div class="geohash-globe-container" id="geohashGlobeCanvas">
                    <canvas class="geohash-globe-canvas" id="geohashGlobeCanvas"></canvas>

                    <div class="geohash-info-panel" id="geohashInfoPanel" style="display: none;">
                        <div class="geohash-info-title" id="geohashInfoTitle">Channel Info</div>
                        <div id="geohashInfoContent"></div>
                        <button class="geohash-join-btn" id="geohashJoinBtn">Join Channel</button>
                    </div>

                    <div class="geohash-controls">
                        <button class="geohash-control-btn" onclick="nym.resetGlobeView()">Reset View</button>
                    </div>

                    <div class="geohash-legend">
                        <div class="geohash-legend-item">
                            <div class="geohash-legend-dot"
                                style="background: var(--primary); box-shadow: 0 0 5px var(--primary);"></div>
                            <span>Active Channels</span>
                        </div>
                        <div class="geohash-legend-item">
                            <div class="geohash-legend-dot" style="background: var(--warning);"></div>
                            <span>Your Location</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Guided Tutorial Overlay -->
    <div id="tutorialOverlay" class="tutorial-overlay" aria-hidden="true">
        <div id="tutorialHighlight" class="tutorial-highlight" style="display:none;"></div>
        <div id="tutorialCard" class="tutorial-card" role="dialog" aria-modal="true" aria-labelledby="tutorialTitle">
            <div class="tutorial-header">
                <div class="tutorial-title" id="tutorialTitle">NYM Tutorial</div>
                <button id="tutorialSkipBtn" class="tutorial-skip" type="button">Skip</button>
            </div>
            <div class="tutorial-body" id="tutorialBody">
                Let’s take a quick 60‑second tour so you know where everything lives.
            </div>
            <div class="tutorial-progress" id="tutorialProgress">Step 1 of 1</div>
            <div class="tutorial-actions">
                <button id="tutorialPrevBtn" class="tutorial-btn" type="button">Back</button>
                <button id="tutorialNextBtn" class="tutorial-btn" type="button">Next</button>
            </div>
        </div>
    </div>

    <!-- Import nostr-tools -->
    <script>
        "use strict";
        var NostrTools = (() => {
            var __defProp = Object.defineProperty;
            var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
            var __getOwnPropNames = Object.getOwnPropertyNames;
            var __hasOwnProp = Object.prototype.hasOwnProperty;
            var __export = (target, all) => {
                for (var name in all)
                    __defProp(target, name, { get: all[name], enumerable: true });
            };
            var __copyProps = (to, from, except, desc) => {
                if (from && typeof from === "object" || typeof from === "function") {
                    for (let key of __getOwnPropNames(from))
                        if (!__hasOwnProp.call(to, key) && key !== except)
                            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
                }
                return to;
            };
            var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

            // index.ts
            var nostr_tools_exports = {};
            __export(nostr_tools_exports, {
                Relay: () => Relay,
                SimplePool: () => SimplePool,
                finalizeEvent: () => finalizeEvent,
                fj: () => fakejson_exports,
                generateSecretKey: () => generateSecretKey,
                getEventHash: () => getEventHash,
                getFilterLimit: () => getFilterLimit,
                getPublicKey: () => getPublicKey,
                kinds: () => kinds_exports,
                matchFilter: () => matchFilter,
                matchFilters: () => matchFilters,
                mergeFilters: () => mergeFilters,
                nip04: () => nip04_exports,
                nip05: () => nip05_exports,
                nip10: () => nip10_exports,
                nip11: () => nip11_exports,
                nip13: () => nip13_exports,
                nip18: () => nip18_exports,
                nip19: () => nip19_exports,
                nip21: () => nip21_exports,
                nip25: () => nip25_exports,
                nip27: () => nip27_exports,
                nip28: () => nip28_exports,
                nip30: () => nip30_exports,
                nip39: () => nip39_exports,
                nip42: () => nip42_exports,
                nip44: () => nip44_exports,
                nip47: () => nip47_exports,
                nip57: () => nip57_exports,
                nip98: () => nip98_exports,
                parseReferences: () => parseReferences,
                serializeEvent: () => serializeEvent,
                sortEvents: () => sortEvents,
                utils: () => utils_exports2,
                validateEvent: () => validateEvent,
                verifiedSymbol: () => verifiedSymbol,
                verifyEvent: () => verifyEvent
            });

            // node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js
            function number(n) {
                if (!Number.isSafeInteger(n) || n < 0)
                    throw new Error(`Wrong positive integer: ${n}`);
            }
            function bytes(b, ...lengths) {
                if (!(b instanceof Uint8Array))
                    throw new Error("Expected Uint8Array");
                if (lengths.length > 0 && !lengths.includes(b.length))
                    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
            }
            function hash(hash3) {
                if (typeof hash3 !== "function" || typeof hash3.create !== "function")
                    throw new Error("Hash should be wrapped by utils.wrapConstructor");
                number(hash3.outputLen);
                number(hash3.blockLen);
            }
            function exists(instance, checkFinished = true) {
                if (instance.destroyed)
                    throw new Error("Hash instance has been destroyed");
                if (checkFinished && instance.finished)
                    throw new Error("Hash#digest() has already been called");
            }
            function output(out, instance) {
                bytes(out);
                const min = instance.outputLen;
                if (out.length < min) {
                    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
                }
            }

            // node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js
            var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

            // node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js
            var u8a = (a) => a instanceof Uint8Array;
            var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
            var rotr = (word, shift) => word << 32 - shift | word >>> shift;
            var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
            if (!isLE)
                throw new Error("Non little-endian hardware is not supported");
            function utf8ToBytes(str) {
                if (typeof str !== "string")
                    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
                return new Uint8Array(new TextEncoder().encode(str));
            }
            function toBytes(data) {
                if (typeof data === "string")
                    data = utf8ToBytes(data);
                if (!u8a(data))
                    throw new Error(`expected Uint8Array, got ${typeof data}`);
                return data;
            }
            function concatBytes(...arrays) {
                const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
                let pad2 = 0;
                arrays.forEach((a) => {
                    if (!u8a(a))
                        throw new Error("Uint8Array expected");
                    r.set(a, pad2);
                    pad2 += a.length;
                });
                return r;
            }
            var Hash = class {
                clone() {
                    return this._cloneInto();
                }
            };
            var toStr = {}.toString;
            function wrapConstructor(hashCons) {
                const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
                const tmp = hashCons();
                hashC.outputLen = tmp.outputLen;
                hashC.blockLen = tmp.blockLen;
                hashC.create = () => hashCons();
                return hashC;
            }
            function randomBytes(bytesLength = 32) {
                if (crypto && typeof crypto.getRandomValues === "function") {
                    return crypto.getRandomValues(new Uint8Array(bytesLength));
                }
                throw new Error("crypto.getRandomValues must be defined");
            }

            // node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js
            function setBigUint64(view, byteOffset, value, isLE4) {
                if (typeof view.setBigUint64 === "function")
                    return view.setBigUint64(byteOffset, value, isLE4);
                const _32n = BigInt(32);
                const _u32_max = BigInt(4294967295);
                const wh = Number(value >> _32n & _u32_max);
                const wl = Number(value & _u32_max);
                const h = isLE4 ? 4 : 0;
                const l = isLE4 ? 0 : 4;
                view.setUint32(byteOffset + h, wh, isLE4);
                view.setUint32(byteOffset + l, wl, isLE4);
            }
            var SHA2 = class extends Hash {
                constructor(blockLen, outputLen, padOffset, isLE4) {
                    super();
                    this.blockLen = blockLen;
                    this.outputLen = outputLen;
                    this.padOffset = padOffset;
                    this.isLE = isLE4;
                    this.finished = false;
                    this.length = 0;
                    this.pos = 0;
                    this.destroyed = false;
                    this.buffer = new Uint8Array(blockLen);
                    this.view = createView(this.buffer);
                }
                update(data) {
                    exists(this);
                    const { view, buffer, blockLen } = this;
                    data = toBytes(data);
                    const len = data.length;
                    for (let pos = 0; pos < len;) {
                        const take = Math.min(blockLen - this.pos, len - pos);
                        if (take === blockLen) {
                            const dataView = createView(data);
                            for (; blockLen <= len - pos; pos += blockLen)
                                this.process(dataView, pos);
                            continue;
                        }
                        buffer.set(data.subarray(pos, pos + take), this.pos);
                        this.pos += take;
                        pos += take;
                        if (this.pos === blockLen) {
                            this.process(view, 0);
                            this.pos = 0;
                        }
                    }
                    this.length += data.length;
                    this.roundClean();
                    return this;
                }
                digestInto(out) {
                    exists(this);
                    output(out, this);
                    this.finished = true;
                    const { buffer, view, blockLen, isLE: isLE4 } = this;
                    let { pos } = this;
                    buffer[pos++] = 128;
                    this.buffer.subarray(pos).fill(0);
                    if (this.padOffset > blockLen - pos) {
                        this.process(view, 0);
                        pos = 0;
                    }
                    for (let i2 = pos; i2 < blockLen; i2++)
                        buffer[i2] = 0;
                    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE4);
                    this.process(view, 0);
                    const oview = createView(out);
                    const len = this.outputLen;
                    if (len % 4)
                        throw new Error("_sha2: outputLen should be aligned to 32bit");
                    const outLen = len / 4;
                    const state = this.get();
                    if (outLen > state.length)
                        throw new Error("_sha2: outputLen bigger than state");
                    for (let i2 = 0; i2 < outLen; i2++)
                        oview.setUint32(4 * i2, state[i2], isLE4);
                }
                digest() {
                    const { buffer, outputLen } = this;
                    this.digestInto(buffer);
                    const res = buffer.slice(0, outputLen);
                    this.destroy();
                    return res;
                }
                _cloneInto(to) {
                    to || (to = new this.constructor());
                    to.set(...this.get());
                    const { blockLen, buffer, length, finished, destroyed, pos } = this;
                    to.length = length;
                    to.pos = pos;
                    to.finished = finished;
                    to.destroyed = destroyed;
                    if (length % blockLen)
                        to.buffer.set(buffer);
                    return to;
                }
            };

            // node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js
            var Chi = (a, b, c) => a & b ^ ~a & c;
            var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
            var SHA256_K = /* @__PURE__ */ new Uint32Array([
                1116352408,
                1899447441,
                3049323471,
                3921009573,
                961987163,
                1508970993,
                2453635748,
                2870763221,
                3624381080,
                310598401,
                607225278,
                1426881987,
                1925078388,
                2162078206,
                2614888103,
                3248222580,
                3835390401,
                4022224774,
                264347078,
                604807628,
                770255983,
                1249150122,
                1555081692,
                1996064986,
                2554220882,
                2821834349,
                2952996808,
                3210313671,
                3336571891,
                3584528711,
                113926993,
                338241895,
                666307205,
                773529912,
                1294757372,
                1396182291,
                1695183700,
                1986661051,
                2177026350,
                2456956037,
                2730485921,
                2820302411,
                3259730800,
                3345764771,
                3516065817,
                3600352804,
                4094571909,
                275423344,
                430227734,
                506948616,
                659060556,
                883997877,
                958139571,
                1322822218,
                1537002063,
                1747873779,
                1955562222,
                2024104815,
                2227730452,
                2361852424,
                2428436474,
                2756734187,
                3204031479,
                3329325298
            ]);
            var IV = /* @__PURE__ */ new Uint32Array([
                1779033703,
                3144134277,
                1013904242,
                2773480762,
                1359893119,
                2600822924,
                528734635,
                1541459225
            ]);
            var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
            var SHA256 = class extends SHA2 {
                constructor() {
                    super(64, 32, 8, false);
                    this.A = IV[0] | 0;
                    this.B = IV[1] | 0;
                    this.C = IV[2] | 0;
                    this.D = IV[3] | 0;
                    this.E = IV[4] | 0;
                    this.F = IV[5] | 0;
                    this.G = IV[6] | 0;
                    this.H = IV[7] | 0;
                }
                get() {
                    const { A, B, C, D, E, F, G, H } = this;
                    return [A, B, C, D, E, F, G, H];
                }
                set(A, B, C, D, E, F, G, H) {
                    this.A = A | 0;
                    this.B = B | 0;
                    this.C = C | 0;
                    this.D = D | 0;
                    this.E = E | 0;
                    this.F = F | 0;
                    this.G = G | 0;
                    this.H = H | 0;
                }
                process(view, offset) {
                    for (let i2 = 0; i2 < 16; i2++, offset += 4)
                        SHA256_W[i2] = view.getUint32(offset, false);
                    for (let i2 = 16; i2 < 64; i2++) {
                        const W15 = SHA256_W[i2 - 15];
                        const W2 = SHA256_W[i2 - 2];
                        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
                        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
                        SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
                    }
                    let { A, B, C, D, E, F, G, H } = this;
                    for (let i2 = 0; i2 < 64; i2++) {
                        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
                        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
                        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
                        const T2 = sigma0 + Maj(A, B, C) | 0;
                        H = G;
                        G = F;
                        F = E;
                        E = D + T1 | 0;
                        D = C;
                        C = B;
                        B = A;
                        A = T1 + T2 | 0;
                    }
                    A = A + this.A | 0;
                    B = B + this.B | 0;
                    C = C + this.C | 0;
                    D = D + this.D | 0;
                    E = E + this.E | 0;
                    F = F + this.F | 0;
                    G = G + this.G | 0;
                    H = H + this.H | 0;
                    this.set(A, B, C, D, E, F, G, H);
                }
                roundClean() {
                    SHA256_W.fill(0);
                }
                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0);
                    this.buffer.fill(0);
                }
            };
            var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

            // node_modules/@noble/curves/esm/abstract/utils.js
            var utils_exports = {};
            __export(utils_exports, {
                bitGet: () => bitGet,
                bitLen: () => bitLen,
                bitMask: () => bitMask,
                bitSet: () => bitSet,
                bytesToHex: () => bytesToHex,
                bytesToNumberBE: () => bytesToNumberBE,
                bytesToNumberLE: () => bytesToNumberLE,
                concatBytes: () => concatBytes2,
                createHmacDrbg: () => createHmacDrbg,
                ensureBytes: () => ensureBytes,
                equalBytes: () => equalBytes,
                hexToBytes: () => hexToBytes,
                hexToNumber: () => hexToNumber,
                numberToBytesBE: () => numberToBytesBE,
                numberToBytesLE: () => numberToBytesLE,
                numberToHexUnpadded: () => numberToHexUnpadded,
                numberToVarBytesBE: () => numberToVarBytesBE,
                utf8ToBytes: () => utf8ToBytes2,
                validateObject: () => validateObject
            });
            var _0n = BigInt(0);
            var _1n = BigInt(1);
            var _2n = BigInt(2);
            var u8a2 = (a) => a instanceof Uint8Array;
            var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
            function bytesToHex(bytes4) {
                if (!u8a2(bytes4))
                    throw new Error("Uint8Array expected");
                let hex2 = "";
                for (let i2 = 0; i2 < bytes4.length; i2++) {
                    hex2 += hexes[bytes4[i2]];
                }
                return hex2;
            }
            function numberToHexUnpadded(num) {
                const hex2 = num.toString(16);
                return hex2.length & 1 ? `0${hex2}` : hex2;
            }
            function hexToNumber(hex2) {
                if (typeof hex2 !== "string")
                    throw new Error("hex string expected, got " + typeof hex2);
                return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
            }
            function hexToBytes(hex2) {
                if (typeof hex2 !== "string")
                    throw new Error("hex string expected, got " + typeof hex2);
                const len = hex2.length;
                if (len % 2)
                    throw new Error("padded hex string expected, got unpadded hex of length " + len);
                const array = new Uint8Array(len / 2);
                for (let i2 = 0; i2 < array.length; i2++) {
                    const j = i2 * 2;
                    const hexByte = hex2.slice(j, j + 2);
                    const byte = Number.parseInt(hexByte, 16);
                    if (Number.isNaN(byte) || byte < 0)
                        throw new Error("Invalid byte sequence");
                    array[i2] = byte;
                }
                return array;
            }
            function bytesToNumberBE(bytes4) {
                return hexToNumber(bytesToHex(bytes4));
            }
            function bytesToNumberLE(bytes4) {
                if (!u8a2(bytes4))
                    throw new Error("Uint8Array expected");
                return hexToNumber(bytesToHex(Uint8Array.from(bytes4).reverse()));
            }
            function numberToBytesBE(n, len) {
                return hexToBytes(n.toString(16).padStart(len * 2, "0"));
            }
            function numberToBytesLE(n, len) {
                return numberToBytesBE(n, len).reverse();
            }
            function numberToVarBytesBE(n) {
                return hexToBytes(numberToHexUnpadded(n));
            }
            function ensureBytes(title, hex2, expectedLength) {
                let res;
                if (typeof hex2 === "string") {
                    try {
                        res = hexToBytes(hex2);
                    } catch (e) {
                        throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e}`);
                    }
                } else if (u8a2(hex2)) {
                    res = Uint8Array.from(hex2);
                } else {
                    throw new Error(`${title} must be hex string or Uint8Array`);
                }
                const len = res.length;
                if (typeof expectedLength === "number" && len !== expectedLength)
                    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
                return res;
            }
            function concatBytes2(...arrays) {
                const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
                let pad2 = 0;
                arrays.forEach((a) => {
                    if (!u8a2(a))
                        throw new Error("Uint8Array expected");
                    r.set(a, pad2);
                    pad2 += a.length;
                });
                return r;
            }
            function equalBytes(b1, b2) {
                if (b1.length !== b2.length)
                    return false;
                for (let i2 = 0; i2 < b1.length; i2++)
                    if (b1[i2] !== b2[i2])
                        return false;
                return true;
            }
            function utf8ToBytes2(str) {
                if (typeof str !== "string")
                    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
                return new Uint8Array(new TextEncoder().encode(str));
            }
            function bitLen(n) {
                let len;
                for (len = 0; n > _0n; n >>= _1n, len += 1)
                    ;
                return len;
            }
            function bitGet(n, pos) {
                return n >> BigInt(pos) & _1n;
            }
            var bitSet = (n, pos, value) => {
                return n | (value ? _1n : _0n) << BigInt(pos);
            };
            var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
            var u8n = (data) => new Uint8Array(data);
            var u8fr = (arr) => Uint8Array.from(arr);
            function createHmacDrbg(hashLen, qByteLen, hmacFn) {
                if (typeof hashLen !== "number" || hashLen < 2)
                    throw new Error("hashLen must be a number");
                if (typeof qByteLen !== "number" || qByteLen < 2)
                    throw new Error("qByteLen must be a number");
                if (typeof hmacFn !== "function")
                    throw new Error("hmacFn must be a function");
                let v = u8n(hashLen);
                let k = u8n(hashLen);
                let i2 = 0;
                const reset = () => {
                    v.fill(1);
                    k.fill(0);
                    i2 = 0;
                };
                const h = (...b) => hmacFn(k, v, ...b);
                const reseed = (seed = u8n()) => {
                    k = h(u8fr([0]), seed);
                    v = h();
                    if (seed.length === 0)
                        return;
                    k = h(u8fr([1]), seed);
                    v = h();
                };
                const gen = () => {
                    if (i2++ >= 1e3)
                        throw new Error("drbg: tried 1000 values");
                    let len = 0;
                    const out = [];
                    while (len < qByteLen) {
                        v = h();
                        const sl = v.slice();
                        out.push(sl);
                        len += v.length;
                    }
                    return concatBytes2(...out);
                };
                const genUntil = (seed, pred) => {
                    reset();
                    reseed(seed);
                    let res = void 0;
                    while (!(res = pred(gen())))
                        reseed();
                    reset();
                    return res;
                };
                return genUntil;
            }
            var validatorFns = {
                bigint: (val) => typeof val === "bigint",
                function: (val) => typeof val === "function",
                boolean: (val) => typeof val === "boolean",
                string: (val) => typeof val === "string",
                stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
                isSafeInteger: (val) => Number.isSafeInteger(val),
                array: (val) => Array.isArray(val),
                field: (val, object) => object.Fp.isValid(val),
                hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
            };
            function validateObject(object, validators, optValidators = {}) {
                const checkField = (fieldName, type, isOptional) => {
                    const checkVal = validatorFns[type];
                    if (typeof checkVal !== "function")
                        throw new Error(`Invalid validator "${type}", expected function`);
                    const val = object[fieldName];
                    if (isOptional && val === void 0)
                        return;
                    if (!checkVal(val, object)) {
                        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
                    }
                };
                for (const [fieldName, type] of Object.entries(validators))
                    checkField(fieldName, type, false);
                for (const [fieldName, type] of Object.entries(optValidators))
                    checkField(fieldName, type, true);
                return object;
            }

            // node_modules/@noble/curves/esm/abstract/modular.js
            var _0n2 = BigInt(0);
            var _1n2 = BigInt(1);
            var _2n2 = BigInt(2);
            var _3n = BigInt(3);
            var _4n = BigInt(4);
            var _5n = BigInt(5);
            var _8n = BigInt(8);
            var _9n = BigInt(9);
            var _16n = BigInt(16);
            function mod(a, b) {
                const result = a % b;
                return result >= _0n2 ? result : b + result;
            }
            function pow(num, power, modulo) {
                if (modulo <= _0n2 || power < _0n2)
                    throw new Error("Expected power/modulo > 0");
                if (modulo === _1n2)
                    return _0n2;
                let res = _1n2;
                while (power > _0n2) {
                    if (power & _1n2)
                        res = res * num % modulo;
                    num = num * num % modulo;
                    power >>= _1n2;
                }
                return res;
            }
            function pow2(x, power, modulo) {
                let res = x;
                while (power-- > _0n2) {
                    res *= res;
                    res %= modulo;
                }
                return res;
            }
            function invert(number4, modulo) {
                if (number4 === _0n2 || modulo <= _0n2) {
                    throw new Error(`invert: expected positive integers, got n=${number4} mod=${modulo}`);
                }
                let a = mod(number4, modulo);
                let b = modulo;
                let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
                while (a !== _0n2) {
                    const q = b / a;
                    const r = b % a;
                    const m = x - u * q;
                    const n = y - v * q;
                    b = a, a = r, x = u, y = v, u = m, v = n;
                }
                const gcd2 = b;
                if (gcd2 !== _1n2)
                    throw new Error("invert: does not exist");
                return mod(x, modulo);
            }
            function tonelliShanks(P) {
                const legendreC = (P - _1n2) / _2n2;
                let Q, S, Z;
                for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
                    ;
                for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
                    ;
                if (S === 1) {
                    const p1div4 = (P + _1n2) / _4n;
                    return function tonelliFast(Fp2, n) {
                        const root = Fp2.pow(n, p1div4);
                        if (!Fp2.eql(Fp2.sqr(root), n))
                            throw new Error("Cannot find square root");
                        return root;
                    };
                }
                const Q1div2 = (Q + _1n2) / _2n2;
                return function tonelliSlow(Fp2, n) {
                    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
                        throw new Error("Cannot find square root");
                    let r = S;
                    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
                    let x = Fp2.pow(n, Q1div2);
                    let b = Fp2.pow(n, Q);
                    while (!Fp2.eql(b, Fp2.ONE)) {
                        if (Fp2.eql(b, Fp2.ZERO))
                            return Fp2.ZERO;
                        let m = 1;
                        for (let t2 = Fp2.sqr(b); m < r; m++) {
                            if (Fp2.eql(t2, Fp2.ONE))
                                break;
                            t2 = Fp2.sqr(t2);
                        }
                        const ge2 = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
                        g = Fp2.sqr(ge2);
                        x = Fp2.mul(x, ge2);
                        b = Fp2.mul(b, g);
                        r = m;
                    }
                    return x;
                };
            }
            function FpSqrt(P) {
                if (P % _4n === _3n) {
                    const p1div4 = (P + _1n2) / _4n;
                    return function sqrt3mod4(Fp2, n) {
                        const root = Fp2.pow(n, p1div4);
                        if (!Fp2.eql(Fp2.sqr(root), n))
                            throw new Error("Cannot find square root");
                        return root;
                    };
                }
                if (P % _8n === _5n) {
                    const c1 = (P - _5n) / _8n;
                    return function sqrt5mod8(Fp2, n) {
                        const n2 = Fp2.mul(n, _2n2);
                        const v = Fp2.pow(n2, c1);
                        const nv = Fp2.mul(n, v);
                        const i2 = Fp2.mul(Fp2.mul(nv, _2n2), v);
                        const root = Fp2.mul(nv, Fp2.sub(i2, Fp2.ONE));
                        if (!Fp2.eql(Fp2.sqr(root), n))
                            throw new Error("Cannot find square root");
                        return root;
                    };
                }
                if (P % _16n === _9n) {
                }
                return tonelliShanks(P);
            }
            var FIELD_FIELDS = [
                "create",
                "isValid",
                "is0",
                "neg",
                "inv",
                "sqrt",
                "sqr",
                "eql",
                "add",
                "sub",
                "mul",
                "pow",
                "div",
                "addN",
                "subN",
                "mulN",
                "sqrN"
            ];
            function validateField(field) {
                const initial = {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger"
                };
                const opts = FIELD_FIELDS.reduce((map, val) => {
                    map[val] = "function";
                    return map;
                }, initial);
                return validateObject(field, opts);
            }
            function FpPow(f, num, power) {
                if (power < _0n2)
                    throw new Error("Expected power > 0");
                if (power === _0n2)
                    return f.ONE;
                if (power === _1n2)
                    return num;
                let p = f.ONE;
                let d = num;
                while (power > _0n2) {
                    if (power & _1n2)
                        p = f.mul(p, d);
                    d = f.sqr(d);
                    power >>= _1n2;
                }
                return p;
            }
            function FpInvertBatch(f, nums) {
                const tmp = new Array(nums.length);
                const lastMultiplied = nums.reduce((acc, num, i2) => {
                    if (f.is0(num))
                        return acc;
                    tmp[i2] = acc;
                    return f.mul(acc, num);
                }, f.ONE);
                const inverted = f.inv(lastMultiplied);
                nums.reduceRight((acc, num, i2) => {
                    if (f.is0(num))
                        return acc;
                    tmp[i2] = f.mul(acc, tmp[i2]);
                    return f.mul(acc, num);
                }, inverted);
                return tmp;
            }
            function nLength(n, nBitLength) {
                const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
                const nByteLength = Math.ceil(_nBitLength / 8);
                return { nBitLength: _nBitLength, nByteLength };
            }
            function Field(ORDER, bitLen2, isLE4 = false, redef = {}) {
                if (ORDER <= _0n2)
                    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
                const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
                if (BYTES > 2048)
                    throw new Error("Field lengths over 2048 bytes are not supported");
                const sqrtP = FpSqrt(ORDER);
                const f = Object.freeze({
                    ORDER,
                    BITS,
                    BYTES,
                    MASK: bitMask(BITS),
                    ZERO: _0n2,
                    ONE: _1n2,
                    create: (num) => mod(num, ORDER),
                    isValid: (num) => {
                        if (typeof num !== "bigint")
                            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
                        return _0n2 <= num && num < ORDER;
                    },
                    is0: (num) => num === _0n2,
                    isOdd: (num) => (num & _1n2) === _1n2,
                    neg: (num) => mod(-num, ORDER),
                    eql: (lhs, rhs) => lhs === rhs,
                    sqr: (num) => mod(num * num, ORDER),
                    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
                    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
                    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
                    pow: (num, power) => FpPow(f, num, power),
                    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
                    sqrN: (num) => num * num,
                    addN: (lhs, rhs) => lhs + rhs,
                    subN: (lhs, rhs) => lhs - rhs,
                    mulN: (lhs, rhs) => lhs * rhs,
                    inv: (num) => invert(num, ORDER),
                    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
                    invertBatch: (lst) => FpInvertBatch(f, lst),
                    cmov: (a, b, c) => c ? b : a,
                    toBytes: (num) => isLE4 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
                    fromBytes: (bytes4) => {
                        if (bytes4.length !== BYTES)
                            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes4.length}`);
                        return isLE4 ? bytesToNumberLE(bytes4) : bytesToNumberBE(bytes4);
                    }
                });
                return Object.freeze(f);
            }
            function getFieldBytesLength(fieldOrder) {
                if (typeof fieldOrder !== "bigint")
                    throw new Error("field order must be bigint");
                const bitLength = fieldOrder.toString(2).length;
                return Math.ceil(bitLength / 8);
            }
            function getMinHashLength(fieldOrder) {
                const length = getFieldBytesLength(fieldOrder);
                return length + Math.ceil(length / 2);
            }
            function mapHashToField(key, fieldOrder, isLE4 = false) {
                const len = key.length;
                const fieldLen = getFieldBytesLength(fieldOrder);
                const minLen = getMinHashLength(fieldOrder);
                if (len < 16 || len < minLen || len > 1024)
                    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
                const num = isLE4 ? bytesToNumberBE(key) : bytesToNumberLE(key);
                const reduced = mod(num, fieldOrder - _1n2) + _1n2;
                return isLE4 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
            }

            // node_modules/@noble/curves/esm/abstract/curve.js
            var _0n3 = BigInt(0);
            var _1n3 = BigInt(1);
            function wNAF(c, bits) {
                const constTimeNegate = (condition, item) => {
                    const neg = item.negate();
                    return condition ? neg : item;
                };
                const opts = (W) => {
                    const windows = Math.ceil(bits / W) + 1;
                    const windowSize = 2 ** (W - 1);
                    return { windows, windowSize };
                };
                return {
                    constTimeNegate,
                    unsafeLadder(elm, n) {
                        let p = c.ZERO;
                        let d = elm;
                        while (n > _0n3) {
                            if (n & _1n3)
                                p = p.add(d);
                            d = d.double();
                            n >>= _1n3;
                        }
                        return p;
                    },
                    precomputeWindow(elm, W) {
                        const { windows, windowSize } = opts(W);
                        const points = [];
                        let p = elm;
                        let base = p;
                        for (let window = 0; window < windows; window++) {
                            base = p;
                            points.push(base);
                            for (let i2 = 1; i2 < windowSize; i2++) {
                                base = base.add(p);
                                points.push(base);
                            }
                            p = base.double();
                        }
                        return points;
                    },
                    wNAF(W, precomputes, n) {
                        const { windows, windowSize } = opts(W);
                        let p = c.ZERO;
                        let f = c.BASE;
                        const mask = BigInt(2 ** W - 1);
                        const maxNumber = 2 ** W;
                        const shiftBy = BigInt(W);
                        for (let window = 0; window < windows; window++) {
                            const offset = window * windowSize;
                            let wbits = Number(n & mask);
                            n >>= shiftBy;
                            if (wbits > windowSize) {
                                wbits -= maxNumber;
                                n += _1n3;
                            }
                            const offset1 = offset;
                            const offset2 = offset + Math.abs(wbits) - 1;
                            const cond1 = window % 2 !== 0;
                            const cond2 = wbits < 0;
                            if (wbits === 0) {
                                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                            } else {
                                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                            }
                        }
                        return { p, f };
                    },
                    wNAFCached(P, precomputesMap, n, transform) {
                        const W = P._WINDOW_SIZE || 1;
                        let comp = precomputesMap.get(P);
                        if (!comp) {
                            comp = this.precomputeWindow(P, W);
                            if (W !== 1) {
                                precomputesMap.set(P, transform(comp));
                            }
                        }
                        return this.wNAF(W, comp, n);
                    }
                };
            }
            function validateBasic(curve) {
                validateField(curve.Fp);
                validateObject(curve, {
                    n: "bigint",
                    h: "bigint",
                    Gx: "field",
                    Gy: "field"
                }, {
                    nBitLength: "isSafeInteger",
                    nByteLength: "isSafeInteger"
                });
                return Object.freeze({
                    ...nLength(curve.n, curve.nBitLength),
                    ...curve,
                    ...{ p: curve.Fp.ORDER }
                });
            }

            // node_modules/@noble/curves/esm/abstract/weierstrass.js
            function validatePointOpts(curve) {
                const opts = validateBasic(curve);
                validateObject(opts, {
                    a: "field",
                    b: "field"
                }, {
                    allowedPrivateKeyLengths: "array",
                    wrapPrivateKey: "boolean",
                    isTorsionFree: "function",
                    clearCofactor: "function",
                    allowInfinityPoint: "boolean",
                    fromBytes: "function",
                    toBytes: "function"
                });
                const { endo, Fp: Fp2, a } = opts;
                if (endo) {
                    if (!Fp2.eql(a, Fp2.ZERO)) {
                        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                    }
                    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
                        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
                    }
                }
                return Object.freeze({ ...opts });
            }
            var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
            var DER = {
                Err: class DERErr extends Error {
                    constructor(m = "") {
                        super(m);
                    }
                },
                _parseInt(data) {
                    const { Err: E } = DER;
                    if (data.length < 2 || data[0] !== 2)
                        throw new E("Invalid signature integer tag");
                    const len = data[1];
                    const res = data.subarray(2, len + 2);
                    if (!len || res.length !== len)
                        throw new E("Invalid signature integer: wrong length");
                    if (res[0] & 128)
                        throw new E("Invalid signature integer: negative");
                    if (res[0] === 0 && !(res[1] & 128))
                        throw new E("Invalid signature integer: unnecessary leading zero");
                    return { d: b2n(res), l: data.subarray(len + 2) };
                },
                toSig(hex2) {
                    const { Err: E } = DER;
                    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
                    if (!(data instanceof Uint8Array))
                        throw new Error("ui8a expected");
                    let l = data.length;
                    if (l < 2 || data[0] != 48)
                        throw new E("Invalid signature tag");
                    if (data[1] !== l - 2)
                        throw new E("Invalid signature: incorrect length");
                    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
                    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
                    if (rBytesLeft.length)
                        throw new E("Invalid signature: left bytes after parsing");
                    return { r, s };
                },
                hexFromSig(sig) {
                    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
                    const h = (num) => {
                        const hex2 = num.toString(16);
                        return hex2.length & 1 ? `0${hex2}` : hex2;
                    };
                    const s = slice(h(sig.s));
                    const r = slice(h(sig.r));
                    const shl = s.length / 2;
                    const rhl = r.length / 2;
                    const sl = h(shl);
                    const rl = h(rhl);
                    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
                }
            };
            var _0n4 = BigInt(0);
            var _1n4 = BigInt(1);
            var _2n3 = BigInt(2);
            var _3n2 = BigInt(3);
            var _4n2 = BigInt(4);
            function weierstrassPoints(opts) {
                const CURVE = validatePointOpts(opts);
                const { Fp: Fp2 } = CURVE;
                const toBytes4 = CURVE.toBytes || ((_c, point, _isCompressed) => {
                    const a = point.toAffine();
                    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
                });
                const fromBytes = CURVE.fromBytes || ((bytes4) => {
                    const tail = bytes4.subarray(1);
                    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
                    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
                    return { x, y };
                });
                function weierstrassEquation(x) {
                    const { a, b } = CURVE;
                    const x2 = Fp2.sqr(x);
                    const x3 = Fp2.mul(x2, x);
                    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
                }
                if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
                    throw new Error("bad generator point: equation left != right");
                function isWithinCurveOrder(num) {
                    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
                }
                function assertGE(num) {
                    if (!isWithinCurveOrder(num))
                        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
                }
                function normPrivateKeyToScalar(key) {
                    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
                    if (lengths && typeof key !== "bigint") {
                        if (key instanceof Uint8Array)
                            key = bytesToHex(key);
                        if (typeof key !== "string" || !lengths.includes(key.length))
                            throw new Error("Invalid key");
                        key = key.padStart(nByteLength * 2, "0");
                    }
                    let num;
                    try {
                        num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
                    } catch (error) {
                        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
                    }
                    if (wrapPrivateKey)
                        num = mod(num, n);
                    assertGE(num);
                    return num;
                }
                const pointPrecomputes = /* @__PURE__ */ new Map();
                function assertPrjPoint(other) {
                    if (!(other instanceof Point2))
                        throw new Error("ProjectivePoint expected");
                }
                class Point2 {
                    constructor(px, py, pz) {
                        this.px = px;
                        this.py = py;
                        this.pz = pz;
                        if (px == null || !Fp2.isValid(px))
                            throw new Error("x required");
                        if (py == null || !Fp2.isValid(py))
                            throw new Error("y required");
                        if (pz == null || !Fp2.isValid(pz))
                            throw new Error("z required");
                    }
                    static fromAffine(p) {
                        const { x, y } = p || {};
                        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
                            throw new Error("invalid affine point");
                        if (p instanceof Point2)
                            throw new Error("projective point not allowed");
                        const is0 = (i2) => Fp2.eql(i2, Fp2.ZERO);
                        if (is0(x) && is0(y))
                            return Point2.ZERO;
                        return new Point2(x, y, Fp2.ONE);
                    }
                    get x() {
                        return this.toAffine().x;
                    }
                    get y() {
                        return this.toAffine().y;
                    }
                    static normalizeZ(points) {
                        const toInv = Fp2.invertBatch(points.map((p) => p.pz));
                        return points.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
                    }
                    static fromHex(hex2) {
                        const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
                        P.assertValidity();
                        return P;
                    }
                    static fromPrivateKey(privateKey) {
                        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
                    }
                    _setWindowSize(windowSize) {
                        this._WINDOW_SIZE = windowSize;
                        pointPrecomputes.delete(this);
                    }
                    assertValidity() {
                        if (this.is0()) {
                            if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
                                return;
                            throw new Error("bad point: ZERO");
                        }
                        const { x, y } = this.toAffine();
                        if (!Fp2.isValid(x) || !Fp2.isValid(y))
                            throw new Error("bad point: x or y not FE");
                        const left = Fp2.sqr(y);
                        const right = weierstrassEquation(x);
                        if (!Fp2.eql(left, right))
                            throw new Error("bad point: equation left != right");
                        if (!this.isTorsionFree())
                            throw new Error("bad point: not in prime-order subgroup");
                    }
                    hasEvenY() {
                        const { y } = this.toAffine();
                        if (Fp2.isOdd)
                            return !Fp2.isOdd(y);
                        throw new Error("Field doesn't support isOdd");
                    }
                    equals(other) {
                        assertPrjPoint(other);
                        const { px: X1, py: Y1, pz: Z1 } = this;
                        const { px: X2, py: Y2, pz: Z2 } = other;
                        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
                        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
                        return U1 && U2;
                    }
                    negate() {
                        return new Point2(this.px, Fp2.neg(this.py), this.pz);
                    }
                    double() {
                        const { a, b } = CURVE;
                        const b3 = Fp2.mul(b, _3n2);
                        const { px: X1, py: Y1, pz: Z1 } = this;
                        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
                        let t0 = Fp2.mul(X1, X1);
                        let t1 = Fp2.mul(Y1, Y1);
                        let t2 = Fp2.mul(Z1, Z1);
                        let t3 = Fp2.mul(X1, Y1);
                        t3 = Fp2.add(t3, t3);
                        Z3 = Fp2.mul(X1, Z1);
                        Z3 = Fp2.add(Z3, Z3);
                        X3 = Fp2.mul(a, Z3);
                        Y3 = Fp2.mul(b3, t2);
                        Y3 = Fp2.add(X3, Y3);
                        X3 = Fp2.sub(t1, Y3);
                        Y3 = Fp2.add(t1, Y3);
                        Y3 = Fp2.mul(X3, Y3);
                        X3 = Fp2.mul(t3, X3);
                        Z3 = Fp2.mul(b3, Z3);
                        t2 = Fp2.mul(a, t2);
                        t3 = Fp2.sub(t0, t2);
                        t3 = Fp2.mul(a, t3);
                        t3 = Fp2.add(t3, Z3);
                        Z3 = Fp2.add(t0, t0);
                        t0 = Fp2.add(Z3, t0);
                        t0 = Fp2.add(t0, t2);
                        t0 = Fp2.mul(t0, t3);
                        Y3 = Fp2.add(Y3, t0);
                        t2 = Fp2.mul(Y1, Z1);
                        t2 = Fp2.add(t2, t2);
                        t0 = Fp2.mul(t2, t3);
                        X3 = Fp2.sub(X3, t0);
                        Z3 = Fp2.mul(t2, t1);
                        Z3 = Fp2.add(Z3, Z3);
                        Z3 = Fp2.add(Z3, Z3);
                        return new Point2(X3, Y3, Z3);
                    }
                    add(other) {
                        assertPrjPoint(other);
                        const { px: X1, py: Y1, pz: Z1 } = this;
                        const { px: X2, py: Y2, pz: Z2 } = other;
                        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
                        const a = CURVE.a;
                        const b3 = Fp2.mul(CURVE.b, _3n2);
                        let t0 = Fp2.mul(X1, X2);
                        let t1 = Fp2.mul(Y1, Y2);
                        let t2 = Fp2.mul(Z1, Z2);
                        let t3 = Fp2.add(X1, Y1);
                        let t4 = Fp2.add(X2, Y2);
                        t3 = Fp2.mul(t3, t4);
                        t4 = Fp2.add(t0, t1);
                        t3 = Fp2.sub(t3, t4);
                        t4 = Fp2.add(X1, Z1);
                        let t5 = Fp2.add(X2, Z2);
                        t4 = Fp2.mul(t4, t5);
                        t5 = Fp2.add(t0, t2);
                        t4 = Fp2.sub(t4, t5);
                        t5 = Fp2.add(Y1, Z1);
                        X3 = Fp2.add(Y2, Z2);
                        t5 = Fp2.mul(t5, X3);
                        X3 = Fp2.add(t1, t2);
                        t5 = Fp2.sub(t5, X3);
                        Z3 = Fp2.mul(a, t4);
                        X3 = Fp2.mul(b3, t2);
                        Z3 = Fp2.add(X3, Z3);
                        X3 = Fp2.sub(t1, Z3);
                        Z3 = Fp2.add(t1, Z3);
                        Y3 = Fp2.mul(X3, Z3);
                        t1 = Fp2.add(t0, t0);
                        t1 = Fp2.add(t1, t0);
                        t2 = Fp2.mul(a, t2);
                        t4 = Fp2.mul(b3, t4);
                        t1 = Fp2.add(t1, t2);
                        t2 = Fp2.sub(t0, t2);
                        t2 = Fp2.mul(a, t2);
                        t4 = Fp2.add(t4, t2);
                        t0 = Fp2.mul(t1, t4);
                        Y3 = Fp2.add(Y3, t0);
                        t0 = Fp2.mul(t5, t4);
                        X3 = Fp2.mul(t3, X3);
                        X3 = Fp2.sub(X3, t0);
                        t0 = Fp2.mul(t3, t1);
                        Z3 = Fp2.mul(t5, Z3);
                        Z3 = Fp2.add(Z3, t0);
                        return new Point2(X3, Y3, Z3);
                    }
                    subtract(other) {
                        return this.add(other.negate());
                    }
                    is0() {
                        return this.equals(Point2.ZERO);
                    }
                    wNAF(n) {
                        return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
                            const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
                            return comp.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
                        });
                    }
                    multiplyUnsafe(n) {
                        const I = Point2.ZERO;
                        if (n === _0n4)
                            return I;
                        assertGE(n);
                        if (n === _1n4)
                            return this;
                        const { endo } = CURVE;
                        if (!endo)
                            return wnaf.unsafeLadder(this, n);
                        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                        let k1p = I;
                        let k2p = I;
                        let d = this;
                        while (k1 > _0n4 || k2 > _0n4) {
                            if (k1 & _1n4)
                                k1p = k1p.add(d);
                            if (k2 & _1n4)
                                k2p = k2p.add(d);
                            d = d.double();
                            k1 >>= _1n4;
                            k2 >>= _1n4;
                        }
                        if (k1neg)
                            k1p = k1p.negate();
                        if (k2neg)
                            k2p = k2p.negate();
                        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                        return k1p.add(k2p);
                    }
                    multiply(scalar) {
                        assertGE(scalar);
                        let n = scalar;
                        let point, fake;
                        const { endo } = CURVE;
                        if (endo) {
                            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                            let { p: k1p, f: f1p } = this.wNAF(k1);
                            let { p: k2p, f: f2p } = this.wNAF(k2);
                            k1p = wnaf.constTimeNegate(k1neg, k1p);
                            k2p = wnaf.constTimeNegate(k2neg, k2p);
                            k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                            point = k1p.add(k2p);
                            fake = f1p.add(f2p);
                        } else {
                            const { p, f } = this.wNAF(n);
                            point = p;
                            fake = f;
                        }
                        return Point2.normalizeZ([point, fake])[0];
                    }
                    multiplyAndAddUnsafe(Q, a, b) {
                        const G = Point2.BASE;
                        const mul3 = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
                        const sum = mul3(this, a).add(mul3(Q, b));
                        return sum.is0() ? void 0 : sum;
                    }
                    toAffine(iz) {
                        const { px: x, py: y, pz: z } = this;
                        const is0 = this.is0();
                        if (iz == null)
                            iz = is0 ? Fp2.ONE : Fp2.inv(z);
                        const ax = Fp2.mul(x, iz);
                        const ay = Fp2.mul(y, iz);
                        const zz = Fp2.mul(z, iz);
                        if (is0)
                            return { x: Fp2.ZERO, y: Fp2.ZERO };
                        if (!Fp2.eql(zz, Fp2.ONE))
                            throw new Error("invZ was invalid");
                        return { x: ax, y: ay };
                    }
                    isTorsionFree() {
                        const { h: cofactor, isTorsionFree } = CURVE;
                        if (cofactor === _1n4)
                            return true;
                        if (isTorsionFree)
                            return isTorsionFree(Point2, this);
                        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
                    }
                    clearCofactor() {
                        const { h: cofactor, clearCofactor } = CURVE;
                        if (cofactor === _1n4)
                            return this;
                        if (clearCofactor)
                            return clearCofactor(Point2, this);
                        return this.multiplyUnsafe(CURVE.h);
                    }
                    toRawBytes(isCompressed = true) {
                        this.assertValidity();
                        return toBytes4(Point2, this, isCompressed);
                    }
                    toHex(isCompressed = true) {
                        return bytesToHex(this.toRawBytes(isCompressed));
                    }
                }
                Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
                Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
                const _bits = CURVE.nBitLength;
                const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
                return {
                    CURVE,
                    ProjectivePoint: Point2,
                    normPrivateKeyToScalar,
                    weierstrassEquation,
                    isWithinCurveOrder
                };
            }
            function validateOpts(curve) {
                const opts = validateBasic(curve);
                validateObject(opts, {
                    hash: "hash",
                    hmac: "function",
                    randomBytes: "function"
                }, {
                    bits2int: "function",
                    bits2int_modN: "function",
                    lowS: "boolean"
                });
                return Object.freeze({ lowS: true, ...opts });
            }
            function weierstrass(curveDef) {
                const CURVE = validateOpts(curveDef);
                const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
                const compressedLen = Fp2.BYTES + 1;
                const uncompressedLen = 2 * Fp2.BYTES + 1;
                function isValidFieldElement(num) {
                    return _0n4 < num && num < Fp2.ORDER;
                }
                function modN2(a) {
                    return mod(a, CURVE_ORDER);
                }
                function invN(a) {
                    return invert(a, CURVE_ORDER);
                }
                const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
                    ...CURVE,
                    toBytes(_c, point, isCompressed) {
                        const a = point.toAffine();
                        const x = Fp2.toBytes(a.x);
                        const cat = concatBytes2;
                        if (isCompressed) {
                            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
                        } else {
                            return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
                        }
                    },
                    fromBytes(bytes4) {
                        const len = bytes4.length;
                        const head = bytes4[0];
                        const tail = bytes4.subarray(1);
                        if (len === compressedLen && (head === 2 || head === 3)) {
                            const x = bytesToNumberBE(tail);
                            if (!isValidFieldElement(x))
                                throw new Error("Point is not on curve");
                            const y2 = weierstrassEquation(x);
                            let y = Fp2.sqrt(y2);
                            const isYOdd = (y & _1n4) === _1n4;
                            const isHeadOdd = (head & 1) === 1;
                            if (isHeadOdd !== isYOdd)
                                y = Fp2.neg(y);
                            return { x, y };
                        } else if (len === uncompressedLen && head === 4) {
                            const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
                            const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
                            return { x, y };
                        } else {
                            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
                        }
                    }
                });
                const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
                function isBiggerThanHalfOrder(number4) {
                    const HALF = CURVE_ORDER >> _1n4;
                    return number4 > HALF;
                }
                function normalizeS(s) {
                    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
                }
                const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
                class Signature {
                    constructor(r, s, recovery) {
                        this.r = r;
                        this.s = s;
                        this.recovery = recovery;
                        this.assertValidity();
                    }
                    static fromCompact(hex2) {
                        const l = CURVE.nByteLength;
                        hex2 = ensureBytes("compactSignature", hex2, l * 2);
                        return new Signature(slcNum(hex2, 0, l), slcNum(hex2, l, 2 * l));
                    }
                    static fromDER(hex2) {
                        const { r, s } = DER.toSig(ensureBytes("DER", hex2));
                        return new Signature(r, s);
                    }
                    assertValidity() {
                        if (!isWithinCurveOrder(this.r))
                            throw new Error("r must be 0 < r < CURVE.n");
                        if (!isWithinCurveOrder(this.s))
                            throw new Error("s must be 0 < s < CURVE.n");
                    }
                    addRecoveryBit(recovery) {
                        return new Signature(this.r, this.s, recovery);
                    }
                    recoverPublicKey(msgHash) {
                        const { r, s, recovery: rec } = this;
                        const h = bits2int_modN(ensureBytes("msgHash", msgHash));
                        if (rec == null || ![0, 1, 2, 3].includes(rec))
                            throw new Error("recovery id invalid");
                        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
                        if (radj >= Fp2.ORDER)
                            throw new Error("recovery id 2 or 3 invalid");
                        const prefix = (rec & 1) === 0 ? "02" : "03";
                        const R = Point2.fromHex(prefix + numToNByteStr(radj));
                        const ir = invN(radj);
                        const u1 = modN2(-h * ir);
                        const u2 = modN2(s * ir);
                        const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
                        if (!Q)
                            throw new Error("point at infinify");
                        Q.assertValidity();
                        return Q;
                    }
                    hasHighS() {
                        return isBiggerThanHalfOrder(this.s);
                    }
                    normalizeS() {
                        return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
                    }
                    toDERRawBytes() {
                        return hexToBytes(this.toDERHex());
                    }
                    toDERHex() {
                        return DER.hexFromSig({ r: this.r, s: this.s });
                    }
                    toCompactRawBytes() {
                        return hexToBytes(this.toCompactHex());
                    }
                    toCompactHex() {
                        return numToNByteStr(this.r) + numToNByteStr(this.s);
                    }
                }
                const utils = {
                    isValidPrivateKey(privateKey) {
                        try {
                            normPrivateKeyToScalar(privateKey);
                            return true;
                        } catch (error) {
                            return false;
                        }
                    },
                    normPrivateKeyToScalar,
                    randomPrivateKey: () => {
                        const length = getMinHashLength(CURVE.n);
                        return mapHashToField(CURVE.randomBytes(length), CURVE.n);
                    },
                    precompute(windowSize = 8, point = Point2.BASE) {
                        point._setWindowSize(windowSize);
                        point.multiply(BigInt(3));
                        return point;
                    }
                };
                function getPublicKey2(privateKey, isCompressed = true) {
                    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
                }
                function isProbPub(item) {
                    const arr = item instanceof Uint8Array;
                    const str = typeof item === "string";
                    const len = (arr || str) && item.length;
                    if (arr)
                        return len === compressedLen || len === uncompressedLen;
                    if (str)
                        return len === 2 * compressedLen || len === 2 * uncompressedLen;
                    if (item instanceof Point2)
                        return true;
                    return false;
                }
                function getSharedSecret(privateA, publicB, isCompressed = true) {
                    if (isProbPub(privateA))
                        throw new Error("first arg must be private key");
                    if (!isProbPub(publicB))
                        throw new Error("second arg must be public key");
                    const b = Point2.fromHex(publicB);
                    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
                }
                const bits2int = CURVE.bits2int || function (bytes4) {
                    const num = bytesToNumberBE(bytes4);
                    const delta = bytes4.length * 8 - CURVE.nBitLength;
                    return delta > 0 ? num >> BigInt(delta) : num;
                };
                const bits2int_modN = CURVE.bits2int_modN || function (bytes4) {
                    return modN2(bits2int(bytes4));
                };
                const ORDER_MASK = bitMask(CURVE.nBitLength);
                function int2octets(num) {
                    if (typeof num !== "bigint")
                        throw new Error("bigint expected");
                    if (!(_0n4 <= num && num < ORDER_MASK))
                        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
                    return numberToBytesBE(num, CURVE.nByteLength);
                }
                function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
                    if (["recovered", "canonical"].some((k) => k in opts))
                        throw new Error("sign() legacy options not supported");
                    const { hash: hash3, randomBytes: randomBytes3 } = CURVE;
                    let { lowS, prehash, extraEntropy: ent } = opts;
                    if (lowS == null)
                        lowS = true;
                    msgHash = ensureBytes("msgHash", msgHash);
                    if (prehash)
                        msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
                    const h1int = bits2int_modN(msgHash);
                    const d = normPrivateKeyToScalar(privateKey);
                    const seedArgs = [int2octets(d), int2octets(h1int)];
                    if (ent != null) {
                        const e = ent === true ? randomBytes3(Fp2.BYTES) : ent;
                        seedArgs.push(ensureBytes("extraEntropy", e));
                    }
                    const seed = concatBytes2(...seedArgs);
                    const m = h1int;
                    function k2sig(kBytes) {
                        const k = bits2int(kBytes);
                        if (!isWithinCurveOrder(k))
                            return;
                        const ik = invN(k);
                        const q = Point2.BASE.multiply(k).toAffine();
                        const r = modN2(q.x);
                        if (r === _0n4)
                            return;
                        const s = modN2(ik * modN2(m + r * d));
                        if (s === _0n4)
                            return;
                        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
                        let normS = s;
                        if (lowS && isBiggerThanHalfOrder(s)) {
                            normS = normalizeS(s);
                            recovery ^= 1;
                        }
                        return new Signature(r, normS, recovery);
                    }
                    return { seed, k2sig };
                }
                const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
                const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
                function sign(msgHash, privKey, opts = defaultSigOpts) {
                    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
                    const C = CURVE;
                    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
                    return drbg(seed, k2sig);
                }
                Point2.BASE._setWindowSize(8);
                function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
                    const sg = signature;
                    msgHash = ensureBytes("msgHash", msgHash);
                    publicKey = ensureBytes("publicKey", publicKey);
                    if ("strict" in opts)
                        throw new Error("options.strict was renamed to lowS");
                    const { lowS, prehash } = opts;
                    let _sig = void 0;
                    let P;
                    try {
                        if (typeof sg === "string" || sg instanceof Uint8Array) {
                            try {
                                _sig = Signature.fromDER(sg);
                            } catch (derError) {
                                if (!(derError instanceof DER.Err))
                                    throw derError;
                                _sig = Signature.fromCompact(sg);
                            }
                        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
                            const { r: r2, s: s2 } = sg;
                            _sig = new Signature(r2, s2);
                        } else {
                            throw new Error("PARSE");
                        }
                        P = Point2.fromHex(publicKey);
                    } catch (error) {
                        if (error.message === "PARSE")
                            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
                        return false;
                    }
                    if (lowS && _sig.hasHighS())
                        return false;
                    if (prehash)
                        msgHash = CURVE.hash(msgHash);
                    const { r, s } = _sig;
                    const h = bits2int_modN(msgHash);
                    const is = invN(s);
                    const u1 = modN2(h * is);
                    const u2 = modN2(r * is);
                    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
                    if (!R)
                        return false;
                    const v = modN2(R.x);
                    return v === r;
                }
                return {
                    CURVE,
                    getPublicKey: getPublicKey2,
                    getSharedSecret,
                    sign,
                    verify,
                    ProjectivePoint: Point2,
                    Signature,
                    utils
                };
            }

            // node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js
            var HMAC = class extends Hash {
                constructor(hash3, _key) {
                    super();
                    this.finished = false;
                    this.destroyed = false;
                    hash(hash3);
                    const key = toBytes(_key);
                    this.iHash = hash3.create();
                    if (typeof this.iHash.update !== "function")
                        throw new Error("Expected instance of class which extends utils.Hash");
                    this.blockLen = this.iHash.blockLen;
                    this.outputLen = this.iHash.outputLen;
                    const blockLen = this.blockLen;
                    const pad2 = new Uint8Array(blockLen);
                    pad2.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
                    for (let i2 = 0; i2 < pad2.length; i2++)
                        pad2[i2] ^= 54;
                    this.iHash.update(pad2);
                    this.oHash = hash3.create();
                    for (let i2 = 0; i2 < pad2.length; i2++)
                        pad2[i2] ^= 54 ^ 92;
                    this.oHash.update(pad2);
                    pad2.fill(0);
                }
                update(buf) {
                    exists(this);
                    this.iHash.update(buf);
                    return this;
                }
                digestInto(out) {
                    exists(this);
                    bytes(out, this.outputLen);
                    this.finished = true;
                    this.iHash.digestInto(out);
                    this.oHash.update(out);
                    this.oHash.digestInto(out);
                    this.destroy();
                }
                digest() {
                    const out = new Uint8Array(this.oHash.outputLen);
                    this.digestInto(out);
                    return out;
                }
                _cloneInto(to) {
                    to || (to = Object.create(Object.getPrototypeOf(this), {}));
                    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
                    to = to;
                    to.finished = finished;
                    to.destroyed = destroyed;
                    to.blockLen = blockLen;
                    to.outputLen = outputLen;
                    to.oHash = oHash._cloneInto(to.oHash);
                    to.iHash = iHash._cloneInto(to.iHash);
                    return to;
                }
                destroy() {
                    this.destroyed = true;
                    this.oHash.destroy();
                    this.iHash.destroy();
                }
            };
            var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
            hmac.create = (hash3, key) => new HMAC(hash3, key);

            // node_modules/@noble/curves/esm/_shortw_utils.js
            function getHash(hash3) {
                return {
                    hash: hash3,
                    hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
                    randomBytes
                };
            }
            function createCurve(curveDef, defHash) {
                const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
                return Object.freeze({ ...create(defHash), create });
            }

            // node_modules/@noble/curves/esm/secp256k1.js
            var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
            var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
            var _1n5 = BigInt(1);
            var _2n4 = BigInt(2);
            var divNearest = (a, b) => (a + b / _2n4) / b;
            function sqrtMod(y) {
                const P = secp256k1P;
                const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
                const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
                const b2 = y * y * y % P;
                const b3 = b2 * b2 * y % P;
                const b6 = pow2(b3, _3n3, P) * b3 % P;
                const b9 = pow2(b6, _3n3, P) * b3 % P;
                const b11 = pow2(b9, _2n4, P) * b2 % P;
                const b22 = pow2(b11, _11n, P) * b11 % P;
                const b44 = pow2(b22, _22n, P) * b22 % P;
                const b88 = pow2(b44, _44n, P) * b44 % P;
                const b176 = pow2(b88, _88n, P) * b88 % P;
                const b220 = pow2(b176, _44n, P) * b44 % P;
                const b223 = pow2(b220, _3n3, P) * b3 % P;
                const t1 = pow2(b223, _23n, P) * b22 % P;
                const t2 = pow2(t1, _6n, P) * b2 % P;
                const root = pow2(t2, _2n4, P);
                if (!Fp.eql(Fp.sqr(root), y))
                    throw new Error("Cannot find square root");
                return root;
            }
            var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
            var secp256k1 = createCurve({
                a: BigInt(0),
                b: BigInt(7),
                Fp,
                n: secp256k1N,
                Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                h: BigInt(1),
                lowS: true,
                endo: {
                    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                    splitScalar: (k) => {
                        const n = secp256k1N;
                        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
                        const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
                        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
                        const b2 = a1;
                        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
                        const c1 = divNearest(b2 * k, n);
                        const c2 = divNearest(-b1 * k, n);
                        let k1 = mod(k - c1 * a1 - c2 * a2, n);
                        let k2 = mod(-c1 * b1 - c2 * b2, n);
                        const k1neg = k1 > POW_2_128;
                        const k2neg = k2 > POW_2_128;
                        if (k1neg)
                            k1 = n - k1;
                        if (k2neg)
                            k2 = n - k2;
                        if (k1 > POW_2_128 || k2 > POW_2_128) {
                            throw new Error("splitScalar: Endomorphism failed, k=" + k);
                        }
                        return { k1neg, k1, k2neg, k2 };
                    }
                }
            }, sha256);
            var _0n5 = BigInt(0);
            var fe = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1P;
            var ge = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1N;
            var TAGGED_HASH_PREFIXES = {};
            function taggedHash(tag, ...messages) {
                let tagP = TAGGED_HASH_PREFIXES[tag];
                if (tagP === void 0) {
                    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
                    tagP = concatBytes2(tagH, tagH);
                    TAGGED_HASH_PREFIXES[tag] = tagP;
                }
                return sha256(concatBytes2(tagP, ...messages));
            }
            var pointToBytes = (point) => point.toRawBytes(true).slice(1);
            var numTo32b = (n) => numberToBytesBE(n, 32);
            var modP = (x) => mod(x, secp256k1P);
            var modN = (x) => mod(x, secp256k1N);
            var Point = secp256k1.ProjectivePoint;
            var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
            function schnorrGetExtPubKey(priv) {
                let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
                let p = Point.fromPrivateKey(d_);
                const scalar = p.hasEvenY() ? d_ : modN(-d_);
                return { scalar, bytes: pointToBytes(p) };
            }
            function lift_x(x) {
                if (!fe(x))
                    throw new Error("bad x: need 0 < x < p");
                const xx = modP(x * x);
                const c = modP(xx * x + BigInt(7));
                let y = sqrtMod(c);
                if (y % _2n4 !== _0n5)
                    y = modP(-y);
                const p = new Point(x, y, _1n5);
                p.assertValidity();
                return p;
            }
            function challenge(...args) {
                return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
            }
            function schnorrGetPublicKey(privateKey) {
                return schnorrGetExtPubKey(privateKey).bytes;
            }
            function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
                const m = ensureBytes("message", message);
                const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
                const a = ensureBytes("auxRand", auxRand, 32);
                const t = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a)));
                const rand = taggedHash("BIP0340/nonce", t, px, m);
                const k_ = modN(bytesToNumberBE(rand));
                if (k_ === _0n5)
                    throw new Error("sign failed: k is zero");
                const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
                const e = challenge(rx, px, m);
                const sig = new Uint8Array(64);
                sig.set(rx, 0);
                sig.set(numTo32b(modN(k + e * d)), 32);
                if (!schnorrVerify(sig, m, px))
                    throw new Error("sign: Invalid signature produced");
                return sig;
            }
            function schnorrVerify(signature, message, publicKey) {
                const sig = ensureBytes("signature", signature, 64);
                const m = ensureBytes("message", message);
                const pub = ensureBytes("publicKey", publicKey, 32);
                try {
                    const P = lift_x(bytesToNumberBE(pub));
                    const r = bytesToNumberBE(sig.subarray(0, 32));
                    if (!fe(r))
                        return false;
                    const s = bytesToNumberBE(sig.subarray(32, 64));
                    if (!ge(s))
                        return false;
                    const e = challenge(numTo32b(r), pointToBytes(P), m);
                    const R = GmulAdd(P, s, modN(-e));
                    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
                        return false;
                    return true;
                } catch (error) {
                    return false;
                }
            }
            var schnorr = /* @__PURE__ */ (() => ({
                getPublicKey: schnorrGetPublicKey,
                sign: schnorrSign,
                verify: schnorrVerify,
                utils: {
                    randomPrivateKey: secp256k1.utils.randomPrivateKey,
                    lift_x,
                    pointToBytes,
                    numberToBytesBE,
                    bytesToNumberBE,
                    taggedHash,
                    mod
                }
            }))();

            // node_modules/@noble/hashes/esm/crypto.js
            var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

            // node_modules/@noble/hashes/esm/utils.js
            var u8a3 = (a) => a instanceof Uint8Array;
            var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
            var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
            var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
            if (!isLE2)
                throw new Error("Non little-endian hardware is not supported");
            var hexes2 = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
            function bytesToHex2(bytes4) {
                if (!u8a3(bytes4))
                    throw new Error("Uint8Array expected");
                let hex2 = "";
                for (let i2 = 0; i2 < bytes4.length; i2++) {
                    hex2 += hexes2[bytes4[i2]];
                }
                return hex2;
            }
            function hexToBytes2(hex2) {
                if (typeof hex2 !== "string")
                    throw new Error("hex string expected, got " + typeof hex2);
                const len = hex2.length;
                if (len % 2)
                    throw new Error("padded hex string expected, got unpadded hex of length " + len);
                const array = new Uint8Array(len / 2);
                for (let i2 = 0; i2 < array.length; i2++) {
                    const j = i2 * 2;
                    const hexByte = hex2.slice(j, j + 2);
                    const byte = Number.parseInt(hexByte, 16);
                    if (Number.isNaN(byte) || byte < 0)
                        throw new Error("Invalid byte sequence");
                    array[i2] = byte;
                }
                return array;
            }
            function utf8ToBytes3(str) {
                if (typeof str !== "string")
                    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
                return new Uint8Array(new TextEncoder().encode(str));
            }
            function toBytes2(data) {
                if (typeof data === "string")
                    data = utf8ToBytes3(data);
                if (!u8a3(data))
                    throw new Error(`expected Uint8Array, got ${typeof data}`);
                return data;
            }
            function concatBytes3(...arrays) {
                const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
                let pad2 = 0;
                arrays.forEach((a) => {
                    if (!u8a3(a))
                        throw new Error("Uint8Array expected");
                    r.set(a, pad2);
                    pad2 += a.length;
                });
                return r;
            }
            var Hash2 = class {
                clone() {
                    return this._cloneInto();
                }
            };
            function wrapConstructor2(hashCons) {
                const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
                const tmp = hashCons();
                hashC.outputLen = tmp.outputLen;
                hashC.blockLen = tmp.blockLen;
                hashC.create = () => hashCons();
                return hashC;
            }
            function randomBytes2(bytesLength = 32) {
                if (crypto2 && typeof crypto2.getRandomValues === "function") {
                    return crypto2.getRandomValues(new Uint8Array(bytesLength));
                }
                throw new Error("crypto.getRandomValues must be defined");
            }

            // core.ts
            var verifiedSymbol = Symbol("verified");
            var isRecord = (obj) => obj instanceof Object;
            function validateEvent(event) {
                if (!isRecord(event))
                    return false;
                if (typeof event.kind !== "number")
                    return false;
                if (typeof event.content !== "string")
                    return false;
                if (typeof event.created_at !== "number")
                    return false;
                if (typeof event.pubkey !== "string")
                    return false;
                if (!event.pubkey.match(/^[a-f0-9]{64}$/))
                    return false;
                if (!Array.isArray(event.tags))
                    return false;
                for (let i2 = 0; i2 < event.tags.length; i2++) {
                    let tag = event.tags[i2];
                    if (!Array.isArray(tag))
                        return false;
                    for (let j = 0; j < tag.length; j++) {
                        if (typeof tag[j] === "object")
                            return false;
                    }
                }
                return true;
            }
            function sortEvents(events) {
                return events.sort((a, b) => {
                    if (a.created_at !== b.created_at) {
                        return b.created_at - a.created_at;
                    }
                    return a.id.localeCompare(b.id);
                });
            }

            // node_modules/@noble/hashes/esm/_assert.js
            function number2(n) {
                if (!Number.isSafeInteger(n) || n < 0)
                    throw new Error(`Wrong positive integer: ${n}`);
            }
            function bool(b) {
                if (typeof b !== "boolean")
                    throw new Error(`Expected boolean, not ${b}`);
            }
            function bytes2(b, ...lengths) {
                if (!(b instanceof Uint8Array))
                    throw new Error("Expected Uint8Array");
                if (lengths.length > 0 && !lengths.includes(b.length))
                    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
            }
            function hash2(hash3) {
                if (typeof hash3 !== "function" || typeof hash3.create !== "function")
                    throw new Error("Hash should be wrapped by utils.wrapConstructor");
                number2(hash3.outputLen);
                number2(hash3.blockLen);
            }
            function exists2(instance, checkFinished = true) {
                if (instance.destroyed)
                    throw new Error("Hash instance has been destroyed");
                if (checkFinished && instance.finished)
                    throw new Error("Hash#digest() has already been called");
            }
            function output2(out, instance) {
                bytes2(out);
                const min = instance.outputLen;
                if (out.length < min) {
                    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
                }
            }
            var assert = {
                number: number2,
                bool,
                bytes: bytes2,
                hash: hash2,
                exists: exists2,
                output: output2
            };
            var assert_default = assert;

            // node_modules/@noble/hashes/esm/_sha2.js
            function setBigUint642(view, byteOffset, value, isLE4) {
                if (typeof view.setBigUint64 === "function")
                    return view.setBigUint64(byteOffset, value, isLE4);
                const _32n = BigInt(32);
                const _u32_max = BigInt(4294967295);
                const wh = Number(value >> _32n & _u32_max);
                const wl = Number(value & _u32_max);
                const h = isLE4 ? 4 : 0;
                const l = isLE4 ? 0 : 4;
                view.setUint32(byteOffset + h, wh, isLE4);
                view.setUint32(byteOffset + l, wl, isLE4);
            }
            var SHA22 = class extends Hash2 {
                constructor(blockLen, outputLen, padOffset, isLE4) {
                    super();
                    this.blockLen = blockLen;
                    this.outputLen = outputLen;
                    this.padOffset = padOffset;
                    this.isLE = isLE4;
                    this.finished = false;
                    this.length = 0;
                    this.pos = 0;
                    this.destroyed = false;
                    this.buffer = new Uint8Array(blockLen);
                    this.view = createView2(this.buffer);
                }
                update(data) {
                    assert_default.exists(this);
                    const { view, buffer, blockLen } = this;
                    data = toBytes2(data);
                    const len = data.length;
                    for (let pos = 0; pos < len;) {
                        const take = Math.min(blockLen - this.pos, len - pos);
                        if (take === blockLen) {
                            const dataView = createView2(data);
                            for (; blockLen <= len - pos; pos += blockLen)
                                this.process(dataView, pos);
                            continue;
                        }
                        buffer.set(data.subarray(pos, pos + take), this.pos);
                        this.pos += take;
                        pos += take;
                        if (this.pos === blockLen) {
                            this.process(view, 0);
                            this.pos = 0;
                        }
                    }
                    this.length += data.length;
                    this.roundClean();
                    return this;
                }
                digestInto(out) {
                    assert_default.exists(this);
                    assert_default.output(out, this);
                    this.finished = true;
                    const { buffer, view, blockLen, isLE: isLE4 } = this;
                    let { pos } = this;
                    buffer[pos++] = 128;
                    this.buffer.subarray(pos).fill(0);
                    if (this.padOffset > blockLen - pos) {
                        this.process(view, 0);
                        pos = 0;
                    }
                    for (let i2 = pos; i2 < blockLen; i2++)
                        buffer[i2] = 0;
                    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE4);
                    this.process(view, 0);
                    const oview = createView2(out);
                    const len = this.outputLen;
                    if (len % 4)
                        throw new Error("_sha2: outputLen should be aligned to 32bit");
                    const outLen = len / 4;
                    const state = this.get();
                    if (outLen > state.length)
                        throw new Error("_sha2: outputLen bigger than state");
                    for (let i2 = 0; i2 < outLen; i2++)
                        oview.setUint32(4 * i2, state[i2], isLE4);
                }
                digest() {
                    const { buffer, outputLen } = this;
                    this.digestInto(buffer);
                    const res = buffer.slice(0, outputLen);
                    this.destroy();
                    return res;
                }
                _cloneInto(to) {
                    to || (to = new this.constructor());
                    to.set(...this.get());
                    const { blockLen, buffer, length, finished, destroyed, pos } = this;
                    to.length = length;
                    to.pos = pos;
                    to.finished = finished;
                    to.destroyed = destroyed;
                    if (length % blockLen)
                        to.buffer.set(buffer);
                    return to;
                }
            };

            // node_modules/@noble/hashes/esm/sha256.js
            var Chi2 = (a, b, c) => a & b ^ ~a & c;
            var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
            var SHA256_K2 = new Uint32Array([
                1116352408,
                1899447441,
                3049323471,
                3921009573,
                961987163,
                1508970993,
                2453635748,
                2870763221,
                3624381080,
                310598401,
                607225278,
                1426881987,
                1925078388,
                2162078206,
                2614888103,
                3248222580,
                3835390401,
                4022224774,
                264347078,
                604807628,
                770255983,
                1249150122,
                1555081692,
                1996064986,
                2554220882,
                2821834349,
                2952996808,
                3210313671,
                3336571891,
                3584528711,
                113926993,
                338241895,
                666307205,
                773529912,
                1294757372,
                1396182291,
                1695183700,
                1986661051,
                2177026350,
                2456956037,
                2730485921,
                2820302411,
                3259730800,
                3345764771,
                3516065817,
                3600352804,
                4094571909,
                275423344,
                430227734,
                506948616,
                659060556,
                883997877,
                958139571,
                1322822218,
                1537002063,
                1747873779,
                1955562222,
                2024104815,
                2227730452,
                2361852424,
                2428436474,
                2756734187,
                3204031479,
                3329325298
            ]);
            var IV2 = new Uint32Array([
                1779033703,
                3144134277,
                1013904242,
                2773480762,
                1359893119,
                2600822924,
                528734635,
                1541459225
            ]);
            var SHA256_W2 = new Uint32Array(64);
            var SHA2562 = class extends SHA22 {
                constructor() {
                    super(64, 32, 8, false);
                    this.A = IV2[0] | 0;
                    this.B = IV2[1] | 0;
                    this.C = IV2[2] | 0;
                    this.D = IV2[3] | 0;
                    this.E = IV2[4] | 0;
                    this.F = IV2[5] | 0;
                    this.G = IV2[6] | 0;
                    this.H = IV2[7] | 0;
                }
                get() {
                    const { A, B, C, D, E, F, G, H } = this;
                    return [A, B, C, D, E, F, G, H];
                }
                set(A, B, C, D, E, F, G, H) {
                    this.A = A | 0;
                    this.B = B | 0;
                    this.C = C | 0;
                    this.D = D | 0;
                    this.E = E | 0;
                    this.F = F | 0;
                    this.G = G | 0;
                    this.H = H | 0;
                }
                process(view, offset) {
                    for (let i2 = 0; i2 < 16; i2++, offset += 4)
                        SHA256_W2[i2] = view.getUint32(offset, false);
                    for (let i2 = 16; i2 < 64; i2++) {
                        const W15 = SHA256_W2[i2 - 15];
                        const W2 = SHA256_W2[i2 - 2];
                        const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
                        const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
                        SHA256_W2[i2] = s1 + SHA256_W2[i2 - 7] + s0 + SHA256_W2[i2 - 16] | 0;
                    }
                    let { A, B, C, D, E, F, G, H } = this;
                    for (let i2 = 0; i2 < 64; i2++) {
                        const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
                        const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i2] + SHA256_W2[i2] | 0;
                        const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
                        const T2 = sigma0 + Maj2(A, B, C) | 0;
                        H = G;
                        G = F;
                        F = E;
                        E = D + T1 | 0;
                        D = C;
                        C = B;
                        B = A;
                        A = T1 + T2 | 0;
                    }
                    A = A + this.A | 0;
                    B = B + this.B | 0;
                    C = C + this.C | 0;
                    D = D + this.D | 0;
                    E = E + this.E | 0;
                    F = F + this.F | 0;
                    G = G + this.G | 0;
                    H = H + this.H | 0;
                    this.set(A, B, C, D, E, F, G, H);
                }
                roundClean() {
                    SHA256_W2.fill(0);
                }
                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0);
                    this.buffer.fill(0);
                }
            };
            var SHA224 = class extends SHA2562 {
                constructor() {
                    super();
                    this.A = 3238371032 | 0;
                    this.B = 914150663 | 0;
                    this.C = 812702999 | 0;
                    this.D = 4144912697 | 0;
                    this.E = 4290775857 | 0;
                    this.F = 1750603025 | 0;
                    this.G = 1694076839 | 0;
                    this.H = 3204075428 | 0;
                    this.outputLen = 28;
                }
            };
            var sha2562 = wrapConstructor2(() => new SHA2562());
            var sha224 = wrapConstructor2(() => new SHA224());

            // utils.ts
            var utils_exports2 = {};
            __export(utils_exports2, {
                Queue: () => Queue,
                QueueNode: () => QueueNode,
                binarySearch: () => binarySearch,
                insertEventIntoAscendingList: () => insertEventIntoAscendingList,
                insertEventIntoDescendingList: () => insertEventIntoDescendingList,
                normalizeURL: () => normalizeURL,
                utf8Decoder: () => utf8Decoder,
                utf8Encoder: () => utf8Encoder
            });
            var utf8Decoder = new TextDecoder("utf-8");
            var utf8Encoder = new TextEncoder();
            function normalizeURL(url) {
                if (url.indexOf("://") === -1)
                    url = "wss://" + url;
                let p = new URL(url);
                p.pathname = p.pathname.replace(/\/+/g, "/");
                if (p.pathname.endsWith("/"))
                    p.pathname = p.pathname.slice(0, -1);
                if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
                    p.port = "";
                p.searchParams.sort();
                p.hash = "";
                return p.toString();
            }
            function insertEventIntoDescendingList(sortedArray, event) {
                const [idx, found] = binarySearch(sortedArray, (b) => {
                    if (event.id === b.id)
                        return 0;
                    if (event.created_at === b.created_at)
                        return -1;
                    return b.created_at - event.created_at;
                });
                if (!found) {
                    sortedArray.splice(idx, 0, event);
                }
                return sortedArray;
            }
            function insertEventIntoAscendingList(sortedArray, event) {
                const [idx, found] = binarySearch(sortedArray, (b) => {
                    if (event.id === b.id)
                        return 0;
                    if (event.created_at === b.created_at)
                        return -1;
                    return event.created_at - b.created_at;
                });
                if (!found) {
                    sortedArray.splice(idx, 0, event);
                }
                return sortedArray;
            }
            function binarySearch(arr, compare) {
                let start = 0;
                let end = arr.length - 1;
                while (start <= end) {
                    const mid = Math.floor((start + end) / 2);
                    const cmp = compare(arr[mid]);
                    if (cmp === 0) {
                        return [mid, true];
                    }
                    if (cmp < 0) {
                        end = mid - 1;
                    } else {
                        start = mid + 1;
                    }
                }
                return [start, false];
            }
            var QueueNode = class {
                value;
                next = null;
                prev = null;
                constructor(message) {
                    this.value = message;
                }
            };
            var Queue = class {
                first;
                last;
                constructor() {
                    this.first = null;
                    this.last = null;
                }
                enqueue(value) {
                    const newNode = new QueueNode(value);
                    if (!this.last) {
                        this.first = newNode;
                        this.last = newNode;
                    } else if (this.last === this.first) {
                        this.last = newNode;
                        this.last.prev = this.first;
                        this.first.next = newNode;
                    } else {
                        newNode.prev = this.last;
                        this.last.next = newNode;
                        this.last = newNode;
                    }
                    return true;
                }
                dequeue() {
                    if (!this.first)
                        return null;
                    if (this.first === this.last) {
                        const target2 = this.first;
                        this.first = null;
                        this.last = null;
                        return target2.value;
                    }
                    const target = this.first;
                    this.first = target.next;
                    return target.value;
                }
            };

            // pure.ts
            var JS = class {
                generateSecretKey() {
                    return schnorr.utils.randomPrivateKey();
                }
                getPublicKey(secretKey) {
                    return bytesToHex2(schnorr.getPublicKey(secretKey));
                }
                finalizeEvent(t, secretKey) {
                    const event = t;
                    event.pubkey = bytesToHex2(schnorr.getPublicKey(secretKey));
                    event.id = getEventHash(event);
                    event.sig = bytesToHex2(schnorr.sign(getEventHash(event), secretKey));
                    event[verifiedSymbol] = true;
                    return event;
                }
                verifyEvent(event) {
                    if (typeof event[verifiedSymbol] === "boolean")
                        return event[verifiedSymbol];
                    const hash3 = getEventHash(event);
                    if (hash3 !== event.id) {
                        event[verifiedSymbol] = false;
                        return false;
                    }
                    try {
                        const valid = schnorr.verify(event.sig, hash3, event.pubkey);
                        event[verifiedSymbol] = valid;
                        return valid;
                    } catch (err) {
                        event[verifiedSymbol] = false;
                        return false;
                    }
                }
            };
            function serializeEvent(evt) {
                if (!validateEvent(evt))
                    throw new Error("can't serialize event with wrong or missing properties");
                return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);
            }
            function getEventHash(event) {
                let eventHash = sha2562(utf8Encoder.encode(serializeEvent(event)));
                return bytesToHex2(eventHash);
            }
            var i = new JS();
            var generateSecretKey = i.generateSecretKey;
            var getPublicKey = i.getPublicKey;
            var finalizeEvent = i.finalizeEvent;
            var verifyEvent = i.verifyEvent;

            // kinds.ts
            var kinds_exports = {};
            __export(kinds_exports, {
                Application: () => Application,
                BadgeAward: () => BadgeAward,
                BadgeDefinition: () => BadgeDefinition,
                BlockedRelaysList: () => BlockedRelaysList,
                BookmarkList: () => BookmarkList,
                Bookmarksets: () => Bookmarksets,
                Calendar: () => Calendar,
                CalendarEventRSVP: () => CalendarEventRSVP,
                ChannelCreation: () => ChannelCreation,
                ChannelHideMessage: () => ChannelHideMessage,
                ChannelMessage: () => ChannelMessage,
                ChannelMetadata: () => ChannelMetadata,
                ChannelMuteUser: () => ChannelMuteUser,
                ClassifiedListing: () => ClassifiedListing,
                ClientAuth: () => ClientAuth,
                CommunitiesList: () => CommunitiesList,
                CommunityDefinition: () => CommunityDefinition,
                CommunityPostApproval: () => CommunityPostApproval,
                Contacts: () => Contacts,
                CreateOrUpdateProduct: () => CreateOrUpdateProduct,
                CreateOrUpdateStall: () => CreateOrUpdateStall,
                Curationsets: () => Curationsets,
                Date: () => Date2,
                DraftClassifiedListing: () => DraftClassifiedListing,
                DraftLong: () => DraftLong,
                Emojisets: () => Emojisets,
                EncryptedDirectMessage: () => EncryptedDirectMessage,
                EncryptedDirectMessages: () => EncryptedDirectMessages,
                EventDeletion: () => EventDeletion,
                FileMetadata: () => FileMetadata,
                FileServerPreference: () => FileServerPreference,
                Followsets: () => Followsets,
                GenericRepost: () => GenericRepost,
                Genericlists: () => Genericlists,
                HTTPAuth: () => HTTPAuth,
                Handlerinformation: () => Handlerinformation,
                Handlerrecommendation: () => Handlerrecommendation,
                Highlights: () => Highlights,
                InterestsList: () => InterestsList,
                Interestsets: () => Interestsets,
                JobFeedback: () => JobFeedback,
                JobRequest: () => JobRequest,
                JobResult: () => JobResult,
                Label: () => Label,
                LightningPubRPC: () => LightningPubRPC,
                LiveChatMessage: () => LiveChatMessage,
                LiveEvent: () => LiveEvent,
                LongFormArticle: () => LongFormArticle,
                Metadata: () => Metadata,
                Mutelist: () => Mutelist,
                NWCWalletInfo: () => NWCWalletInfo,
                NWCWalletRequest: () => NWCWalletRequest,
                NWCWalletResponse: () => NWCWalletResponse,
                NostrConnect: () => NostrConnect,
                OpenTimestamps: () => OpenTimestamps,
                Pinlist: () => Pinlist,
                ProblemTracker: () => ProblemTracker,
                ProfileBadges: () => ProfileBadges,
                PublicChatsList: () => PublicChatsList,
                Reaction: () => Reaction,
                RecommendRelay: () => RecommendRelay,
                RelayList: () => RelayList,
                Relaysets: () => Relaysets,
                Report: () => Report,
                Reporting: () => Reporting,
                Repost: () => Repost,
                SearchRelaysList: () => SearchRelaysList,
                ShortTextNote: () => ShortTextNote,
                Time: () => Time,
                UserEmojiList: () => UserEmojiList,
                UserStatuses: () => UserStatuses,
                Zap: () => Zap,
                ZapGoal: () => ZapGoal,
                ZapRequest: () => ZapRequest,
                classifyKind: () => classifyKind,
                isEphemeralKind: () => isEphemeralKind,
                isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,
                isRegularKind: () => isRegularKind,
                isReplaceableKind: () => isReplaceableKind
            });
            function isRegularKind(kind) {
                return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);
            }
            function isReplaceableKind(kind) {
                return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;
            }
            function isEphemeralKind(kind) {
                return 2e4 <= kind && kind < 3e4;
            }
            function isParameterizedReplaceableKind(kind) {
                return 3e4 <= kind && kind < 4e4;
            }
            function classifyKind(kind) {
                if (isRegularKind(kind))
                    return "regular";
                if (isReplaceableKind(kind))
                    return "replaceable";
                if (isEphemeralKind(kind))
                    return "ephemeral";
                if (isParameterizedReplaceableKind(kind))
                    return "parameterized";
                return "unknown";
            }
            var Metadata = 0;
            var ShortTextNote = 1;
            var RecommendRelay = 2;
            var Contacts = 3;
            var EncryptedDirectMessage = 4;
            var EncryptedDirectMessages = 4;
            var EventDeletion = 5;
            var Repost = 6;
            var Reaction = 7;
            var BadgeAward = 8;
            var GenericRepost = 16;
            var ChannelCreation = 40;
            var ChannelMetadata = 41;
            var ChannelMessage = 42;
            var ChannelHideMessage = 43;
            var ChannelMuteUser = 44;
            var OpenTimestamps = 1040;
            var FileMetadata = 1063;
            var LiveChatMessage = 1311;
            var ProblemTracker = 1971;
            var Report = 1984;
            var Reporting = 1984;
            var Label = 1985;
            var CommunityPostApproval = 4550;
            var JobRequest = 5999;
            var JobResult = 6999;
            var JobFeedback = 7e3;
            var ZapGoal = 9041;
            var ZapRequest = 9734;
            var Zap = 9735;
            var Highlights = 9802;
            var Mutelist = 1e4;
            var Pinlist = 10001;
            var RelayList = 10002;
            var BookmarkList = 10003;
            var CommunitiesList = 10004;
            var PublicChatsList = 10005;
            var BlockedRelaysList = 10006;
            var SearchRelaysList = 10007;
            var InterestsList = 10015;
            var UserEmojiList = 10030;
            var FileServerPreference = 10096;
            var NWCWalletInfo = 13194;
            var LightningPubRPC = 21e3;
            var ClientAuth = 22242;
            var NWCWalletRequest = 23194;
            var NWCWalletResponse = 23195;
            var NostrConnect = 24133;
            var HTTPAuth = 27235;
            var Followsets = 3e4;
            var Genericlists = 30001;
            var Relaysets = 30002;
            var Bookmarksets = 30003;
            var Curationsets = 30004;
            var ProfileBadges = 30008;
            var BadgeDefinition = 30009;
            var Interestsets = 30015;
            var CreateOrUpdateStall = 30017;
            var CreateOrUpdateProduct = 30018;
            var LongFormArticle = 30023;
            var DraftLong = 30024;
            var Emojisets = 30030;
            var Application = 30078;
            var LiveEvent = 30311;
            var UserStatuses = 30315;
            var ClassifiedListing = 30402;
            var DraftClassifiedListing = 30403;
            var Date2 = 31922;
            var Time = 31923;
            var Calendar = 31924;
            var CalendarEventRSVP = 31925;
            var Handlerrecommendation = 31989;
            var Handlerinformation = 31990;
            var CommunityDefinition = 34550;

            // filter.ts
            function matchFilter(filter, event) {
                if (filter.ids && filter.ids.indexOf(event.id) === -1) {
                    return false;
                }
                if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {
                    return false;
                }
                if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {
                    return false;
                }
                for (let f in filter) {
                    if (f[0] === "#") {
                        let tagName = f.slice(1);
                        let values = filter[`#${tagName}`];
                        if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))
                            return false;
                    }
                }
                if (filter.since && event.created_at < filter.since)
                    return false;
                if (filter.until && event.created_at > filter.until)
                    return false;
                return true;
            }
            function matchFilters(filters, event) {
                for (let i2 = 0; i2 < filters.length; i2++) {
                    if (matchFilter(filters[i2], event)) {
                        return true;
                    }
                }
                return false;
            }
            function mergeFilters(...filters) {
                let result = {};
                for (let i2 = 0; i2 < filters.length; i2++) {
                    let filter = filters[i2];
                    Object.entries(filter).forEach(([property, values]) => {
                        if (property === "kinds" || property === "ids" || property === "authors" || property[0] === "#") {
                            result[property] = result[property] || [];
                            for (let v = 0; v < values.length; v++) {
                                let value = values[v];
                                if (!result[property].includes(value))
                                    result[property].push(value);
                            }
                        }
                    });
                    if (filter.limit && (!result.limit || filter.limit > result.limit))
                        result.limit = filter.limit;
                    if (filter.until && (!result.until || filter.until > result.until))
                        result.until = filter.until;
                    if (filter.since && (!result.since || filter.since < result.since))
                        result.since = filter.since;
                }
                return result;
            }
            function getFilterLimit(filter) {
                if (filter.ids && !filter.ids.length)
                    return 0;
                if (filter.kinds && !filter.kinds.length)
                    return 0;
                if (filter.authors && !filter.authors.length)
                    return 0;
                for (const [key, value] of Object.entries(filter)) {
                    if (key[0] === "#" && Array.isArray(value) && !value.length)
                        return 0;
                }
                return Math.min(
                    Math.max(0, filter.limit ?? Infinity),
                    filter.ids?.length ?? Infinity,
                    filter.authors?.length && filter.kinds?.every((kind) => isReplaceableKind(kind)) ? filter.authors.length * filter.kinds.length : Infinity,
                    filter.authors?.length && filter.kinds?.every((kind) => isParameterizedReplaceableKind(kind)) && filter["#d"]?.length ? filter.authors.length * filter.kinds.length * filter["#d"].length : Infinity
                );
            }

            // fakejson.ts
            var fakejson_exports = {};
            __export(fakejson_exports, {
                getHex64: () => getHex64,
                getInt: () => getInt,
                getSubscriptionId: () => getSubscriptionId,
                matchEventId: () => matchEventId,
                matchEventKind: () => matchEventKind,
                matchEventPubkey: () => matchEventPubkey
            });
            function getHex64(json, field) {
                let len = field.length + 3;
                let idx = json.indexOf(`"${field}":`) + len;
                let s = json.slice(idx).indexOf(`"`) + idx + 1;
                return json.slice(s, s + 64);
            }
            function getInt(json, field) {
                let len = field.length;
                let idx = json.indexOf(`"${field}":`) + len + 3;
                let sliced = json.slice(idx);
                let end = Math.min(sliced.indexOf(","), sliced.indexOf("}"));
                return parseInt(sliced.slice(0, end), 10);
            }
            function getSubscriptionId(json) {
                let idx = json.slice(0, 22).indexOf(`"EVENT"`);
                if (idx === -1)
                    return null;
                let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
                if (pstart === -1)
                    return null;
                let start = idx + 7 + 1 + pstart;
                let pend = json.slice(start + 1, 80).indexOf(`"`);
                if (pend === -1)
                    return null;
                let end = start + 1 + pend;
                return json.slice(start + 1, end);
            }
            function matchEventId(json, id) {
                return id === getHex64(json, "id");
            }
            function matchEventPubkey(json, pubkey) {
                return pubkey === getHex64(json, "pubkey");
            }
            function matchEventKind(json, kind) {
                return kind === getInt(json, "kind");
            }

            // nip42.ts
            var nip42_exports = {};
            __export(nip42_exports, {
                makeAuthEvent: () => makeAuthEvent
            });
            function makeAuthEvent(relayURL, challenge2) {
                return {
                    kind: ClientAuth,
                    created_at: Math.floor(Date.now() / 1e3),
                    tags: [
                        ["relay", relayURL],
                        ["challenge", challenge2]
                    ],
                    content: ""
                };
            }

            // helpers.ts
            async function yieldThread() {
                return new Promise((resolve) => {
                    const ch = new MessageChannel();
                    const handler = () => {
                        ch.port1.removeEventListener("message", handler);
                        resolve();
                    };
                    ch.port1.addEventListener("message", handler);
                    ch.port2.postMessage(0);
                    ch.port1.start();
                });
            }
            var alwaysTrue = (t) => {
                t[verifiedSymbol] = true;
                return true;
            };

            // abstract-relay.ts
            var AbstractRelay = class {
                url;
                _connected = false;
                onclose = null;
                onnotice = (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`);
                _onauth = null;
                baseEoseTimeout = 4400;
                connectionTimeout = 4400;
                openSubs = /* @__PURE__ */ new Map();
                connectionTimeoutHandle;
                connectionPromise;
                openCountRequests = /* @__PURE__ */ new Map();
                openEventPublishes = /* @__PURE__ */ new Map();
                ws;
                incomingMessageQueue = new Queue();
                queueRunning = false;
                challenge;
                serial = 0;
                verifyEvent;
                _WebSocket;
                constructor(url, opts) {
                    this.url = normalizeURL(url);
                    this.verifyEvent = opts.verifyEvent;
                    this._WebSocket = opts.websocketImplementation || WebSocket;
                }
                static async connect(url, opts) {
                    const relay = new AbstractRelay(url, opts);
                    await relay.connect();
                    return relay;
                }
                closeAllSubscriptions(reason) {
                    for (let [_, sub] of this.openSubs) {
                        sub.close(reason);
                    }
                    this.openSubs.clear();
                    for (let [_, ep] of this.openEventPublishes) {
                        ep.reject(new Error(reason));
                    }
                    this.openEventPublishes.clear();
                    for (let [_, cr] of this.openCountRequests) {
                        cr.reject(new Error(reason));
                    }
                    this.openCountRequests.clear();
                }
                get connected() {
                    return this._connected;
                }
                async connect() {
                    if (this.connectionPromise)
                        return this.connectionPromise;
                    this.challenge = void 0;
                    this.connectionPromise = new Promise((resolve, reject) => {
                        this.connectionTimeoutHandle = setTimeout(() => {
                            reject("connection timed out");
                            this.connectionPromise = void 0;
                            this.onclose?.();
                            this.closeAllSubscriptions("relay connection timed out");
                        }, this.connectionTimeout);
                        try {
                            this.ws = new this._WebSocket(this.url);
                        } catch (err) {
                            reject(err);
                            return;
                        }
                        this.ws.onopen = () => {
                            clearTimeout(this.connectionTimeoutHandle);
                            this._connected = true;
                            resolve();
                        };
                        this.ws.onerror = (ev) => {
                            reject(ev.message || "websocket error");
                            if (this._connected) {
                                this._connected = false;
                                this.connectionPromise = void 0;
                                this.onclose?.();
                                this.closeAllSubscriptions("relay connection errored");
                            }
                        };
                        this.ws.onclose = async () => {
                            if (this._connected) {
                                this._connected = false;
                                this.connectionPromise = void 0;
                                this.onclose?.();
                                this.closeAllSubscriptions("relay connection closed");
                            }
                        };
                        this.ws.onmessage = this._onmessage.bind(this);
                    });
                    return this.connectionPromise;
                }
                async runQueue() {
                    this.queueRunning = true;
                    while (true) {
                        if (false === this.handleNext()) {
                            break;
                        }
                        await yieldThread();
                    }
                    this.queueRunning = false;
                }
                handleNext() {
                    const json = this.incomingMessageQueue.dequeue();
                    if (!json) {
                        return false;
                    }
                    const subid = getSubscriptionId(json);
                    if (subid) {
                        const so = this.openSubs.get(subid);
                        if (!so) {
                            return;
                        }
                        const id = getHex64(json, "id");
                        const alreadyHave = so.alreadyHaveEvent?.(id);
                        so.receivedEvent?.(this, id);
                        if (alreadyHave) {
                            return;
                        }
                    }
                    try {
                        let data = JSON.parse(json);
                        switch (data[0]) {
                            case "EVENT": {
                                const so = this.openSubs.get(data[1]);
                                const event = data[2];
                                if (this.verifyEvent(event) && matchFilters(so.filters, event)) {
                                    so.onevent(event);
                                }
                                return;
                            }
                            case "COUNT": {
                                const id = data[1];
                                const payload = data[2];
                                const cr = this.openCountRequests.get(id);
                                if (cr) {
                                    cr.resolve(payload.count);
                                    this.openCountRequests.delete(id);
                                }
                                return;
                            }
                            case "EOSE": {
                                const so = this.openSubs.get(data[1]);
                                if (!so)
                                    return;
                                so.receivedEose();
                                return;
                            }
                            case "OK": {
                                const id = data[1];
                                const ok = data[2];
                                const reason = data[3];
                                const ep = this.openEventPublishes.get(id);
                                if (ok)
                                    ep.resolve(reason);
                                else
                                    ep.reject(new Error(reason));
                                this.openEventPublishes.delete(id);
                                return;
                            }
                            case "CLOSED": {
                                const id = data[1];
                                const so = this.openSubs.get(id);
                                if (!so)
                                    return;
                                so.closed = true;
                                so.close(data[2]);
                                return;
                            }
                            case "NOTICE":
                                this.onnotice(data[1]);
                                return;
                            case "AUTH": {
                                this.challenge = data[1];
                                this._onauth?.(data[1]);
                                return;
                            }
                        }
                    } catch (err) {
                        return;
                    }
                }
                async send(message) {
                    if (!this.connectionPromise)
                        throw new Error("sending on closed connection");
                    this.connectionPromise.then(() => {
                        this.ws?.send(message);
                    });
                }
                async auth(signAuthEvent) {
                    if (!this.challenge)
                        throw new Error("can't perform auth, no challenge was received");
                    const evt = await signAuthEvent(makeAuthEvent(this.url, this.challenge));
                    const ret = new Promise((resolve, reject) => {
                        this.openEventPublishes.set(evt.id, { resolve, reject });
                    });
                    this.send('["AUTH",' + JSON.stringify(evt) + "]");
                    return ret;
                }
                async publish(event) {
                    const ret = new Promise((resolve, reject) => {
                        this.openEventPublishes.set(event.id, { resolve, reject });
                    });
                    this.send('["EVENT",' + JSON.stringify(event) + "]");
                    return ret;
                }
                async count(filters, params) {
                    this.serial++;
                    const id = params?.id || "count:" + this.serial;
                    const ret = new Promise((resolve, reject) => {
                        this.openCountRequests.set(id, { resolve, reject });
                    });
                    this.send('["COUNT","' + id + '",' + JSON.stringify(filters).substring(1));
                    return ret;
                }
                subscribe(filters, params) {
                    const subscription = this.prepareSubscription(filters, params);
                    subscription.fire();
                    return subscription;
                }
                prepareSubscription(filters, params) {
                    this.serial++;
                    const id = params.id || "sub:" + this.serial;
                    const subscription = new Subscription(this, id, filters, params);
                    this.openSubs.set(id, subscription);
                    return subscription;
                }
                close() {
                    this.closeAllSubscriptions("relay connection closed by us");
                    this._connected = false;
                    this.ws?.close();
                }
                _onmessage(ev) {
                    this.incomingMessageQueue.enqueue(ev.data);
                    if (!this.queueRunning) {
                        this.runQueue();
                    }
                }
            };
            var Subscription = class {
                relay;
                id;
                closed = false;
                eosed = false;
                filters;
                alreadyHaveEvent;
                receivedEvent;
                onevent;
                oneose;
                onclose;
                eoseTimeout;
                eoseTimeoutHandle;
                constructor(relay, id, filters, params) {
                    this.relay = relay;
                    this.filters = filters;
                    this.id = id;
                    this.alreadyHaveEvent = params.alreadyHaveEvent;
                    this.receivedEvent = params.receivedEvent;
                    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;
                    this.oneose = params.oneose;
                    this.onclose = params.onclose;
                    this.onevent = params.onevent || ((event) => {
                        console.warn(
                            `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,
                            event
                        );
                    });
                }
                fire() {
                    this.relay.send('["REQ","' + this.id + '",' + JSON.stringify(this.filters).substring(1));
                    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);
                }
                receivedEose() {
                    if (this.eosed)
                        return;
                    clearTimeout(this.eoseTimeoutHandle);
                    this.eosed = true;
                    this.oneose?.();
                }
                close(reason = "closed by caller") {
                    if (!this.closed && this.relay.connected) {
                        this.relay.send('["CLOSE",' + JSON.stringify(this.id) + "]");
                        this.closed = true;
                    }
                    this.relay.openSubs.delete(this.id);
                    this.onclose?.(reason);
                }
            };

            // relay.ts
            var _WebSocket;
            try {
                _WebSocket = WebSocket;
            } catch {
            }
            var Relay = class extends AbstractRelay {
                constructor(url) {
                    super(url, { verifyEvent, websocketImplementation: _WebSocket });
                }
                static async connect(url) {
                    const relay = new Relay(url);
                    await relay.connect();
                    return relay;
                }
            };

            // abstract-pool.ts
            var AbstractSimplePool = class {
                relays = /* @__PURE__ */ new Map();
                seenOn = /* @__PURE__ */ new Map();
                trackRelays = false;
                verifyEvent;
                trustedRelayURLs = /* @__PURE__ */ new Set();
                _WebSocket;
                constructor(opts) {
                    this.verifyEvent = opts.verifyEvent;
                    this._WebSocket = opts.websocketImplementation;
                }
                async ensureRelay(url, params) {
                    url = normalizeURL(url);
                    let relay = this.relays.get(url);
                    if (!relay) {
                        relay = new AbstractRelay(url, {
                            verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent,
                            websocketImplementation: this._WebSocket
                        });
                        if (params?.connectionTimeout)
                            relay.connectionTimeout = params.connectionTimeout;
                        this.relays.set(url, relay);
                    }
                    await relay.connect();
                    return relay;
                }
                close(relays) {
                    relays.map(normalizeURL).forEach((url) => {
                        this.relays.get(url)?.close();
                    });
                }
                subscribeMany(relays, filters, params) {
                    return this.subscribeManyMap(Object.fromEntries(relays.map((url) => [url, filters])), params);
                }
                subscribeManyMap(requests, params) {
                    if (this.trackRelays) {
                        params.receivedEvent = (relay, id) => {
                            let set = this.seenOn.get(id);
                            if (!set) {
                                set = /* @__PURE__ */ new Set();
                                this.seenOn.set(id, set);
                            }
                            set.add(relay);
                        };
                    }
                    const _knownIds = /* @__PURE__ */ new Set();
                    const subs = [];
                    const relaysLength = Object.keys(requests).length;
                    const eosesReceived = [];
                    let handleEose = (i2) => {
                        eosesReceived[i2] = true;
                        if (eosesReceived.filter((a) => a).length === relaysLength) {
                            params.oneose?.();
                            handleEose = () => {
                            };
                        }
                    };
                    const closesReceived = [];
                    let handleClose = (i2, reason) => {
                        handleEose(i2);
                        closesReceived[i2] = reason;
                        if (closesReceived.filter((a) => a).length === relaysLength) {
                            params.onclose?.(closesReceived);
                            handleClose = () => {
                            };
                        }
                    };
                    const localAlreadyHaveEventHandler = (id) => {
                        if (params.alreadyHaveEvent?.(id)) {
                            return true;
                        }
                        const have = _knownIds.has(id);
                        _knownIds.add(id);
                        return have;
                    };
                    const allOpened = Promise.all(
                        Object.entries(requests).map(async (req, i2, arr) => {
                            if (arr.indexOf(req) !== i2) {
                                handleClose(i2, "duplicate url");
                                return;
                            }
                            let [url, filters] = req;
                            url = normalizeURL(url);
                            let relay;
                            try {
                                relay = await this.ensureRelay(url, {
                                    connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0
                                });
                            } catch (err) {
                                handleClose(i2, err?.message || String(err));
                                return;
                            }
                            let subscription = relay.subscribe(filters, {
                                ...params,
                                oneose: () => handleEose(i2),
                                onclose: (reason) => handleClose(i2, reason),
                                alreadyHaveEvent: localAlreadyHaveEventHandler,
                                eoseTimeout: params.maxWait
                            });
                            subs.push(subscription);
                        })
                    );
                    return {
                        async close() {
                            await allOpened;
                            subs.forEach((sub) => {
                                sub.close();
                            });
                        }
                    };
                }
                subscribeManyEose(relays, filters, params) {
                    const subcloser = this.subscribeMany(relays, filters, {
                        ...params,
                        oneose() {
                            subcloser.close();
                        }
                    });
                    return subcloser;
                }
                async querySync(relays, filter, params) {
                    return new Promise(async (resolve) => {
                        const events = [];
                        this.subscribeManyEose(relays, [filter], {
                            ...params,
                            onevent(event) {
                                events.push(event);
                            },
                            onclose(_) {
                                resolve(events);
                            }
                        });
                    });
                }
                async get(relays, filter, params) {
                    filter.limit = 1;
                    const events = await this.querySync(relays, filter, params);
                    events.sort((a, b) => b.created_at - a.created_at);
                    return events[0] || null;
                }
                publish(relays, event) {
                    return relays.map(normalizeURL).map(async (url, i2, arr) => {
                        if (arr.indexOf(url) !== i2) {
                            return Promise.reject("duplicate url");
                        }
                        let r = await this.ensureRelay(url);
                        return r.publish(event);
                    });
                }
                listConnectionStatus() {
                    const map = /* @__PURE__ */ new Map();
                    this.relays.forEach((relay, url) => map.set(url, relay.connected));
                    return map;
                }
                destroy() {
                    this.relays.forEach((conn) => conn.close());
                    this.relays = /* @__PURE__ */ new Map();
                }
            };

            // pool.ts
            var _WebSocket2;
            try {
                _WebSocket2 = WebSocket;
            } catch {
            }
            var SimplePool = class extends AbstractSimplePool {
                constructor() {
                    super({ verifyEvent, websocketImplementation: _WebSocket2 });
                }
            };

            // nip19.ts
            var nip19_exports = {};
            __export(nip19_exports, {
                BECH32_REGEX: () => BECH32_REGEX,
                Bech32MaxSize: () => Bech32MaxSize,
                decode: () => decode,
                encodeBytes: () => encodeBytes,
                naddrEncode: () => naddrEncode,
                neventEncode: () => neventEncode,
                noteEncode: () => noteEncode,
                nprofileEncode: () => nprofileEncode,
                npubEncode: () => npubEncode,
                nrelayEncode: () => nrelayEncode,
                nsecEncode: () => nsecEncode
            });

            // node_modules/@scure/base/lib/esm/index.js
            function assertNumber(n) {
                if (!Number.isSafeInteger(n))
                    throw new Error(`Wrong integer: ${n}`);
            }
            function chain(...args) {
                const wrap = (a, b) => (c) => a(b(c));
                const encode = Array.from(args).reverse().reduce((acc, i2) => acc ? wrap(acc, i2.encode) : i2.encode, void 0);
                const decode2 = args.reduce((acc, i2) => acc ? wrap(acc, i2.decode) : i2.decode, void 0);
                return { encode, decode: decode2 };
            }
            function alphabet(alphabet2) {
                return {
                    encode: (digits) => {
                        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
                            throw new Error("alphabet.encode input should be an array of numbers");
                        return digits.map((i2) => {
                            assertNumber(i2);
                            if (i2 < 0 || i2 >= alphabet2.length)
                                throw new Error(`Digit index outside alphabet: ${i2} (alphabet: ${alphabet2.length})`);
                            return alphabet2[i2];
                        });
                    },
                    decode: (input) => {
                        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
                            throw new Error("alphabet.decode input should be array of strings");
                        return input.map((letter) => {
                            if (typeof letter !== "string")
                                throw new Error(`alphabet.decode: not string element=${letter}`);
                            const index = alphabet2.indexOf(letter);
                            if (index === -1)
                                throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
                            return index;
                        });
                    }
                };
            }
            function join(separator = "") {
                if (typeof separator !== "string")
                    throw new Error("join separator should be string");
                return {
                    encode: (from) => {
                        if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
                            throw new Error("join.encode input should be array of strings");
                        for (let i2 of from)
                            if (typeof i2 !== "string")
                                throw new Error(`join.encode: non-string input=${i2}`);
                        return from.join(separator);
                    },
                    decode: (to) => {
                        if (typeof to !== "string")
                            throw new Error("join.decode input should be string");
                        return to.split(separator);
                    }
                };
            }
            function padding(bits, chr = "=") {
                assertNumber(bits);
                if (typeof chr !== "string")
                    throw new Error("padding chr should be string");
                return {
                    encode(data) {
                        if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
                            throw new Error("padding.encode input should be array of strings");
                        for (let i2 of data)
                            if (typeof i2 !== "string")
                                throw new Error(`padding.encode: non-string input=${i2}`);
                        while (data.length * bits % 8)
                            data.push(chr);
                        return data;
                    },
                    decode(input) {
                        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
                            throw new Error("padding.encode input should be array of strings");
                        for (let i2 of input)
                            if (typeof i2 !== "string")
                                throw new Error(`padding.decode: non-string input=${i2}`);
                        let end = input.length;
                        if (end * bits % 8)
                            throw new Error("Invalid padding: string should have whole number of bytes");
                        for (; end > 0 && input[end - 1] === chr; end--) {
                            if (!((end - 1) * bits % 8))
                                throw new Error("Invalid padding: string has too much padding");
                        }
                        return input.slice(0, end);
                    }
                };
            }
            function normalize(fn) {
                if (typeof fn !== "function")
                    throw new Error("normalize fn should be function");
                return { encode: (from) => from, decode: (to) => fn(to) };
            }
            function convertRadix(data, from, to) {
                if (from < 2)
                    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
                if (to < 2)
                    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
                if (!Array.isArray(data))
                    throw new Error("convertRadix: data should be array");
                if (!data.length)
                    return [];
                let pos = 0;
                const res = [];
                const digits = Array.from(data);
                digits.forEach((d) => {
                    assertNumber(d);
                    if (d < 0 || d >= from)
                        throw new Error(`Wrong integer: ${d}`);
                });
                while (true) {
                    let carry = 0;
                    let done = true;
                    for (let i2 = pos; i2 < digits.length; i2++) {
                        const digit = digits[i2];
                        const digitBase = from * carry + digit;
                        if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
                            throw new Error("convertRadix: carry overflow");
                        }
                        carry = digitBase % to;
                        digits[i2] = Math.floor(digitBase / to);
                        if (!Number.isSafeInteger(digits[i2]) || digits[i2] * to + carry !== digitBase)
                            throw new Error("convertRadix: carry overflow");
                        if (!done)
                            continue;
                        else if (!digits[i2])
                            pos = i2;
                        else
                            done = false;
                    }
                    res.push(carry);
                    if (done)
                        break;
                }
                for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
                    res.push(0);
                return res.reverse();
            }
            var gcd = (a, b) => !b ? a : gcd(b, a % b);
            var radix2carry = (from, to) => from + (to - gcd(from, to));
            function convertRadix2(data, from, to, padding2) {
                if (!Array.isArray(data))
                    throw new Error("convertRadix2: data should be array");
                if (from <= 0 || from > 32)
                    throw new Error(`convertRadix2: wrong from=${from}`);
                if (to <= 0 || to > 32)
                    throw new Error(`convertRadix2: wrong to=${to}`);
                if (radix2carry(from, to) > 32) {
                    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
                }
                let carry = 0;
                let pos = 0;
                const mask = 2 ** to - 1;
                const res = [];
                for (const n of data) {
                    assertNumber(n);
                    if (n >= 2 ** from)
                        throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
                    carry = carry << from | n;
                    if (pos + from > 32)
                        throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
                    pos += from;
                    for (; pos >= to; pos -= to)
                        res.push((carry >> pos - to & mask) >>> 0);
                    carry &= 2 ** pos - 1;
                }
                carry = carry << to - pos & mask;
                if (!padding2 && pos >= from)
                    throw new Error("Excess padding");
                if (!padding2 && carry)
                    throw new Error(`Non-zero padding: ${carry}`);
                if (padding2 && pos > 0)
                    res.push(carry >>> 0);
                return res;
            }
            function radix(num) {
                assertNumber(num);
                return {
                    encode: (bytes4) => {
                        if (!(bytes4 instanceof Uint8Array))
                            throw new Error("radix.encode input should be Uint8Array");
                        return convertRadix(Array.from(bytes4), 2 ** 8, num);
                    },
                    decode: (digits) => {
                        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
                            throw new Error("radix.decode input should be array of strings");
                        return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
                    }
                };
            }
            function radix2(bits, revPadding = false) {
                assertNumber(bits);
                if (bits <= 0 || bits > 32)
                    throw new Error("radix2: bits should be in (0..32]");
                if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
                    throw new Error("radix2: carry overflow");
                return {
                    encode: (bytes4) => {
                        if (!(bytes4 instanceof Uint8Array))
                            throw new Error("radix2.encode input should be Uint8Array");
                        return convertRadix2(Array.from(bytes4), 8, bits, !revPadding);
                    },
                    decode: (digits) => {
                        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
                            throw new Error("radix2.decode input should be array of strings");
                        return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
                    }
                };
            }
            function unsafeWrapper(fn) {
                if (typeof fn !== "function")
                    throw new Error("unsafeWrapper fn should be function");
                return function (...args) {
                    try {
                        return fn.apply(null, args);
                    } catch (e) {
                    }
                };
            }
            var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
            var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
            var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
            var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
            var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
            var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
            var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
            var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
            var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
            var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
            var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
            var base58xmr = {
                encode(data) {
                    let res = "";
                    for (let i2 = 0; i2 < data.length; i2 += 8) {
                        const block = data.subarray(i2, i2 + 8);
                        res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
                    }
                    return res;
                },
                decode(str) {
                    let res = [];
                    for (let i2 = 0; i2 < str.length; i2 += 11) {
                        const slice = str.slice(i2, i2 + 11);
                        const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
                        const block = base58.decode(slice);
                        for (let j = 0; j < block.length - blockLen; j++) {
                            if (block[j] !== 0)
                                throw new Error("base58xmr: wrong padding");
                        }
                        res = res.concat(Array.from(block.slice(block.length - blockLen)));
                    }
                    return Uint8Array.from(res);
                }
            };
            var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
            var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
            function bech32Polymod(pre) {
                const b = pre >> 25;
                let chk = (pre & 33554431) << 5;
                for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
                    if ((b >> i2 & 1) === 1)
                        chk ^= POLYMOD_GENERATORS[i2];
                }
                return chk;
            }
            function bechChecksum(prefix, words, encodingConst = 1) {
                const len = prefix.length;
                let chk = 1;
                for (let i2 = 0; i2 < len; i2++) {
                    const c = prefix.charCodeAt(i2);
                    if (c < 33 || c > 126)
                        throw new Error(`Invalid prefix (${prefix})`);
                    chk = bech32Polymod(chk) ^ c >> 5;
                }
                chk = bech32Polymod(chk);
                for (let i2 = 0; i2 < len; i2++)
                    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
                for (let v of words)
                    chk = bech32Polymod(chk) ^ v;
                for (let i2 = 0; i2 < 6; i2++)
                    chk = bech32Polymod(chk);
                chk ^= encodingConst;
                return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
            }
            function genBech32(encoding) {
                const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
                const _words = radix2(5);
                const fromWords = _words.decode;
                const toWords = _words.encode;
                const fromWordsUnsafe = unsafeWrapper(fromWords);
                function encode(prefix, words, limit2 = 90) {
                    if (typeof prefix !== "string")
                        throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
                    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
                        throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
                    const actualLength = prefix.length + 7 + words.length;
                    if (limit2 !== false && actualLength > limit2)
                        throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
                    prefix = prefix.toLowerCase();
                    return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
                }
                function decode2(str, limit2 = 90) {
                    if (typeof str !== "string")
                        throw new Error(`bech32.decode input should be string, not ${typeof str}`);
                    if (str.length < 8 || limit2 !== false && str.length > limit2)
                        throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit2})`);
                    const lowered = str.toLowerCase();
                    if (str !== lowered && str !== str.toUpperCase())
                        throw new Error(`String must be lowercase or uppercase`);
                    str = lowered;
                    const sepIndex = str.lastIndexOf("1");
                    if (sepIndex === 0 || sepIndex === -1)
                        throw new Error(`Letter "1" must be present between prefix and data only`);
                    const prefix = str.slice(0, sepIndex);
                    const _words2 = str.slice(sepIndex + 1);
                    if (_words2.length < 6)
                        throw new Error("Data must be at least 6 characters long");
                    const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
                    const sum = bechChecksum(prefix, words, ENCODING_CONST);
                    if (!_words2.endsWith(sum))
                        throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
                    return { prefix, words };
                }
                const decodeUnsafe = unsafeWrapper(decode2);
                function decodeToBytes(str) {
                    const { prefix, words } = decode2(str, false);
                    return { prefix, words, bytes: fromWords(words) };
                }
                return { encode, decode: decode2, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
            }
            var bech32 = genBech32("bech32");
            var bech32m = genBech32("bech32m");
            var utf8 = {
                encode: (data) => new TextDecoder().decode(data),
                decode: (str) => new TextEncoder().encode(str)
            };
            var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
                if (typeof s !== "string" || s.length % 2)
                    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
                return s.toLowerCase();
            }));
            var CODERS = {
                utf8,
                hex,
                base16,
                base32,
                base64,
                base64url,
                base58,
                base58xmr
            };
            var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;

            // nip19.ts
            var Bech32MaxSize = 5e3;
            var BECH32_REGEX = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
            function integerToUint8Array(number4) {
                const uint8Array = new Uint8Array(4);
                uint8Array[0] = number4 >> 24 & 255;
                uint8Array[1] = number4 >> 16 & 255;
                uint8Array[2] = number4 >> 8 & 255;
                uint8Array[3] = number4 & 255;
                return uint8Array;
            }
            function decode(nip19) {
                let { prefix, words } = bech32.decode(nip19, Bech32MaxSize);
                let data = new Uint8Array(bech32.fromWords(words));
                switch (prefix) {
                    case "nprofile": {
                        let tlv = parseTLV(data);
                        if (!tlv[0]?.[0])
                            throw new Error("missing TLV 0 for nprofile");
                        if (tlv[0][0].length !== 32)
                            throw new Error("TLV 0 should be 32 bytes");
                        return {
                            type: "nprofile",
                            data: {
                                pubkey: bytesToHex2(tlv[0][0]),
                                relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
                            }
                        };
                    }
                    case "nevent": {
                        let tlv = parseTLV(data);
                        if (!tlv[0]?.[0])
                            throw new Error("missing TLV 0 for nevent");
                        if (tlv[0][0].length !== 32)
                            throw new Error("TLV 0 should be 32 bytes");
                        if (tlv[2] && tlv[2][0].length !== 32)
                            throw new Error("TLV 2 should be 32 bytes");
                        if (tlv[3] && tlv[3][0].length !== 4)
                            throw new Error("TLV 3 should be 4 bytes");
                        return {
                            type: "nevent",
                            data: {
                                id: bytesToHex2(tlv[0][0]),
                                relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
                                author: tlv[2]?.[0] ? bytesToHex2(tlv[2][0]) : void 0,
                                kind: tlv[3]?.[0] ? parseInt(bytesToHex2(tlv[3][0]), 16) : void 0
                            }
                        };
                    }
                    case "naddr": {
                        let tlv = parseTLV(data);
                        if (!tlv[0]?.[0])
                            throw new Error("missing TLV 0 for naddr");
                        if (!tlv[2]?.[0])
                            throw new Error("missing TLV 2 for naddr");
                        if (tlv[2][0].length !== 32)
                            throw new Error("TLV 2 should be 32 bytes");
                        if (!tlv[3]?.[0])
                            throw new Error("missing TLV 3 for naddr");
                        if (tlv[3][0].length !== 4)
                            throw new Error("TLV 3 should be 4 bytes");
                        return {
                            type: "naddr",
                            data: {
                                identifier: utf8Decoder.decode(tlv[0][0]),
                                pubkey: bytesToHex2(tlv[2][0]),
                                kind: parseInt(bytesToHex2(tlv[3][0]), 16),
                                relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
                            }
                        };
                    }
                    case "nrelay": {
                        let tlv = parseTLV(data);
                        if (!tlv[0]?.[0])
                            throw new Error("missing TLV 0 for nrelay");
                        return {
                            type: "nrelay",
                            data: utf8Decoder.decode(tlv[0][0])
                        };
                    }
                    case "nsec":
                        return { type: prefix, data };
                    case "npub":
                    case "note":
                        return { type: prefix, data: bytesToHex2(data) };
                    default:
                        throw new Error(`unknown prefix ${prefix}`);
                }
            }
            function parseTLV(data) {
                let result = {};
                let rest = data;
                while (rest.length > 0) {
                    let t = rest[0];
                    let l = rest[1];
                    let v = rest.slice(2, 2 + l);
                    rest = rest.slice(2 + l);
                    if (v.length < l)
                        throw new Error(`not enough data to read on TLV ${t}`);
                    result[t] = result[t] || [];
                    result[t].push(v);
                }
                return result;
            }
            function nsecEncode(key) {
                return encodeBytes("nsec", key);
            }
            function npubEncode(hex2) {
                return encodeBytes("npub", hexToBytes2(hex2));
            }
            function noteEncode(hex2) {
                return encodeBytes("note", hexToBytes2(hex2));
            }
            function encodeBech32(prefix, data) {
                let words = bech32.toWords(data);
                return bech32.encode(prefix, words, Bech32MaxSize);
            }
            function encodeBytes(prefix, bytes4) {
                return encodeBech32(prefix, bytes4);
            }
            function nprofileEncode(profile) {
                let data = encodeTLV({
                    0: [hexToBytes2(profile.pubkey)],
                    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))
                });
                return encodeBech32("nprofile", data);
            }
            function neventEncode(event) {
                let kindArray;
                if (event.kind !== void 0) {
                    kindArray = integerToUint8Array(event.kind);
                }
                let data = encodeTLV({
                    0: [hexToBytes2(event.id)],
                    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),
                    2: event.author ? [hexToBytes2(event.author)] : [],
                    3: kindArray ? [new Uint8Array(kindArray)] : []
                });
                return encodeBech32("nevent", data);
            }
            function naddrEncode(addr) {
                let kind = new ArrayBuffer(4);
                new DataView(kind).setUint32(0, addr.kind, false);
                let data = encodeTLV({
                    0: [utf8Encoder.encode(addr.identifier)],
                    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),
                    2: [hexToBytes2(addr.pubkey)],
                    3: [new Uint8Array(kind)]
                });
                return encodeBech32("naddr", data);
            }
            function nrelayEncode(url) {
                let data = encodeTLV({
                    0: [utf8Encoder.encode(url)]
                });
                return encodeBech32("nrelay", data);
            }
            function encodeTLV(tlv) {
                let entries = [];
                Object.entries(tlv).reverse().forEach(([t, vs]) => {
                    vs.forEach((v) => {
                        let entry = new Uint8Array(v.length + 2);
                        entry.set([parseInt(t)], 0);
                        entry.set([v.length], 1);
                        entry.set(v, 2);
                        entries.push(entry);
                    });
                });
                return concatBytes3(...entries);
            }

            // references.ts
            var mentionRegex = /\bnostr:((note|npub|naddr|nevent|nprofile)1\w+)\b|#\[(\d+)\]/g;
            function parseReferences(evt) {
                let references = [];
                for (let ref of evt.content.matchAll(mentionRegex)) {
                    if (ref[2]) {
                        try {
                            let { type, data } = decode(ref[1]);
                            switch (type) {
                                case "npub": {
                                    references.push({
                                        text: ref[0],
                                        profile: { pubkey: data, relays: [] }
                                    });
                                    break;
                                }
                                case "nprofile": {
                                    references.push({
                                        text: ref[0],
                                        profile: data
                                    });
                                    break;
                                }
                                case "note": {
                                    references.push({
                                        text: ref[0],
                                        event: { id: data, relays: [] }
                                    });
                                    break;
                                }
                                case "nevent": {
                                    references.push({
                                        text: ref[0],
                                        event: data
                                    });
                                    break;
                                }
                                case "naddr": {
                                    references.push({
                                        text: ref[0],
                                        address: data
                                    });
                                    break;
                                }
                            }
                        } catch (err) {
                        }
                    } else if (ref[3]) {
                        let idx = parseInt(ref[3], 10);
                        let tag = evt.tags[idx];
                        if (!tag)
                            continue;
                        switch (tag[0]) {
                            case "p": {
                                references.push({
                                    text: ref[0],
                                    profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }
                                });
                                break;
                            }
                            case "e": {
                                references.push({
                                    text: ref[0],
                                    event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }
                                });
                                break;
                            }
                            case "a": {
                                try {
                                    let [kind, pubkey, identifier] = tag[1].split(":");
                                    references.push({
                                        text: ref[0],
                                        address: {
                                            identifier,
                                            pubkey,
                                            kind: parseInt(kind, 10),
                                            relays: tag[2] ? [tag[2]] : []
                                        }
                                    });
                                } catch (err) {
                                }
                                break;
                            }
                        }
                    }
                }
                return references;
            }

            // nip04.ts
            var nip04_exports = {};
            __export(nip04_exports, {
                decrypt: () => decrypt2,
                encrypt: () => encrypt2
            });

            // node_modules/@noble/ciphers/esm/_assert.js
            function number3(n) {
                if (!Number.isSafeInteger(n) || n < 0)
                    throw new Error(`positive integer expected, not ${n}`);
            }
            function bool2(b) {
                if (typeof b !== "boolean")
                    throw new Error(`boolean expected, not ${b}`);
            }
            function isBytes(a) {
                return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
            }
            function bytes3(b, ...lengths) {
                if (!isBytes(b))
                    throw new Error("Uint8Array expected");
                if (lengths.length > 0 && !lengths.includes(b.length))
                    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
            }
            function exists3(instance, checkFinished = true) {
                if (instance.destroyed)
                    throw new Error("Hash instance has been destroyed");
                if (checkFinished && instance.finished)
                    throw new Error("Hash#digest() has already been called");
            }
            function output3(out, instance) {
                bytes3(out);
                const min = instance.outputLen;
                if (out.length < min) {
                    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
                }
            }

            // node_modules/@noble/ciphers/esm/utils.js
            var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
            var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
            var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
            var isLE3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
            if (!isLE3)
                throw new Error("Non little-endian hardware is not supported");
            function utf8ToBytes4(str) {
                if (typeof str !== "string")
                    throw new Error(`string expected, got ${typeof str}`);
                return new Uint8Array(new TextEncoder().encode(str));
            }
            function toBytes3(data) {
                if (typeof data === "string")
                    data = utf8ToBytes4(data);
                else if (isBytes(data))
                    data = data.slice();
                else
                    throw new Error(`Uint8Array expected, got ${typeof data}`);
                return data;
            }
            function checkOpts(defaults, opts) {
                if (opts == null || typeof opts !== "object")
                    throw new Error("options must be defined");
                const merged = Object.assign(defaults, opts);
                return merged;
            }
            function equalBytes2(a, b) {
                if (a.length !== b.length)
                    return false;
                let diff = 0;
                for (let i2 = 0; i2 < a.length; i2++)
                    diff |= a[i2] ^ b[i2];
                return diff === 0;
            }
            var wrapCipher = (params, c) => {
                Object.assign(c, params);
                return c;
            };
            function setBigUint643(view, byteOffset, value, isLE4) {
                if (typeof view.setBigUint64 === "function")
                    return view.setBigUint64(byteOffset, value, isLE4);
                const _32n = BigInt(32);
                const _u32_max = BigInt(4294967295);
                const wh = Number(value >> _32n & _u32_max);
                const wl = Number(value & _u32_max);
                const h = isLE4 ? 4 : 0;
                const l = isLE4 ? 0 : 4;
                view.setUint32(byteOffset + h, wh, isLE4);
                view.setUint32(byteOffset + l, wl, isLE4);
            }

            // node_modules/@noble/ciphers/esm/_polyval.js
            var BLOCK_SIZE = 16;
            var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
            var ZEROS32 = u32(ZEROS16);
            var POLY = 225;
            var mul2 = (s0, s1, s2, s3) => {
                const hiBit = s3 & 1;
                return {
                    s3: s2 << 31 | s3 >>> 1,
                    s2: s1 << 31 | s2 >>> 1,
                    s1: s0 << 31 | s1 >>> 1,
                    s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
                };
            };
            var swapLE = (n) => (n >>> 0 & 255) << 24 | (n >>> 8 & 255) << 16 | (n >>> 16 & 255) << 8 | n >>> 24 & 255 | 0;
            function _toGHASHKey(k) {
                k.reverse();
                const hiBit = k[15] & 1;
                let carry = 0;
                for (let i2 = 0; i2 < k.length; i2++) {
                    const t = k[i2];
                    k[i2] = t >>> 1 | carry;
                    carry = (t & 1) << 7;
                }
                k[0] ^= -hiBit & 225;
                return k;
            }
            var estimateWindow = (bytes4) => {
                if (bytes4 > 64 * 1024)
                    return 8;
                if (bytes4 > 1024)
                    return 4;
                return 2;
            };
            var GHASH = class {
                constructor(key, expectedLength) {
                    this.blockLen = BLOCK_SIZE;
                    this.outputLen = BLOCK_SIZE;
                    this.s0 = 0;
                    this.s1 = 0;
                    this.s2 = 0;
                    this.s3 = 0;
                    this.finished = false;
                    key = toBytes3(key);
                    bytes3(key, 16);
                    const kView = createView3(key);
                    let k0 = kView.getUint32(0, false);
                    let k1 = kView.getUint32(4, false);
                    let k2 = kView.getUint32(8, false);
                    let k3 = kView.getUint32(12, false);
                    const doubles = [];
                    for (let i2 = 0; i2 < 128; i2++) {
                        doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });
                        ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));
                    }
                    const W = estimateWindow(expectedLength || 1024);
                    if (![1, 2, 4, 8].includes(W))
                        throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);
                    this.W = W;
                    const bits = 128;
                    const windows = bits / W;
                    const windowSize = this.windowSize = 2 ** W;
                    const items = [];
                    for (let w = 0; w < windows; w++) {
                        for (let byte = 0; byte < windowSize; byte++) {
                            let s0 = 0, s1 = 0, s2 = 0, s3 = 0;
                            for (let j = 0; j < W; j++) {
                                const bit = byte >>> W - j - 1 & 1;
                                if (!bit)
                                    continue;
                                const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];
                                s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;
                            }
                            items.push({ s0, s1, s2, s3 });
                        }
                    }
                    this.t = items;
                }
                _updateBlock(s0, s1, s2, s3) {
                    s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;
                    const { W, t, windowSize } = this;
                    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;
                    const mask = (1 << W) - 1;
                    let w = 0;
                    for (const num of [s0, s1, s2, s3]) {
                        for (let bytePos = 0; bytePos < 4; bytePos++) {
                            const byte = num >>> 8 * bytePos & 255;
                            for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {
                                const bit = byte >>> W * bitPos & mask;
                                const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];
                                o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;
                                w += 1;
                            }
                        }
                    }
                    this.s0 = o0;
                    this.s1 = o1;
                    this.s2 = o2;
                    this.s3 = o3;
                }
                update(data) {
                    data = toBytes3(data);
                    exists3(this);
                    const b32 = u32(data);
                    const blocks = Math.floor(data.length / BLOCK_SIZE);
                    const left = data.length % BLOCK_SIZE;
                    for (let i2 = 0; i2 < blocks; i2++) {
                        this._updateBlock(b32[i2 * 4 + 0], b32[i2 * 4 + 1], b32[i2 * 4 + 2], b32[i2 * 4 + 3]);
                    }
                    if (left) {
                        ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
                        this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);
                        ZEROS32.fill(0);
                    }
                    return this;
                }
                destroy() {
                    const { t } = this;
                    for (const elm of t) {
                        elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
                    }
                }
                digestInto(out) {
                    exists3(this);
                    output3(out, this);
                    this.finished = true;
                    const { s0, s1, s2, s3 } = this;
                    const o32 = u32(out);
                    o32[0] = s0;
                    o32[1] = s1;
                    o32[2] = s2;
                    o32[3] = s3;
                    return out;
                }
                digest() {
                    const res = new Uint8Array(BLOCK_SIZE);
                    this.digestInto(res);
                    this.destroy();
                    return res;
                }
            };
            var Polyval = class extends GHASH {
                constructor(key, expectedLength) {
                    key = toBytes3(key);
                    const ghKey = _toGHASHKey(key.slice());
                    super(ghKey, expectedLength);
                    ghKey.fill(0);
                }
                update(data) {
                    data = toBytes3(data);
                    exists3(this);
                    const b32 = u32(data);
                    const left = data.length % BLOCK_SIZE;
                    const blocks = Math.floor(data.length / BLOCK_SIZE);
                    for (let i2 = 0; i2 < blocks; i2++) {
                        this._updateBlock(swapLE(b32[i2 * 4 + 3]), swapLE(b32[i2 * 4 + 2]), swapLE(b32[i2 * 4 + 1]), swapLE(b32[i2 * 4 + 0]));
                    }
                    if (left) {
                        ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
                        this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));
                        ZEROS32.fill(0);
                    }
                    return this;
                }
                digestInto(out) {
                    exists3(this);
                    output3(out, this);
                    this.finished = true;
                    const { s0, s1, s2, s3 } = this;
                    const o32 = u32(out);
                    o32[0] = s0;
                    o32[1] = s1;
                    o32[2] = s2;
                    o32[3] = s3;
                    return out.reverse();
                }
            };
            function wrapConstructorWithKey(hashCons) {
                const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes3(msg)).digest();
                const tmp = hashCons(new Uint8Array(16), 0);
                hashC.outputLen = tmp.outputLen;
                hashC.blockLen = tmp.blockLen;
                hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
                return hashC;
            }
            var ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));
            var polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));

            // node_modules/@noble/ciphers/esm/aes.js
            var BLOCK_SIZE2 = 16;
            var BLOCK_SIZE32 = 4;
            var EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE2);
            var POLY2 = 283;
            function mul22(n) {
                return n << 1 ^ POLY2 & -(n >> 7);
            }
            function mul(a, b) {
                let res = 0;
                for (; b > 0; b >>= 1) {
                    res ^= a & -(b & 1);
                    a = mul22(a);
                }
                return res;
            }
            var sbox = /* @__PURE__ */ (() => {
                let t = new Uint8Array(256);
                for (let i2 = 0, x = 1; i2 < 256; i2++, x ^= mul22(x))
                    t[i2] = x;
                const box = new Uint8Array(256);
                box[0] = 99;
                for (let i2 = 0; i2 < 255; i2++) {
                    let x = t[255 - i2];
                    x |= x << 8;
                    box[t[i2]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
                }
                return box;
            })();
            var invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));
            var rotr32_8 = (n) => n << 24 | n >>> 8;
            var rotl32_8 = (n) => n << 8 | n >>> 24;
            function genTtable(sbox2, fn) {
                if (sbox2.length !== 256)
                    throw new Error("Wrong sbox length");
                const T0 = new Uint32Array(256).map((_, j) => fn(sbox2[j]));
                const T1 = T0.map(rotl32_8);
                const T2 = T1.map(rotl32_8);
                const T3 = T2.map(rotl32_8);
                const T01 = new Uint32Array(256 * 256);
                const T23 = new Uint32Array(256 * 256);
                const sbox22 = new Uint16Array(256 * 256);
                for (let i2 = 0; i2 < 256; i2++) {
                    for (let j = 0; j < 256; j++) {
                        const idx = i2 * 256 + j;
                        T01[idx] = T0[i2] ^ T1[j];
                        T23[idx] = T2[i2] ^ T3[j];
                        sbox22[idx] = sbox2[i2] << 8 | sbox2[j];
                    }
                }
                return { sbox: sbox2, sbox2: sbox22, T0, T1, T2, T3, T01, T23 };
            }
            var tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
            var tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));
            var xPowers = /* @__PURE__ */ (() => {
                const p = new Uint8Array(16);
                for (let i2 = 0, x = 1; i2 < 16; i2++, x = mul22(x))
                    p[i2] = x;
                return p;
            })();
            function expandKeyLE(key) {
                bytes3(key);
                const len = key.length;
                if (![16, 24, 32].includes(len))
                    throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);
                const { sbox2 } = tableEncoding;
                const k32 = u32(key);
                const Nk = k32.length;
                const subByte = (n) => applySbox(sbox2, n, n, n, n);
                const xk = new Uint32Array(len + 28);
                xk.set(k32);
                for (let i2 = Nk; i2 < xk.length; i2++) {
                    let t = xk[i2 - 1];
                    if (i2 % Nk === 0)
                        t = subByte(rotr32_8(t)) ^ xPowers[i2 / Nk - 1];
                    else if (Nk > 6 && i2 % Nk === 4)
                        t = subByte(t);
                    xk[i2] = xk[i2 - Nk] ^ t;
                }
                return xk;
            }
            function expandKeyDecLE(key) {
                const encKey = expandKeyLE(key);
                const xk = encKey.slice();
                const Nk = encKey.length;
                const { sbox2 } = tableEncoding;
                const { T0, T1, T2, T3 } = tableDecoding;
                for (let i2 = 0; i2 < Nk; i2 += 4) {
                    for (let j = 0; j < 4; j++)
                        xk[i2 + j] = encKey[Nk - i2 - 4 + j];
                }
                encKey.fill(0);
                for (let i2 = 4; i2 < Nk - 4; i2++) {
                    const x = xk[i2];
                    const w = applySbox(sbox2, x, x, x, x);
                    xk[i2] = T0[w & 255] ^ T1[w >>> 8 & 255] ^ T2[w >>> 16 & 255] ^ T3[w >>> 24];
                }
                return xk;
            }
            function apply0123(T01, T23, s0, s1, s2, s3) {
                return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
            }
            function applySbox(sbox2, s0, s1, s2, s3) {
                return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
            }
            function encrypt(xk, s0, s1, s2, s3) {
                const { sbox2, T01, T23 } = tableEncoding;
                let k = 0;
                s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
                const rounds = xk.length / 4 - 2;
                for (let i2 = 0; i2 < rounds; i2++) {
                    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
                    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
                    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
                    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
                    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
                }
                const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
                const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
                const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
                const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
                return { s0: t0, s1: t1, s2: t2, s3: t3 };
            }
            function decrypt(xk, s0, s1, s2, s3) {
                const { sbox2, T01, T23 } = tableDecoding;
                let k = 0;
                s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
                const rounds = xk.length / 4 - 2;
                for (let i2 = 0; i2 < rounds; i2++) {
                    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);
                    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);
                    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);
                    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);
                    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
                }
                const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);
                const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);
                const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);
                const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);
                return { s0: t0, s1: t1, s2: t2, s3: t3 };
            }
            function getDst(len, dst) {
                if (!dst)
                    return new Uint8Array(len);
                bytes3(dst);
                if (dst.length < len)
                    throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);
                return dst;
            }
            function ctrCounter(xk, nonce, src, dst) {
                bytes3(nonce, BLOCK_SIZE2);
                bytes3(src);
                const srcLen = src.length;
                dst = getDst(srcLen, dst);
                const ctr3 = nonce;
                const c32 = u32(ctr3);
                let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
                const src32 = u32(src);
                const dst32 = u32(dst);
                for (let i2 = 0; i2 + 4 <= src32.length; i2 += 4) {
                    dst32[i2 + 0] = src32[i2 + 0] ^ s0;
                    dst32[i2 + 1] = src32[i2 + 1] ^ s1;
                    dst32[i2 + 2] = src32[i2 + 2] ^ s2;
                    dst32[i2 + 3] = src32[i2 + 3] ^ s3;
                    let carry = 1;
                    for (let i3 = ctr3.length - 1; i3 >= 0; i3--) {
                        carry = carry + (ctr3[i3] & 255) | 0;
                        ctr3[i3] = carry & 255;
                        carry >>>= 8;
                    }
                    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
                }
                const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
                if (start < srcLen) {
                    const b32 = new Uint32Array([s0, s1, s2, s3]);
                    const buf = u8(b32);
                    for (let i2 = start, pos = 0; i2 < srcLen; i2++, pos++)
                        dst[i2] = src[i2] ^ buf[pos];
                }
                return dst;
            }
            function ctr32(xk, isLE4, nonce, src, dst) {
                bytes3(nonce, BLOCK_SIZE2);
                bytes3(src);
                dst = getDst(src.length, dst);
                const ctr3 = nonce;
                const c32 = u32(ctr3);
                const view = createView3(ctr3);
                const src32 = u32(src);
                const dst32 = u32(dst);
                const ctrPos = isLE4 ? 0 : 12;
                const srcLen = src.length;
                let ctrNum = view.getUint32(ctrPos, isLE4);
                let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
                for (let i2 = 0; i2 + 4 <= src32.length; i2 += 4) {
                    dst32[i2 + 0] = src32[i2 + 0] ^ s0;
                    dst32[i2 + 1] = src32[i2 + 1] ^ s1;
                    dst32[i2 + 2] = src32[i2 + 2] ^ s2;
                    dst32[i2 + 3] = src32[i2 + 3] ^ s3;
                    ctrNum = ctrNum + 1 >>> 0;
                    view.setUint32(ctrPos, ctrNum, isLE4);
                    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
                }
                const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
                if (start < srcLen) {
                    const b32 = new Uint32Array([s0, s1, s2, s3]);
                    const buf = u8(b32);
                    for (let i2 = start, pos = 0; i2 < srcLen; i2++, pos++)
                        dst[i2] = src[i2] ^ buf[pos];
                }
                return dst;
            }
            var ctr = wrapCipher({ blockSize: 16, nonceLength: 16 }, function ctr2(key, nonce) {
                bytes3(key);
                bytes3(nonce, BLOCK_SIZE2);
                function processCtr(buf, dst) {
                    const xk = expandKeyLE(key);
                    const n = nonce.slice();
                    const out = ctrCounter(xk, n, buf, dst);
                    xk.fill(0);
                    n.fill(0);
                    return out;
                }
                return {
                    encrypt: (plaintext, dst) => processCtr(plaintext, dst),
                    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
                };
            });
            function validateBlockDecrypt(data) {
                bytes3(data);
                if (data.length % BLOCK_SIZE2 !== 0) {
                    throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE2}`);
                }
            }
            function validateBlockEncrypt(plaintext, pcks5, dst) {
                let outLen = plaintext.length;
                const remaining = outLen % BLOCK_SIZE2;
                if (!pcks5 && remaining !== 0)
                    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
                const b = u32(plaintext);
                if (pcks5) {
                    let left = BLOCK_SIZE2 - remaining;
                    if (!left)
                        left = BLOCK_SIZE2;
                    outLen = outLen + left;
                }
                const out = getDst(outLen, dst);
                const o = u32(out);
                return { b, o, out };
            }
            function validatePCKS(data, pcks5) {
                if (!pcks5)
                    return data;
                const len = data.length;
                if (!len)
                    throw new Error(`aes/pcks5: empty ciphertext not allowed`);
                const lastByte = data[len - 1];
                if (lastByte <= 0 || lastByte > 16)
                    throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);
                const out = data.subarray(0, -lastByte);
                for (let i2 = 0; i2 < lastByte; i2++)
                    if (data[len - i2 - 1] !== lastByte)
                        throw new Error(`aes/pcks5: wrong padding`);
                return out;
            }
            function padPCKS(left) {
                const tmp = new Uint8Array(16);
                const tmp32 = u32(tmp);
                tmp.set(left);
                const paddingByte = BLOCK_SIZE2 - left.length;
                for (let i2 = BLOCK_SIZE2 - paddingByte; i2 < BLOCK_SIZE2; i2++)
                    tmp[i2] = paddingByte;
                return tmp32;
            }
            var ecb = wrapCipher({ blockSize: 16 }, function ecb2(key, opts = {}) {
                bytes3(key);
                const pcks5 = !opts.disablePadding;
                return {
                    encrypt: (plaintext, dst) => {
                        bytes3(plaintext);
                        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
                        const xk = expandKeyLE(key);
                        let i2 = 0;
                        for (; i2 + 4 <= b.length;) {
                            const { s0, s1, s2, s3 } = encrypt(xk, b[i2 + 0], b[i2 + 1], b[i2 + 2], b[i2 + 3]);
                            o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
                        }
                        if (pcks5) {
                            const tmp32 = padPCKS(plaintext.subarray(i2 * 4));
                            const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);
                            o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
                        }
                        xk.fill(0);
                        return _out;
                    },
                    decrypt: (ciphertext, dst) => {
                        validateBlockDecrypt(ciphertext);
                        const xk = expandKeyDecLE(key);
                        const out = getDst(ciphertext.length, dst);
                        const b = u32(ciphertext);
                        const o = u32(out);
                        for (let i2 = 0; i2 + 4 <= b.length;) {
                            const { s0, s1, s2, s3 } = decrypt(xk, b[i2 + 0], b[i2 + 1], b[i2 + 2], b[i2 + 3]);
                            o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
                        }
                        xk.fill(0);
                        return validatePCKS(out, pcks5);
                    }
                };
            });
            var cbc = wrapCipher({ blockSize: 16, nonceLength: 16 }, function cbc2(key, iv, opts = {}) {
                bytes3(key);
                bytes3(iv, 16);
                const pcks5 = !opts.disablePadding;
                return {
                    encrypt: (plaintext, dst) => {
                        const xk = expandKeyLE(key);
                        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
                        const n32 = u32(iv);
                        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
                        let i2 = 0;
                        for (; i2 + 4 <= b.length;) {
                            s0 ^= b[i2 + 0], s1 ^= b[i2 + 1], s2 ^= b[i2 + 2], s3 ^= b[i2 + 3];
                            ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
                            o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
                        }
                        if (pcks5) {
                            const tmp32 = padPCKS(plaintext.subarray(i2 * 4));
                            s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];
                            ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
                            o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
                        }
                        xk.fill(0);
                        return _out;
                    },
                    decrypt: (ciphertext, dst) => {
                        validateBlockDecrypt(ciphertext);
                        const xk = expandKeyDecLE(key);
                        const n32 = u32(iv);
                        const out = getDst(ciphertext.length, dst);
                        const b = u32(ciphertext);
                        const o = u32(out);
                        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
                        for (let i2 = 0; i2 + 4 <= b.length;) {
                            const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;
                            s0 = b[i2 + 0], s1 = b[i2 + 1], s2 = b[i2 + 2], s3 = b[i2 + 3];
                            const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);
                            o[i2++] = o0 ^ ps0, o[i2++] = o1 ^ ps1, o[i2++] = o2 ^ ps2, o[i2++] = o3 ^ ps3;
                        }
                        xk.fill(0);
                        return validatePCKS(out, pcks5);
                    }
                };
            });
            function computeTag(fn, isLE4, key, data, AAD) {
                const h = fn.create(key, data.length + (AAD?.length || 0));
                if (AAD)
                    h.update(AAD);
                h.update(data);
                const num = new Uint8Array(16);
                const view = createView3(num);
                if (AAD)
                    setBigUint643(view, 0, BigInt(AAD.length * 8), isLE4);
                setBigUint643(view, 8, BigInt(data.length * 8), isLE4);
                h.update(num);
                return h.digest();
            }
            var gcm = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm2(key, nonce, AAD) {
                bytes3(nonce);
                if (nonce.length === 0)
                    throw new Error("aes/gcm: empty nonce");
                const tagLength = 16;
                function _computeTag(authKey, tagMask, data) {
                    const tag = computeTag(ghash, false, authKey, data, AAD);
                    for (let i2 = 0; i2 < tagMask.length; i2++)
                        tag[i2] ^= tagMask[i2];
                    return tag;
                }
                function deriveKeys() {
                    const xk = expandKeyLE(key);
                    const authKey = EMPTY_BLOCK.slice();
                    const counter = EMPTY_BLOCK.slice();
                    ctr32(xk, false, counter, counter, authKey);
                    if (nonce.length === 12) {
                        counter.set(nonce);
                    } else {
                        const nonceLen = EMPTY_BLOCK.slice();
                        const view = createView3(nonceLen);
                        setBigUint643(view, 8, BigInt(nonce.length * 8), false);
                        ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);
                    }
                    const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);
                    return { xk, authKey, counter, tagMask };
                }
                return {
                    encrypt: (plaintext) => {
                        bytes3(plaintext);
                        const { xk, authKey, counter, tagMask } = deriveKeys();
                        const out = new Uint8Array(plaintext.length + tagLength);
                        ctr32(xk, false, counter, plaintext, out);
                        const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
                        out.set(tag, plaintext.length);
                        xk.fill(0);
                        return out;
                    },
                    decrypt: (ciphertext) => {
                        bytes3(ciphertext);
                        if (ciphertext.length < tagLength)
                            throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);
                        const { xk, authKey, counter, tagMask } = deriveKeys();
                        const data = ciphertext.subarray(0, -tagLength);
                        const passedTag = ciphertext.subarray(-tagLength);
                        const tag = _computeTag(authKey, tagMask, data);
                        if (!equalBytes2(tag, passedTag))
                            throw new Error("aes/gcm: invalid ghash tag");
                        const out = ctr32(xk, false, counter, data);
                        authKey.fill(0);
                        tagMask.fill(0);
                        xk.fill(0);
                        return out;
                    }
                };
            });
            var limit = (name, min, max) => (value) => {
                if (!Number.isSafeInteger(value) || min > value || value > max)
                    throw new Error(`${name}: invalid value=${value}, must be [${min}..${max}]`);
            };
            var siv = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv2(key, nonce, AAD) {
                const tagLength = 16;
                const AAD_LIMIT = limit("AAD", 0, 2 ** 36);
                const PLAIN_LIMIT = limit("plaintext", 0, 2 ** 36);
                const NONCE_LIMIT = limit("nonce", 12, 12);
                const CIPHER_LIMIT = limit("ciphertext", 16, 2 ** 36 + 16);
                bytes3(nonce);
                NONCE_LIMIT(nonce.length);
                if (AAD) {
                    bytes3(AAD);
                    AAD_LIMIT(AAD.length);
                }
                function deriveKeys() {
                    const len = key.length;
                    if (len !== 16 && len !== 24 && len !== 32)
                        throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);
                    const xk = expandKeyLE(key);
                    const encKey = new Uint8Array(len);
                    const authKey = new Uint8Array(16);
                    const n32 = u32(nonce);
                    let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];
                    let counter = 0;
                    for (const derivedKey of [authKey, encKey].map(u32)) {
                        const d32 = u32(derivedKey);
                        for (let i2 = 0; i2 < d32.length; i2 += 2) {
                            const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);
                            d32[i2 + 0] = o0;
                            d32[i2 + 1] = o1;
                            s0 = ++counter;
                        }
                    }
                    xk.fill(0);
                    return { authKey, encKey: expandKeyLE(encKey) };
                }
                function _computeTag(encKey, authKey, data) {
                    const tag = computeTag(polyval, true, authKey, data, AAD);
                    for (let i2 = 0; i2 < 12; i2++)
                        tag[i2] ^= nonce[i2];
                    tag[15] &= 127;
                    const t32 = u32(tag);
                    let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];
                    ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));
                    t32[0] = s0, t32[1] = s1, t32[2] = s2, t32[3] = s3;
                    return tag;
                }
                function processSiv(encKey, tag, input) {
                    let block = tag.slice();
                    block[15] |= 128;
                    return ctr32(encKey, true, block, input);
                }
                return {
                    encrypt: (plaintext) => {
                        bytes3(plaintext);
                        PLAIN_LIMIT(plaintext.length);
                        const { encKey, authKey } = deriveKeys();
                        const tag = _computeTag(encKey, authKey, plaintext);
                        const out = new Uint8Array(plaintext.length + tagLength);
                        out.set(tag, plaintext.length);
                        out.set(processSiv(encKey, tag, plaintext));
                        encKey.fill(0);
                        authKey.fill(0);
                        return out;
                    },
                    decrypt: (ciphertext) => {
                        bytes3(ciphertext);
                        CIPHER_LIMIT(ciphertext.length);
                        const tag = ciphertext.subarray(-tagLength);
                        const { encKey, authKey } = deriveKeys();
                        const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));
                        const expectedTag = _computeTag(encKey, authKey, plaintext);
                        encKey.fill(0);
                        authKey.fill(0);
                        if (!equalBytes2(tag, expectedTag))
                            throw new Error("invalid polyval tag");
                        return plaintext;
                    }
                };
            });

            // nip04.ts
            async function encrypt2(secretKey, pubkey, text) {
                const privkey = secretKey instanceof Uint8Array ? bytesToHex2(secretKey) : secretKey;
                const key = secp256k1.getSharedSecret(privkey, "02" + pubkey);
                const normalizedKey = getNormalizedX(key);
                let iv = Uint8Array.from(randomBytes2(16));
                let plaintext = utf8Encoder.encode(text);
                let ciphertext = cbc(normalizedKey, iv).encrypt(plaintext);
                let ctb64 = base64.encode(new Uint8Array(ciphertext));
                let ivb64 = base64.encode(new Uint8Array(iv.buffer));
                return `${ctb64}?iv=${ivb64}`;
            }
            async function decrypt2(secretKey, pubkey, data) {
                const privkey = secretKey instanceof Uint8Array ? bytesToHex2(secretKey) : secretKey;
                let [ctb64, ivb64] = data.split("?iv=");
                let key = secp256k1.getSharedSecret(privkey, "02" + pubkey);
                let normalizedKey = getNormalizedX(key);
                let iv = base64.decode(ivb64);
                let ciphertext = base64.decode(ctb64);
                let plaintext = cbc(normalizedKey, iv).decrypt(ciphertext);
                return utf8Decoder.decode(plaintext);
            }
            function getNormalizedX(key) {
                return key.slice(1, 33);
            }

            // nip05.ts
            var nip05_exports = {};
            __export(nip05_exports, {
                NIP05_REGEX: () => NIP05_REGEX,
                isValid: () => isValid,
                queryProfile: () => queryProfile,
                searchDomain: () => searchDomain,
                useFetchImplementation: () => useFetchImplementation
            });
            var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/;
            var _fetch;
            try {
                _fetch = fetch;
            } catch {
            }
            function useFetchImplementation(fetchImplementation) {
                _fetch = fetchImplementation;
            }
            async function searchDomain(domain, query = "") {
                try {
                    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;
                    const res = await _fetch(url, { redirect: "error" });
                    const json = await res.json();
                    return json.names;
                } catch (_) {
                    return {};
                }
            }
            async function queryProfile(fullname) {
                const match = fullname.match(NIP05_REGEX);
                if (!match)
                    return null;
                const [_, name = "_", domain] = match;
                try {
                    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;
                    const res = await (await _fetch(url, { redirect: "error" })).json();
                    let pubkey = res.names[name];
                    return pubkey ? { pubkey, relays: res.relays?.[pubkey] } : null;
                } catch (_e) {
                    return null;
                }
            }
            async function isValid(pubkey, nip05) {
                let res = await queryProfile(nip05);
                return res ? res.pubkey === pubkey : false;
            }

            // nip10.ts
            var nip10_exports = {};
            __export(nip10_exports, {
                parse: () => parse
            });
            function parse(event) {
                const result = {
                    reply: void 0,
                    root: void 0,
                    mentions: [],
                    profiles: []
                };
                const eTags = [];
                for (const tag of event.tags) {
                    if (tag[0] === "e" && tag[1]) {
                        eTags.push(tag);
                    }
                    if (tag[0] === "p" && tag[1]) {
                        result.profiles.push({
                            pubkey: tag[1],
                            relays: tag[2] ? [tag[2]] : []
                        });
                    }
                }
                for (let eTagIndex = 0; eTagIndex < eTags.length; eTagIndex++) {
                    const eTag = eTags[eTagIndex];
                    const [_, eTagEventId, eTagRelayUrl, eTagMarker] = eTag;
                    const eventPointer = {
                        id: eTagEventId,
                        relays: eTagRelayUrl ? [eTagRelayUrl] : []
                    };
                    const isFirstETag = eTagIndex === 0;
                    const isLastETag = eTagIndex === eTags.length - 1;
                    if (eTagMarker === "root") {
                        result.root = eventPointer;
                        continue;
                    }
                    if (eTagMarker === "reply") {
                        result.reply = eventPointer;
                        continue;
                    }
                    if (eTagMarker === "mention") {
                        result.mentions.push(eventPointer);
                        continue;
                    }
                    if (isFirstETag) {
                        result.root = eventPointer;
                        continue;
                    }
                    if (isLastETag) {
                        result.reply = eventPointer;
                        continue;
                    }
                    result.mentions.push(eventPointer);
                }
                return result;
            }

            // nip11.ts
            var nip11_exports = {};
            __export(nip11_exports, {
                fetchRelayInformation: () => fetchRelayInformation,
                useFetchImplementation: () => useFetchImplementation2
            });
            var _fetch2;
            try {
                _fetch2 = fetch;
            } catch {
            }
            function useFetchImplementation2(fetchImplementation) {
                _fetch2 = fetchImplementation;
            }
            async function fetchRelayInformation(url) {
                return await (await fetch(url.replace("ws://", "http://").replace("wss://", "https://"), {
                    headers: { Accept: "application/nostr+json" }
                })).json();
            }

            // nip13.ts
            var nip13_exports = {};
            __export(nip13_exports, {
                getPow: () => getPow,
                minePow: () => minePow
            });
            function getPow(hex2) {
                let count = 0;
                for (let i2 = 0; i2 < hex2.length; i2++) {
                    const nibble = parseInt(hex2[i2], 16);
                    if (nibble === 0) {
                        count += 4;
                    } else {
                        count += Math.clz32(nibble) - 28;
                        break;
                    }
                }
                return count;
            }
            function minePow(unsigned, difficulty) {
                let count = 0;
                const event = unsigned;
                const tag = ["nonce", count.toString(), difficulty.toString()];
                event.tags.push(tag);
                while (true) {
                    const now = Math.floor(new Date().getTime() / 1e3);
                    if (now !== event.created_at) {
                        count = 0;
                        event.created_at = now;
                    }
                    tag[1] = (++count).toString();
                    event.id = getEventHash(event);
                    if (getPow(event.id) >= difficulty) {
                        break;
                    }
                }
                return event;
            }

            // nip18.ts
            var nip18_exports = {};
            __export(nip18_exports, {
                finishRepostEvent: () => finishRepostEvent,
                getRepostedEvent: () => getRepostedEvent,
                getRepostedEventPointer: () => getRepostedEventPointer
            });
            function finishRepostEvent(t, reposted, relayUrl, privateKey) {
                return finalizeEvent(
                    {
                        kind: Repost,
                        tags: [...t.tags ?? [], ["e", reposted.id, relayUrl], ["p", reposted.pubkey]],
                        content: t.content === "" ? "" : JSON.stringify(reposted),
                        created_at: t.created_at
                    },
                    privateKey
                );
            }
            function getRepostedEventPointer(event) {
                if (event.kind !== Repost) {
                    return void 0;
                }
                let lastETag;
                let lastPTag;
                for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {
                    const tag = event.tags[i2];
                    if (tag.length >= 2) {
                        if (tag[0] === "e" && lastETag === void 0) {
                            lastETag = tag;
                        } else if (tag[0] === "p" && lastPTag === void 0) {
                            lastPTag = tag;
                        }
                    }
                }
                if (lastETag === void 0) {
                    return void 0;
                }
                return {
                    id: lastETag[1],
                    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === "string"),
                    author: lastPTag?.[1]
                };
            }
            function getRepostedEvent(event, { skipVerification } = {}) {
                const pointer = getRepostedEventPointer(event);
                if (pointer === void 0 || event.content === "") {
                    return void 0;
                }
                let repostedEvent;
                try {
                    repostedEvent = JSON.parse(event.content);
                } catch (error) {
                    return void 0;
                }
                if (repostedEvent.id !== pointer.id) {
                    return void 0;
                }
                if (!skipVerification && !verifyEvent(repostedEvent)) {
                    return void 0;
                }
                return repostedEvent;
            }

            // nip21.ts
            var nip21_exports = {};
            __export(nip21_exports, {
                NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,
                parse: () => parse2,
                test: () => test
            });
            var NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);
            function test(value) {
                return typeof value === "string" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);
            }
            function parse2(uri) {
                const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));
                if (!match)
                    throw new Error(`Invalid Nostr URI: ${uri}`);
                return {
                    uri: match[0],
                    value: match[1],
                    decoded: decode(match[1])
                };
            }

            // nip25.ts
            var nip25_exports = {};
            __export(nip25_exports, {
                finishReactionEvent: () => finishReactionEvent,
                getReactedEventPointer: () => getReactedEventPointer
            });
            function finishReactionEvent(t, reacted, privateKey) {
                const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === "e" || tag[0] === "p"));
                return finalizeEvent(
                    {
                        ...t,
                        kind: Reaction,
                        tags: [...t.tags ?? [], ...inheritedTags, ["e", reacted.id], ["p", reacted.pubkey]],
                        content: t.content ?? "+"
                    },
                    privateKey
                );
            }
            function getReactedEventPointer(event) {
                if (event.kind !== Reaction) {
                    return void 0;
                }
                let lastETag;
                let lastPTag;
                for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {
                    const tag = event.tags[i2];
                    if (tag.length >= 2) {
                        if (tag[0] === "e" && lastETag === void 0) {
                            lastETag = tag;
                        } else if (tag[0] === "p" && lastPTag === void 0) {
                            lastPTag = tag;
                        }
                    }
                }
                if (lastETag === void 0 || lastPTag === void 0) {
                    return void 0;
                }
                return {
                    id: lastETag[1],
                    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),
                    author: lastPTag[1]
                };
            }

            // nip27.ts
            var nip27_exports = {};
            __export(nip27_exports, {
                matchAll: () => matchAll,
                regex: () => regex,
                replaceAll: () => replaceAll
            });
            var regex = () => new RegExp(`\\b${NOSTR_URI_REGEX.source}\\b`, "g");
            function* matchAll(content) {
                const matches = content.matchAll(regex());
                for (const match of matches) {
                    try {
                        const [uri, value] = match;
                        yield {
                            uri,
                            value,
                            decoded: decode(value),
                            start: match.index,
                            end: match.index + uri.length
                        };
                    } catch (_e) {
                    }
                }
            }
            function replaceAll(content, replacer) {
                return content.replaceAll(regex(), (uri, value) => {
                    return replacer({
                        uri,
                        value,
                        decoded: decode(value)
                    });
                });
            }

            // nip28.ts
            var nip28_exports = {};
            __export(nip28_exports, {
                channelCreateEvent: () => channelCreateEvent,
                channelHideMessageEvent: () => channelHideMessageEvent,
                channelMessageEvent: () => channelMessageEvent,
                channelMetadataEvent: () => channelMetadataEvent,
                channelMuteUserEvent: () => channelMuteUserEvent
            });
            var channelCreateEvent = (t, privateKey) => {
                let content;
                if (typeof t.content === "object") {
                    content = JSON.stringify(t.content);
                } else if (typeof t.content === "string") {
                    content = t.content;
                } else {
                    return void 0;
                }
                return finalizeEvent(
                    {
                        kind: ChannelCreation,
                        tags: [...t.tags ?? []],
                        content,
                        created_at: t.created_at
                    },
                    privateKey
                );
            };
            var channelMetadataEvent = (t, privateKey) => {
                let content;
                if (typeof t.content === "object") {
                    content = JSON.stringify(t.content);
                } else if (typeof t.content === "string") {
                    content = t.content;
                } else {
                    return void 0;
                }
                return finalizeEvent(
                    {
                        kind: ChannelMetadata,
                        tags: [["e", t.channel_create_event_id], ...t.tags ?? []],
                        content,
                        created_at: t.created_at
                    },
                    privateKey
                );
            };
            var channelMessageEvent = (t, privateKey) => {
                const tags = [["e", t.channel_create_event_id, t.relay_url, "root"]];
                if (t.reply_to_channel_message_event_id) {
                    tags.push(["e", t.reply_to_channel_message_event_id, t.relay_url, "reply"]);
                }
                return finalizeEvent(
                    {
                        kind: ChannelMessage,
                        tags: [...tags, ...t.tags ?? []],
                        content: t.content,
                        created_at: t.created_at
                    },
                    privateKey
                );
            };
            var channelHideMessageEvent = (t, privateKey) => {
                let content;
                if (typeof t.content === "object") {
                    content = JSON.stringify(t.content);
                } else if (typeof t.content === "string") {
                    content = t.content;
                } else {
                    return void 0;
                }
                return finalizeEvent(
                    {
                        kind: ChannelHideMessage,
                        tags: [["e", t.channel_message_event_id], ...t.tags ?? []],
                        content,
                        created_at: t.created_at
                    },
                    privateKey
                );
            };
            var channelMuteUserEvent = (t, privateKey) => {
                let content;
                if (typeof t.content === "object") {
                    content = JSON.stringify(t.content);
                } else if (typeof t.content === "string") {
                    content = t.content;
                } else {
                    return void 0;
                }
                return finalizeEvent(
                    {
                        kind: ChannelMuteUser,
                        tags: [["p", t.pubkey_to_mute], ...t.tags ?? []],
                        content,
                        created_at: t.created_at
                    },
                    privateKey
                );
            };

            // nip30.ts
            var nip30_exports = {};
            __export(nip30_exports, {
                EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,
                matchAll: () => matchAll2,
                regex: () => regex2,
                replaceAll: () => replaceAll2
            });
            var EMOJI_SHORTCODE_REGEX = /:(\w+):/;
            var regex2 = () => new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`, "g");
            function* matchAll2(content) {
                const matches = content.matchAll(regex2());
                for (const match of matches) {
                    try {
                        const [shortcode, name] = match;
                        yield {
                            shortcode,
                            name,
                            start: match.index,
                            end: match.index + shortcode.length
                        };
                    } catch (_e) {
                    }
                }
            }
            function replaceAll2(content, replacer) {
                return content.replaceAll(regex2(), (shortcode, name) => {
                    return replacer({
                        shortcode,
                        name
                    });
                });
            }

            // nip39.ts
            var nip39_exports = {};
            __export(nip39_exports, {
                useFetchImplementation: () => useFetchImplementation3,
                validateGithub: () => validateGithub
            });
            var _fetch3;
            try {
                _fetch3 = fetch;
            } catch {
            }
            function useFetchImplementation3(fetchImplementation) {
                _fetch3 = fetchImplementation;
            }
            async function validateGithub(pubkey, username, proof) {
                try {
                    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();
                    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;
                } catch (_) {
                    return false;
                }
            }

            // nip44.ts
            var nip44_exports = {};
            __export(nip44_exports, {
                decrypt: () => decrypt3,
                encrypt: () => encrypt3,
                getConversationKey: () => getConversationKey,
                v2: () => v2
            });

            // node_modules/@noble/ciphers/esm/_poly1305.js
            var u8to16 = (a, i2) => a[i2++] & 255 | (a[i2++] & 255) << 8;
            var Poly1305 = class {
                constructor(key) {
                    this.blockLen = 16;
                    this.outputLen = 16;
                    this.buffer = new Uint8Array(16);
                    this.r = new Uint16Array(10);
                    this.h = new Uint16Array(10);
                    this.pad = new Uint16Array(8);
                    this.pos = 0;
                    this.finished = false;
                    key = toBytes3(key);
                    bytes3(key, 32);
                    const t0 = u8to16(key, 0);
                    const t1 = u8to16(key, 2);
                    const t2 = u8to16(key, 4);
                    const t3 = u8to16(key, 6);
                    const t4 = u8to16(key, 8);
                    const t5 = u8to16(key, 10);
                    const t6 = u8to16(key, 12);
                    const t7 = u8to16(key, 14);
                    this.r[0] = t0 & 8191;
                    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
                    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
                    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
                    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
                    this.r[5] = t4 >>> 1 & 8190;
                    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
                    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
                    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
                    this.r[9] = t7 >>> 5 & 127;
                    for (let i2 = 0; i2 < 8; i2++)
                        this.pad[i2] = u8to16(key, 16 + 2 * i2);
                }
                process(data, offset, isLast = false) {
                    const hibit = isLast ? 0 : 1 << 11;
                    const { h, r } = this;
                    const r0 = r[0];
                    const r1 = r[1];
                    const r2 = r[2];
                    const r3 = r[3];
                    const r4 = r[4];
                    const r5 = r[5];
                    const r6 = r[6];
                    const r7 = r[7];
                    const r8 = r[8];
                    const r9 = r[9];
                    const t0 = u8to16(data, offset + 0);
                    const t1 = u8to16(data, offset + 2);
                    const t2 = u8to16(data, offset + 4);
                    const t3 = u8to16(data, offset + 6);
                    const t4 = u8to16(data, offset + 8);
                    const t5 = u8to16(data, offset + 10);
                    const t6 = u8to16(data, offset + 12);
                    const t7 = u8to16(data, offset + 14);
                    let h0 = h[0] + (t0 & 8191);
                    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
                    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
                    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
                    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
                    let h5 = h[5] + (t4 >>> 1 & 8191);
                    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
                    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
                    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
                    let h9 = h[9] + (t7 >>> 5 | hibit);
                    let c = 0;
                    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
                    c = d0 >>> 13;
                    d0 &= 8191;
                    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
                    c += d0 >>> 13;
                    d0 &= 8191;
                    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
                    c = d1 >>> 13;
                    d1 &= 8191;
                    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
                    c += d1 >>> 13;
                    d1 &= 8191;
                    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
                    c = d2 >>> 13;
                    d2 &= 8191;
                    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
                    c += d2 >>> 13;
                    d2 &= 8191;
                    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
                    c = d3 >>> 13;
                    d3 &= 8191;
                    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
                    c += d3 >>> 13;
                    d3 &= 8191;
                    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
                    c = d4 >>> 13;
                    d4 &= 8191;
                    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
                    c += d4 >>> 13;
                    d4 &= 8191;
                    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
                    c = d5 >>> 13;
                    d5 &= 8191;
                    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
                    c += d5 >>> 13;
                    d5 &= 8191;
                    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
                    c = d6 >>> 13;
                    d6 &= 8191;
                    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
                    c += d6 >>> 13;
                    d6 &= 8191;
                    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
                    c = d7 >>> 13;
                    d7 &= 8191;
                    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
                    c += d7 >>> 13;
                    d7 &= 8191;
                    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
                    c = d8 >>> 13;
                    d8 &= 8191;
                    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
                    c += d8 >>> 13;
                    d8 &= 8191;
                    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
                    c = d9 >>> 13;
                    d9 &= 8191;
                    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
                    c += d9 >>> 13;
                    d9 &= 8191;
                    c = (c << 2) + c | 0;
                    c = c + d0 | 0;
                    d0 = c & 8191;
                    c = c >>> 13;
                    d1 += c;
                    h[0] = d0;
                    h[1] = d1;
                    h[2] = d2;
                    h[3] = d3;
                    h[4] = d4;
                    h[5] = d5;
                    h[6] = d6;
                    h[7] = d7;
                    h[8] = d8;
                    h[9] = d9;
                }
                finalize() {
                    const { h, pad: pad2 } = this;
                    const g = new Uint16Array(10);
                    let c = h[1] >>> 13;
                    h[1] &= 8191;
                    for (let i2 = 2; i2 < 10; i2++) {
                        h[i2] += c;
                        c = h[i2] >>> 13;
                        h[i2] &= 8191;
                    }
                    h[0] += c * 5;
                    c = h[0] >>> 13;
                    h[0] &= 8191;
                    h[1] += c;
                    c = h[1] >>> 13;
                    h[1] &= 8191;
                    h[2] += c;
                    g[0] = h[0] + 5;
                    c = g[0] >>> 13;
                    g[0] &= 8191;
                    for (let i2 = 1; i2 < 10; i2++) {
                        g[i2] = h[i2] + c;
                        c = g[i2] >>> 13;
                        g[i2] &= 8191;
                    }
                    g[9] -= 1 << 13;
                    let mask = (c ^ 1) - 1;
                    for (let i2 = 0; i2 < 10; i2++)
                        g[i2] &= mask;
                    mask = ~mask;
                    for (let i2 = 0; i2 < 10; i2++)
                        h[i2] = h[i2] & mask | g[i2];
                    h[0] = (h[0] | h[1] << 13) & 65535;
                    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
                    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
                    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
                    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
                    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
                    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
                    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
                    let f = h[0] + pad2[0];
                    h[0] = f & 65535;
                    for (let i2 = 1; i2 < 8; i2++) {
                        f = (h[i2] + pad2[i2] | 0) + (f >>> 16) | 0;
                        h[i2] = f & 65535;
                    }
                }
                update(data) {
                    exists3(this);
                    const { buffer, blockLen } = this;
                    data = toBytes3(data);
                    const len = data.length;
                    for (let pos = 0; pos < len;) {
                        const take = Math.min(blockLen - this.pos, len - pos);
                        if (take === blockLen) {
                            for (; blockLen <= len - pos; pos += blockLen)
                                this.process(data, pos);
                            continue;
                        }
                        buffer.set(data.subarray(pos, pos + take), this.pos);
                        this.pos += take;
                        pos += take;
                        if (this.pos === blockLen) {
                            this.process(buffer, 0, false);
                            this.pos = 0;
                        }
                    }
                    return this;
                }
                destroy() {
                    this.h.fill(0);
                    this.r.fill(0);
                    this.buffer.fill(0);
                    this.pad.fill(0);
                }
                digestInto(out) {
                    exists3(this);
                    output3(out, this);
                    this.finished = true;
                    const { buffer, h } = this;
                    let { pos } = this;
                    if (pos) {
                        buffer[pos++] = 1;
                        for (; pos < 16; pos++)
                            buffer[pos] = 0;
                        this.process(buffer, 0, true);
                    }
                    this.finalize();
                    let opos = 0;
                    for (let i2 = 0; i2 < 8; i2++) {
                        out[opos++] = h[i2] >>> 0;
                        out[opos++] = h[i2] >>> 8;
                    }
                    return out;
                }
                digest() {
                    const { buffer, outputLen } = this;
                    this.digestInto(buffer);
                    const res = buffer.slice(0, outputLen);
                    this.destroy();
                    return res;
                }
            };
            function wrapConstructorWithKey2(hashCons) {
                const hashC = (msg, key) => hashCons(key).update(toBytes3(msg)).digest();
                const tmp = hashCons(new Uint8Array(32));
                hashC.outputLen = tmp.outputLen;
                hashC.blockLen = tmp.blockLen;
                hashC.create = (key) => hashCons(key);
                return hashC;
            }
            var poly1305 = wrapConstructorWithKey2((key) => new Poly1305(key));

            // node_modules/@noble/ciphers/esm/_arx.js
            var sigma16 = utf8ToBytes4("expand 16-byte k");
            var sigma32 = utf8ToBytes4("expand 32-byte k");
            var sigma16_32 = u32(sigma16);
            var sigma32_32 = u32(sigma32);
            function rotl(a, b) {
                return a << b | a >>> 32 - b;
            }
            function isAligned32(b) {
                return b.byteOffset % 4 === 0;
            }
            var BLOCK_LEN = 64;
            var BLOCK_LEN32 = 16;
            var MAX_COUNTER = 2 ** 32 - 1;
            var U32_EMPTY = new Uint32Array();
            function runCipher(core, sigma, key, nonce, data, output4, counter, rounds) {
                const len = data.length;
                const block = new Uint8Array(BLOCK_LEN);
                const b32 = u32(block);
                const isAligned = isAligned32(data) && isAligned32(output4);
                const d32 = isAligned ? u32(data) : U32_EMPTY;
                const o32 = isAligned ? u32(output4) : U32_EMPTY;
                for (let pos = 0; pos < len; counter++) {
                    core(sigma, key, nonce, b32, counter, rounds);
                    if (counter >= MAX_COUNTER)
                        throw new Error("arx: counter overflow");
                    const take = Math.min(BLOCK_LEN, len - pos);
                    if (isAligned && take === BLOCK_LEN) {
                        const pos32 = pos / 4;
                        if (pos % 4 !== 0)
                            throw new Error("arx: invalid block position");
                        for (let j = 0, posj; j < BLOCK_LEN32; j++) {
                            posj = pos32 + j;
                            o32[posj] = d32[posj] ^ b32[j];
                        }
                        pos += BLOCK_LEN;
                        continue;
                    }
                    for (let j = 0, posj; j < take; j++) {
                        posj = pos + j;
                        output4[posj] = data[posj] ^ block[j];
                    }
                    pos += take;
                }
            }
            function createCipher(core, opts) {
                const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
                if (typeof core !== "function")
                    throw new Error("core must be a function");
                number3(counterLength);
                number3(rounds);
                bool2(counterRight);
                bool2(allowShortKeys);
                return (key, nonce, data, output4, counter = 0) => {
                    bytes3(key);
                    bytes3(nonce);
                    bytes3(data);
                    const len = data.length;
                    if (!output4)
                        output4 = new Uint8Array(len);
                    bytes3(output4);
                    number3(counter);
                    if (counter < 0 || counter >= MAX_COUNTER)
                        throw new Error("arx: counter overflow");
                    if (output4.length < len)
                        throw new Error(`arx: output (${output4.length}) is shorter than data (${len})`);
                    const toClean = [];
                    let l = key.length, k, sigma;
                    if (l === 32) {
                        k = key.slice();
                        toClean.push(k);
                        sigma = sigma32_32;
                    } else if (l === 16 && allowShortKeys) {
                        k = new Uint8Array(32);
                        k.set(key);
                        k.set(key, 16);
                        sigma = sigma16_32;
                        toClean.push(k);
                    } else {
                        throw new Error(`arx: invalid 32-byte key, got length=${l}`);
                    }
                    if (!isAligned32(nonce)) {
                        nonce = nonce.slice();
                        toClean.push(nonce);
                    }
                    const k32 = u32(k);
                    if (extendNonceFn) {
                        if (nonce.length !== 24)
                            throw new Error(`arx: extended nonce must be 24 bytes`);
                        extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
                        nonce = nonce.subarray(16);
                    }
                    const nonceNcLen = 16 - counterLength;
                    if (nonceNcLen !== nonce.length)
                        throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
                    if (nonceNcLen !== 12) {
                        const nc = new Uint8Array(12);
                        nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
                        nonce = nc;
                        toClean.push(nonce);
                    }
                    const n32 = u32(nonce);
                    runCipher(core, sigma, k32, n32, data, output4, counter, rounds);
                    while (toClean.length > 0)
                        toClean.pop().fill(0);
                    return output4;
                };
            }

            // node_modules/@noble/ciphers/esm/chacha.js
            function chachaCore(s, k, n, out, cnt, rounds = 20) {
                let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
                let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
                for (let r = 0; r < rounds; r += 2) {
                    x00 = x00 + x04 | 0;
                    x12 = rotl(x12 ^ x00, 16);
                    x08 = x08 + x12 | 0;
                    x04 = rotl(x04 ^ x08, 12);
                    x00 = x00 + x04 | 0;
                    x12 = rotl(x12 ^ x00, 8);
                    x08 = x08 + x12 | 0;
                    x04 = rotl(x04 ^ x08, 7);
                    x01 = x01 + x05 | 0;
                    x13 = rotl(x13 ^ x01, 16);
                    x09 = x09 + x13 | 0;
                    x05 = rotl(x05 ^ x09, 12);
                    x01 = x01 + x05 | 0;
                    x13 = rotl(x13 ^ x01, 8);
                    x09 = x09 + x13 | 0;
                    x05 = rotl(x05 ^ x09, 7);
                    x02 = x02 + x06 | 0;
                    x14 = rotl(x14 ^ x02, 16);
                    x10 = x10 + x14 | 0;
                    x06 = rotl(x06 ^ x10, 12);
                    x02 = x02 + x06 | 0;
                    x14 = rotl(x14 ^ x02, 8);
                    x10 = x10 + x14 | 0;
                    x06 = rotl(x06 ^ x10, 7);
                    x03 = x03 + x07 | 0;
                    x15 = rotl(x15 ^ x03, 16);
                    x11 = x11 + x15 | 0;
                    x07 = rotl(x07 ^ x11, 12);
                    x03 = x03 + x07 | 0;
                    x15 = rotl(x15 ^ x03, 8);
                    x11 = x11 + x15 | 0;
                    x07 = rotl(x07 ^ x11, 7);
                    x00 = x00 + x05 | 0;
                    x15 = rotl(x15 ^ x00, 16);
                    x10 = x10 + x15 | 0;
                    x05 = rotl(x05 ^ x10, 12);
                    x00 = x00 + x05 | 0;
                    x15 = rotl(x15 ^ x00, 8);
                    x10 = x10 + x15 | 0;
                    x05 = rotl(x05 ^ x10, 7);
                    x01 = x01 + x06 | 0;
                    x12 = rotl(x12 ^ x01, 16);
                    x11 = x11 + x12 | 0;
                    x06 = rotl(x06 ^ x11, 12);
                    x01 = x01 + x06 | 0;
                    x12 = rotl(x12 ^ x01, 8);
                    x11 = x11 + x12 | 0;
                    x06 = rotl(x06 ^ x11, 7);
                    x02 = x02 + x07 | 0;
                    x13 = rotl(x13 ^ x02, 16);
                    x08 = x08 + x13 | 0;
                    x07 = rotl(x07 ^ x08, 12);
                    x02 = x02 + x07 | 0;
                    x13 = rotl(x13 ^ x02, 8);
                    x08 = x08 + x13 | 0;
                    x07 = rotl(x07 ^ x08, 7);
                    x03 = x03 + x04 | 0;
                    x14 = rotl(x14 ^ x03, 16);
                    x09 = x09 + x14 | 0;
                    x04 = rotl(x04 ^ x09, 12);
                    x03 = x03 + x04 | 0;
                    x14 = rotl(x14 ^ x03, 8);
                    x09 = x09 + x14 | 0;
                    x04 = rotl(x04 ^ x09, 7);
                }
                let oi = 0;
                out[oi++] = y00 + x00 | 0;
                out[oi++] = y01 + x01 | 0;
                out[oi++] = y02 + x02 | 0;
                out[oi++] = y03 + x03 | 0;
                out[oi++] = y04 + x04 | 0;
                out[oi++] = y05 + x05 | 0;
                out[oi++] = y06 + x06 | 0;
                out[oi++] = y07 + x07 | 0;
                out[oi++] = y08 + x08 | 0;
                out[oi++] = y09 + x09 | 0;
                out[oi++] = y10 + x10 | 0;
                out[oi++] = y11 + x11 | 0;
                out[oi++] = y12 + x12 | 0;
                out[oi++] = y13 + x13 | 0;
                out[oi++] = y14 + x14 | 0;
                out[oi++] = y15 + x15 | 0;
            }
            function hchacha(s, k, i2, o32) {
                let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i2[0], x13 = i2[1], x14 = i2[2], x15 = i2[3];
                for (let r = 0; r < 20; r += 2) {
                    x00 = x00 + x04 | 0;
                    x12 = rotl(x12 ^ x00, 16);
                    x08 = x08 + x12 | 0;
                    x04 = rotl(x04 ^ x08, 12);
                    x00 = x00 + x04 | 0;
                    x12 = rotl(x12 ^ x00, 8);
                    x08 = x08 + x12 | 0;
                    x04 = rotl(x04 ^ x08, 7);
                    x01 = x01 + x05 | 0;
                    x13 = rotl(x13 ^ x01, 16);
                    x09 = x09 + x13 | 0;
                    x05 = rotl(x05 ^ x09, 12);
                    x01 = x01 + x05 | 0;
                    x13 = rotl(x13 ^ x01, 8);
                    x09 = x09 + x13 | 0;
                    x05 = rotl(x05 ^ x09, 7);
                    x02 = x02 + x06 | 0;
                    x14 = rotl(x14 ^ x02, 16);
                    x10 = x10 + x14 | 0;
                    x06 = rotl(x06 ^ x10, 12);
                    x02 = x02 + x06 | 0;
                    x14 = rotl(x14 ^ x02, 8);
                    x10 = x10 + x14 | 0;
                    x06 = rotl(x06 ^ x10, 7);
                    x03 = x03 + x07 | 0;
                    x15 = rotl(x15 ^ x03, 16);
                    x11 = x11 + x15 | 0;
                    x07 = rotl(x07 ^ x11, 12);
                    x03 = x03 + x07 | 0;
                    x15 = rotl(x15 ^ x03, 8);
                    x11 = x11 + x15 | 0;
                    x07 = rotl(x07 ^ x11, 7);
                    x00 = x00 + x05 | 0;
                    x15 = rotl(x15 ^ x00, 16);
                    x10 = x10 + x15 | 0;
                    x05 = rotl(x05 ^ x10, 12);
                    x00 = x00 + x05 | 0;
                    x15 = rotl(x15 ^ x00, 8);
                    x10 = x10 + x15 | 0;
                    x05 = rotl(x05 ^ x10, 7);
                    x01 = x01 + x06 | 0;
                    x12 = rotl(x12 ^ x01, 16);
                    x11 = x11 + x12 | 0;
                    x06 = rotl(x06 ^ x11, 12);
                    x01 = x01 + x06 | 0;
                    x12 = rotl(x12 ^ x01, 8);
                    x11 = x11 + x12 | 0;
                    x06 = rotl(x06 ^ x11, 7);
                    x02 = x02 + x07 | 0;
                    x13 = rotl(x13 ^ x02, 16);
                    x08 = x08 + x13 | 0;
                    x07 = rotl(x07 ^ x08, 12);
                    x02 = x02 + x07 | 0;
                    x13 = rotl(x13 ^ x02, 8);
                    x08 = x08 + x13 | 0;
                    x07 = rotl(x07 ^ x08, 7);
                    x03 = x03 + x04 | 0;
                    x14 = rotl(x14 ^ x03, 16);
                    x09 = x09 + x14 | 0;
                    x04 = rotl(x04 ^ x09, 12);
                    x03 = x03 + x04 | 0;
                    x14 = rotl(x14 ^ x03, 8);
                    x09 = x09 + x14 | 0;
                    x04 = rotl(x04 ^ x09, 7);
                }
                let oi = 0;
                o32[oi++] = x00;
                o32[oi++] = x01;
                o32[oi++] = x02;
                o32[oi++] = x03;
                o32[oi++] = x12;
                o32[oi++] = x13;
                o32[oi++] = x14;
                o32[oi++] = x15;
            }
            var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
                counterRight: false,
                counterLength: 4,
                allowShortKeys: false
            });
            var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
                counterRight: false,
                counterLength: 8,
                extendNonceFn: hchacha,
                allowShortKeys: false
            });
            var ZEROS162 = /* @__PURE__ */ new Uint8Array(16);
            var updatePadded = (h, msg) => {
                h.update(msg);
                const left = msg.length % 16;
                if (left)
                    h.update(ZEROS162.subarray(left));
            };
            var ZEROS322 = /* @__PURE__ */ new Uint8Array(32);
            function computeTag2(fn, key, nonce, data, AAD) {
                const authKey = fn(key, nonce, ZEROS322);
                const h = poly1305.create(authKey);
                if (AAD)
                    updatePadded(h, AAD);
                updatePadded(h, data);
                const num = new Uint8Array(16);
                const view = createView3(num);
                setBigUint643(view, 0, BigInt(AAD ? AAD.length : 0), true);
                setBigUint643(view, 8, BigInt(data.length), true);
                h.update(num);
                const res = h.digest();
                authKey.fill(0);
                return res;
            }
            var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
                const tagLength = 16;
                bytes3(key, 32);
                bytes3(nonce);
                return {
                    encrypt: (plaintext, output4) => {
                        const plength = plaintext.length;
                        const clength = plength + tagLength;
                        if (output4) {
                            bytes3(output4, clength);
                        } else {
                            output4 = new Uint8Array(clength);
                        }
                        xorStream(key, nonce, plaintext, output4, 1);
                        const tag = computeTag2(xorStream, key, nonce, output4.subarray(0, -tagLength), AAD);
                        output4.set(tag, plength);
                        return output4;
                    },
                    decrypt: (ciphertext, output4) => {
                        const clength = ciphertext.length;
                        const plength = clength - tagLength;
                        if (clength < tagLength)
                            throw new Error(`encrypted data must be at least ${tagLength} bytes`);
                        if (output4) {
                            bytes3(output4, plength);
                        } else {
                            output4 = new Uint8Array(plength);
                        }
                        const data = ciphertext.subarray(0, -tagLength);
                        const passedTag = ciphertext.subarray(-tagLength);
                        const tag = computeTag2(xorStream, key, nonce, data, AAD);
                        if (!equalBytes2(passedTag, tag))
                            throw new Error("invalid tag");
                        xorStream(key, nonce, data, output4, 1);
                        return output4;
                    }
                };
            };
            var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
            var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

            // node_modules/@noble/hashes/esm/hmac.js
            var HMAC2 = class extends Hash2 {
                constructor(hash3, _key) {
                    super();
                    this.finished = false;
                    this.destroyed = false;
                    assert_default.hash(hash3);
                    const key = toBytes2(_key);
                    this.iHash = hash3.create();
                    if (typeof this.iHash.update !== "function")
                        throw new Error("Expected instance of class which extends utils.Hash");
                    this.blockLen = this.iHash.blockLen;
                    this.outputLen = this.iHash.outputLen;
                    const blockLen = this.blockLen;
                    const pad2 = new Uint8Array(blockLen);
                    pad2.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
                    for (let i2 = 0; i2 < pad2.length; i2++)
                        pad2[i2] ^= 54;
                    this.iHash.update(pad2);
                    this.oHash = hash3.create();
                    for (let i2 = 0; i2 < pad2.length; i2++)
                        pad2[i2] ^= 54 ^ 92;
                    this.oHash.update(pad2);
                    pad2.fill(0);
                }
                update(buf) {
                    assert_default.exists(this);
                    this.iHash.update(buf);
                    return this;
                }
                digestInto(out) {
                    assert_default.exists(this);
                    assert_default.bytes(out, this.outputLen);
                    this.finished = true;
                    this.iHash.digestInto(out);
                    this.oHash.update(out);
                    this.oHash.digestInto(out);
                    this.destroy();
                }
                digest() {
                    const out = new Uint8Array(this.oHash.outputLen);
                    this.digestInto(out);
                    return out;
                }
                _cloneInto(to) {
                    to || (to = Object.create(Object.getPrototypeOf(this), {}));
                    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
                    to = to;
                    to.finished = finished;
                    to.destroyed = destroyed;
                    to.blockLen = blockLen;
                    to.outputLen = outputLen;
                    to.oHash = oHash._cloneInto(to.oHash);
                    to.iHash = iHash._cloneInto(to.iHash);
                    return to;
                }
                destroy() {
                    this.destroyed = true;
                    this.oHash.destroy();
                    this.iHash.destroy();
                }
            };
            var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
            hmac2.create = (hash3, key) => new HMAC2(hash3, key);

            // node_modules/@noble/hashes/esm/hkdf.js
            function extract(hash3, ikm, salt) {
                assert_default.hash(hash3);
                if (salt === void 0)
                    salt = new Uint8Array(hash3.outputLen);
                return hmac2(hash3, toBytes2(salt), toBytes2(ikm));
            }
            var HKDF_COUNTER = new Uint8Array([0]);
            var EMPTY_BUFFER = new Uint8Array();
            function expand(hash3, prk, info, length = 32) {
                assert_default.hash(hash3);
                assert_default.number(length);
                if (length > 255 * hash3.outputLen)
                    throw new Error("Length should be <= 255*HashLen");
                const blocks = Math.ceil(length / hash3.outputLen);
                if (info === void 0)
                    info = EMPTY_BUFFER;
                const okm = new Uint8Array(blocks * hash3.outputLen);
                const HMAC3 = hmac2.create(hash3, prk);
                const HMACTmp = HMAC3._cloneInto();
                const T = new Uint8Array(HMAC3.outputLen);
                for (let counter = 0; counter < blocks; counter++) {
                    HKDF_COUNTER[0] = counter + 1;
                    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
                    okm.set(T, hash3.outputLen * counter);
                    HMAC3._cloneInto(HMACTmp);
                }
                HMAC3.destroy();
                HMACTmp.destroy();
                T.fill(0);
                HKDF_COUNTER.fill(0);
                return okm.slice(0, length);
            }

            // nip44.ts
            var minPlaintextSize = 1;
            var maxPlaintextSize = 65535;
            function getConversationKey(privkeyA, pubkeyB) {
                const sharedX = secp256k1.getSharedSecret(privkeyA, "02" + pubkeyB).subarray(1, 33);
                return extract(sha2562, sharedX, "nip44-v2");
            }
            function getMessageKeys(conversationKey, nonce) {
                const keys = expand(sha2562, conversationKey, nonce, 76);
                return {
                    chacha_key: keys.subarray(0, 32),
                    chacha_nonce: keys.subarray(32, 44),
                    hmac_key: keys.subarray(44, 76)
                };
            }
            function calcPaddedLen(len) {
                if (!Number.isSafeInteger(len) || len < 1)
                    throw new Error("expected positive integer");
                if (len <= 32)
                    return 32;
                const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;
                const chunk = nextPower <= 256 ? 32 : nextPower / 8;
                return chunk * (Math.floor((len - 1) / chunk) + 1);
            }
            function writeU16BE(num) {
                if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)
                    throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
                const arr = new Uint8Array(2);
                new DataView(arr.buffer).setUint16(0, num, false);
                return arr;
            }
            function pad(plaintext) {
                const unpadded = utf8Encoder.encode(plaintext);
                const unpaddedLen = unpadded.length;
                const prefix = writeU16BE(unpaddedLen);
                const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);
                return concatBytes3(prefix, unpadded, suffix);
            }
            function unpad(padded) {
                const unpaddedLen = new DataView(padded.buffer).getUint16(0);
                const unpadded = padded.subarray(2, 2 + unpaddedLen);
                if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))
                    throw new Error("invalid padding");
                return utf8Decoder.decode(unpadded);
            }
            function hmacAad(key, message, aad) {
                if (aad.length !== 32)
                    throw new Error("AAD associated data must be 32 bytes");
                const combined = concatBytes3(aad, message);
                return hmac2(sha2562, key, combined);
            }
            function decodePayload(payload) {
                if (typeof payload !== "string")
                    throw new Error("payload must be a valid string");
                const plen = payload.length;
                if (plen < 132 || plen > 87472)
                    throw new Error("invalid payload length: " + plen);
                if (payload[0] === "#")
                    throw new Error("unknown encryption version");
                let data;
                try {
                    data = base64.decode(payload);
                } catch (error) {
                    throw new Error("invalid base64: " + error.message);
                }
                const dlen = data.length;
                if (dlen < 99 || dlen > 65603)
                    throw new Error("invalid data length: " + dlen);
                const vers = data[0];
                if (vers !== 2)
                    throw new Error("unknown encryption version " + vers);
                return {
                    nonce: data.subarray(1, 33),
                    ciphertext: data.subarray(33, -32),
                    mac: data.subarray(-32)
                };
            }
            function encrypt3(plaintext, conversationKey, nonce = randomBytes2(32)) {
                const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);
                const padded = pad(plaintext);
                const ciphertext = chacha20(chacha_key, chacha_nonce, padded);
                const mac = hmacAad(hmac_key, ciphertext, nonce);
                return base64.encode(concatBytes3(new Uint8Array([2]), nonce, ciphertext, mac));
            }
            function decrypt3(payload, conversationKey) {
                const { nonce, ciphertext, mac } = decodePayload(payload);
                const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);
                const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);
                if (!equalBytes2(calculatedMac, mac))
                    throw new Error("invalid MAC");
                const padded = chacha20(chacha_key, chacha_nonce, ciphertext);
                return unpad(padded);
            }
            var v2 = {
                utils: {
                    getConversationKey,
                    calcPaddedLen
                },
                encrypt: encrypt3,
                decrypt: decrypt3
            };

            // nip47.ts
            var nip47_exports = {};
            __export(nip47_exports, {
                makeNwcRequestEvent: () => makeNwcRequestEvent,
                parseConnectionString: () => parseConnectionString
            });
            function parseConnectionString(connectionString) {
                const { pathname, searchParams } = new URL(connectionString);
                const pubkey = pathname;
                const relay = searchParams.get("relay");
                const secret = searchParams.get("secret");
                if (!pubkey || !relay || !secret) {
                    throw new Error("invalid connection string");
                }
                return { pubkey, relay, secret };
            }
            async function makeNwcRequestEvent(pubkey, secretKey, invoice) {
                const content = {
                    method: "pay_invoice",
                    params: {
                        invoice
                    }
                };
                const encryptedContent = await encrypt2(secretKey, pubkey, JSON.stringify(content));
                const eventTemplate = {
                    kind: NWCWalletRequest,
                    created_at: Math.round(Date.now() / 1e3),
                    content: encryptedContent,
                    tags: [["p", pubkey]]
                };
                return finalizeEvent(eventTemplate, secretKey);
            }

            // nip57.ts
            var nip57_exports = {};
            __export(nip57_exports, {
                getZapEndpoint: () => getZapEndpoint,
                makeZapReceipt: () => makeZapReceipt,
                makeZapRequest: () => makeZapRequest,
                useFetchImplementation: () => useFetchImplementation4,
                validateZapRequest: () => validateZapRequest
            });
            var _fetch4;
            try {
                _fetch4 = fetch;
            } catch {
            }
            function useFetchImplementation4(fetchImplementation) {
                _fetch4 = fetchImplementation;
            }
            async function getZapEndpoint(metadata) {
                try {
                    let lnurl = "";
                    let { lud06, lud16 } = JSON.parse(metadata.content);
                    if (lud06) {
                        let { words } = bech32.decode(lud06, 1e3);
                        let data = bech32.fromWords(words);
                        lnurl = utf8Decoder.decode(data);
                    } else if (lud16) {
                        let [name, domain] = lud16.split("@");
                        lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();
                    } else {
                        return null;
                    }
                    let res = await _fetch4(lnurl);
                    let body = await res.json();
                    if (body.allowsNostr && body.nostrPubkey) {
                        return body.callback;
                    }
                } catch (err) {
                }
                return null;
            }
            function makeZapRequest({
                profile,
                event,
                amount,
                relays,
                comment = ""
            }) {
                if (!amount)
                    throw new Error("amount not given");
                if (!profile)
                    throw new Error("profile not given");
                let zr = {
                    kind: 9734,
                    created_at: Math.round(Date.now() / 1e3),
                    content: comment,
                    tags: [
                        ["p", profile],
                        ["amount", amount.toString()],
                        ["relays", ...relays]
                    ]
                };
                if (event) {
                    zr.tags.push(["e", event]);
                }
                return zr;
            }
            function validateZapRequest(zapRequestString) {
                let zapRequest;
                try {
                    zapRequest = JSON.parse(zapRequestString);
                } catch (err) {
                    return "Invalid zap request JSON.";
                }
                if (!validateEvent(zapRequest))
                    return "Zap request is not a valid Nostr event.";
                if (!verifyEvent(zapRequest))
                    return "Invalid signature on zap request.";
                let p = zapRequest.tags.find(([t, v]) => t === "p" && v);
                if (!p)
                    return "Zap request doesn't have a 'p' tag.";
                if (!p[1].match(/^[a-f0-9]{64}$/))
                    return "Zap request 'p' tag is not valid hex.";
                let e = zapRequest.tags.find(([t, v]) => t === "e" && v);
                if (e && !e[1].match(/^[a-f0-9]{64}$/))
                    return "Zap request 'e' tag is not valid hex.";
                let relays = zapRequest.tags.find(([t, v]) => t === "relays" && v);
                if (!relays)
                    return "Zap request doesn't have a 'relays' tag.";
                return null;
            }
            function makeZapReceipt({
                zapRequest,
                preimage,
                bolt11,
                paidAt
            }) {
                let zr = JSON.parse(zapRequest);
                let tagsFromZapRequest = zr.tags.filter(([t]) => t === "e" || t === "p" || t === "a");
                let zap = {
                    kind: 9735,
                    created_at: Math.round(paidAt.getTime() / 1e3),
                    content: "",
                    tags: [...tagsFromZapRequest, ["P", zr.pubkey], ["bolt11", bolt11], ["description", zapRequest]]
                };
                if (preimage) {
                    zap.tags.push(["preimage", preimage]);
                }
                return zap;
            }

            // nip98.ts
            var nip98_exports = {};
            __export(nip98_exports, {
                getToken: () => getToken,
                hashPayload: () => hashPayload,
                unpackEventFromToken: () => unpackEventFromToken,
                validateEvent: () => validateEvent2,
                validateEventKind: () => validateEventKind,
                validateEventMethodTag: () => validateEventMethodTag,
                validateEventPayloadTag: () => validateEventPayloadTag,
                validateEventTimestamp: () => validateEventTimestamp,
                validateEventUrlTag: () => validateEventUrlTag,
                validateToken: () => validateToken
            });
            var _authorizationScheme = "Nostr ";
            async function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {
                const event = {
                    kind: HTTPAuth,
                    tags: [
                        ["u", loginUrl],
                        ["method", httpMethod]
                    ],
                    created_at: Math.round(new Date().getTime() / 1e3),
                    content: ""
                };
                if (payload) {
                    event.tags.push(["payload", hashPayload(payload)]);
                }
                const signedEvent = await sign(event);
                const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : "";
                return authorizationScheme + base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));
            }
            async function validateToken(token, url, method) {
                const event = await unpackEventFromToken(token).catch((error) => {
                    throw error;
                });
                const valid = await validateEvent2(event, url, method).catch((error) => {
                    throw error;
                });
                return valid;
            }
            async function unpackEventFromToken(token) {
                if (!token) {
                    throw new Error("Missing token");
                }
                token = token.replace(_authorizationScheme, "");
                const eventB64 = utf8Decoder.decode(base64.decode(token));
                if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith("{")) {
                    throw new Error("Invalid token");
                }
                const event = JSON.parse(eventB64);
                return event;
            }
            function validateEventTimestamp(event) {
                if (!event.created_at) {
                    return false;
                }
                return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;
            }
            function validateEventKind(event) {
                return event.kind === HTTPAuth;
            }
            function validateEventUrlTag(event, url) {
                const urlTag = event.tags.find((t) => t[0] === "u");
                if (!urlTag) {
                    return false;
                }
                return urlTag.length > 0 && urlTag[1] === url;
            }
            function validateEventMethodTag(event, method) {
                const methodTag = event.tags.find((t) => t[0] === "method");
                if (!methodTag) {
                    return false;
                }
                return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();
            }
            function hashPayload(payload) {
                const hash3 = sha2562(utf8Encoder.encode(JSON.stringify(payload)));
                return bytesToHex2(hash3);
            }
            function validateEventPayloadTag(event, payload) {
                const payloadTag = event.tags.find((t) => t[0] === "payload");
                if (!payloadTag) {
                    return false;
                }
                const payloadHash = hashPayload(payload);
                return payloadTag.length > 0 && payloadTag[1] === payloadHash;
            }
            async function validateEvent2(event, url, method, body) {
                if (!verifyEvent(event)) {
                    throw new Error("Invalid nostr event, signature invalid");
                }
                if (!validateEventKind(event)) {
                    throw new Error("Invalid nostr event, kind invalid");
                }
                if (!validateEventTimestamp(event)) {
                    throw new Error("Invalid nostr event, created_at timestamp invalid");
                }
                if (!validateEventUrlTag(event, url)) {
                    throw new Error("Invalid nostr event, url tag invalid");
                }
                if (!validateEventMethodTag(event, method)) {
                    throw new Error("Invalid nostr event, method tag invalid");
                }
                if (Boolean(body) && typeof body === "object" && Object.keys(body).length > 0) {
                    if (!validateEventPayloadTag(event, body)) {
                        throw new Error("Invalid nostr event, payload tag does not match request body hash");
                    }
                }
                return true;
            }
            return __toCommonJS(nostr_tools_exports);
        })();
    </script>

    <!-- NYM app-->
    <script>
        // Guided Tutorial
        (function () {
            const state = {
                steps: [],
                idx: 0,
                started: false,
                overlay: null,
                card: null,
                highlight: null,
                elTitle: null,
                elBody: null,
                elProgress: null,
                btnPrev: null,
                btnNext: null,
                btnSkip: null,
                sidebarInitiallyOpen: null,
                _onResize: null,
                _onScroll: null
            };

            function $(sel) { return document.querySelector(sel); }

            function buildSteps() {
                state.steps = [
                    {
                        title: 'NYM Tutorial',
                        body: 'Take a quick tour so you know what’s where. You can skip anytime. And use the /help command in any channel to learn more.',
                        selector: null
                    },
                    {
                        title: 'Your Nym',
                        body: 'Tap here to edit your nickname for this session.',
                        selector: '.nym-display',
                        onBefore: ensureSidebarOpenOnMobile
                    },
                    {
                        title: 'Connection',
                        body: 'The current relay connection status.',
                        selector: '.status-indicator',
                        onBefore: ensureSidebarOpenOnMobile
                    },
                    {
                        title: 'Main Menu',
                        body: 'Create or join a channel. Edit settings such as sorting geohash channels by proximity, adding a Bitcoin lightning address, changing the app\'s theme, manage blocked users and keywords, and more. Logout to terminate session and start anew.',
                        selector: (window.innerWidth > 768 ? '.header-actions' : '.sidebar-actions'),
                        onBefore: () => { if (window.innerWidth <= 768) return ensureSidebarOpenOnMobile(); }
                    },
                    {
                        title: 'Channels',
                        body: 'Browse and switch channels. Each channel type is denoted by a unique, colorful badge (Ephemeral is blue, Geohash is yellow, Public community is green, and Private community is pink). Use the search or "+ Channel" button in menu to join or create. Note: only users who used a Nostr login method can view public/private communities.',
                        selector: '#channelList',
                        onBefore: ensureSidebarOpenOnMobile
                    },
                    {
                        title: 'Explore Geohash',
                        body: 'Tap the globe to explore geohash channels on a 3D globe.',
                        selector: '.discover-icon',
                        onBefore: ensureSidebarOpenOnMobile
                    },
                    {
                        title: 'Private Messages',
                        body: 'Your one‑on‑one, end-to-end encrypted messages live here.',
                        selector: '#pmList',
                        onBefore: ensureSidebarOpenOnMobile
                    },
                    {
                        title: 'Active Nyms',
                        body: 'See who is currently active. Tap a nym to PM them.',
                        selector: '#userList',
                        onBefore: ensureSidebarOpenOnMobile
                    },
                    {
                        title: 'Messages',
                        body: 'Channel messages appear here. Tap a nym\'s nickname for quick actions such as to react with emoji, zap Bitcoin, PM, mention, block and more from the context menu.',
                        selector: '#messagesContainer',
                        onBefore: ensureSidebarClosedOnMobile
                    },
                    {
                        title: 'Compose',
                        body: 'Type your message, add emoji or upload an image, then SEND. Markdown is supported. You can also type commands for other actions, such as creating an away message and many more.',
                        selector: '.input-container'
                    },
                    {
                        title: 'Share',
                        body: 'Invite others to a channel with a shareable link.',
                        selector: '#shareChannelBtn'
                    },
                    {
                        title: 'All set!',
                        body: 'That\'s it. Enjoy NYM! Check out all of the available commands by typing the /help command in any channel.',
                        selector: null,
                        final: true
                    }
                ];
            }

            function ensureSidebarOpenOnMobile() {
                if (window.innerWidth > 768) return Promise.resolve();

                const sidebar = $('#sidebar');
                const overlay = $('#mobileOverlay');
                if (!sidebar) return Promise.resolve();

                // Already open
                if (sidebar.classList.contains('open')) return Promise.resolve();

                // Open it and wait for transition to complete
                sidebar.classList.add('open');
                overlay && overlay.classList.add('active');

                return new Promise((resolve) => {
                    let settled = false;

                    const done = () => {
                        if (settled) return;
                        settled = true;
                        sidebar.removeEventListener('transitionend', onEnd);
                        clearTimeout(timer);
                        // small delay to allow layout to settle before measuring
                        setTimeout(() => resolve(), 30);
                    };

                    const onEnd = (e) => {
                        if (e.propertyName === 'transform') {
                            done();
                        }
                    };

                    sidebar.addEventListener('transitionend', onEnd, { once: true });
                    // Fallback timeout in case transitionend doesn’t fire
                    const timer = setTimeout(done, 400);
                });
            }

            // Close the sidebar on mobile and wait for transition
            function ensureSidebarClosedOnMobile() {
                if (window.innerWidth > 768) return Promise.resolve();

                const sidebar = $('#sidebar');
                const overlay = $('#mobileOverlay');
                if (!sidebar) return Promise.resolve();

                // Already closed
                if (!sidebar.classList.contains('open')) {
                    overlay && overlay.classList.remove('active');
                    return Promise.resolve();
                }

                // Close it and wait for transition to complete
                sidebar.classList.remove('open');
                overlay && overlay.classList.remove('active');

                return new Promise((resolve) => {
                    let settled = false;

                    const done = () => {
                        if (settled) return;
                        settled = true;
                        sidebar.removeEventListener('transitionend', onEnd);
                        clearTimeout(timer);
                        // small delay to allow layout to settle before measuring
                        setTimeout(() => resolve(), 30);
                    };

                    const onEnd = (e) => {
                        if (e.propertyName === 'transform') {
                            done();
                        }
                    };

                    sidebar.addEventListener('transitionend', onEnd, { once: true });
                    // Fallback timeout
                    const timer = setTimeout(done, 400);
                });
            }

            function restoreSidebarAfterTutorial() {
                if (window.innerWidth <= 768) {
                    const sidebar = $('#sidebar');
                    const overlay = $('#mobileOverlay');
                    if (!sidebar) return;

                    const initiallyOpen = !!state.sidebarInitiallyOpen;
                    const currentlyOpen = sidebar.classList.contains('open');

                    // Restore to the initial open/closed state
                    if (initiallyOpen && !currentlyOpen) {
                        sidebar.classList.add('open');
                        overlay && overlay.classList.add('active');
                    } else if (!initiallyOpen && currentlyOpen) {
                        sidebar.classList.remove('open');
                        overlay && overlay.classList.remove('active');
                    }
                }
            }

            function getTargetEl(step) {
                if (!step.selector) return null;
                if (typeof step.selector === 'function') {
                    const resolvedSelector = step.selector();
                    return resolvedSelector ? $(resolvedSelector) : null;
                }
                return $(step.selector) || null;
            }

            function positionStep() {
                const step = state.steps[state.idx];
                const target = getTargetEl(step);
                const highlight = state.highlight;
                const card = state.card;

                // Reset display
                highlight.style.display = 'none';

                // If there is a target, try to highlight and position near it
                if (target && target.getBoundingClientRect) {
                    const rect = target.getBoundingClientRect();

                    // If target is off-screen, scroll into view then re-position
                    const fullyOutVert = rect.bottom < 0 || rect.top > window.innerHeight;
                    const fullyOutHorz = rect.right < 0 || rect.left > window.innerWidth;
                    if (fullyOutVert || fullyOutHorz) {
                        try {
                            target.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                        } catch (_) { }
                        setTimeout(positionStep, 250);
                        return;
                    }

                    const pad = 8;
                    const hlLeft = Math.max(8, rect.left - pad);
                    const hlTop = Math.max(8, rect.top - pad);
                    const hlWidth = Math.min(window.innerWidth - hlLeft - 8, rect.width + pad * 2);
                    const hlHeight = Math.min(window.innerHeight - hlTop - 8, rect.height + pad * 2);

                    highlight.style.display = 'block';
                    highlight.style.left = `${hlLeft}px`;
                    highlight.style.top = `${hlTop}px`;
                    highlight.style.width = `${hlWidth}px`;
                    highlight.style.height = `${hlHeight}px`;

                    // Place card relative to target
                    card.style.visibility = 'hidden';
                    card.style.left = '12px';
                    card.style.top = '12px';

                    // Wait a frame to measure
                    requestAnimationFrame(() => {
                        const cRect = card.getBoundingClientRect();
                        const spaceBelow = window.innerHeight - rect.bottom;
                        const spaceAbove = rect.top;

                        let top;
                        if (spaceBelow > cRect.height + 16) {
                            top = rect.bottom + 12;
                        } else if (spaceAbove > cRect.height + 16) {
                            top = rect.top - cRect.height - 12;
                        } else {
                            // fallback: bottom area
                            top = Math.min(window.innerHeight - cRect.height - 12, Math.max(12, rect.bottom + 12));
                        }

                        let left = rect.left + (rect.width - cRect.width) / 2;
                        left = Math.max(12, Math.min(left, window.innerWidth - cRect.width - 12));

                        card.style.left = `${left}px`;
                        card.style.top = `${top}px`;
                        card.style.visibility = 'visible';
                    });
                } else {
                    // Center the card for generic/welcome/final steps
                    highlight.style.display = 'none';
                    card.style.visibility = 'hidden';
                    requestAnimationFrame(() => {
                        const cRect = card.getBoundingClientRect();
                        const left = Math.max(12, (window.innerWidth - cRect.width) / 2);
                        const top = Math.max(12, (window.innerHeight - cRect.height) / 2);
                        card.style.left = `${left}px`;
                        card.style.top = `${top}px`;
                        card.style.visibility = 'visible';
                    });
                }
            }

            function renderStep() {
                const step = state.steps[state.idx];

                const updateAndPosition = () => {
                    state.elTitle.textContent = step.title || 'NYM';
                    state.elBody.textContent = step.body || '';
                    state.elProgress.textContent = `Step ${state.idx + 1} of ${state.steps.length}`;

                    state.btnPrev.disabled = state.idx === 0;
                    state.btnNext.textContent = (step.final || state.idx === state.steps.length - 1) ? 'Done' : 'Next';

                    positionStep();
                };

                if (step.onBefore && typeof step.onBefore === 'function') {
                    try {
                        const maybe = step.onBefore();
                        if (maybe && typeof maybe.then === 'function') {
                            return maybe.then(updateAndPosition);
                        }
                    } catch (_) {
                        // fall through to update
                    }
                }
                updateAndPosition();
            }

            function nextStep() {
                const last = state.steps.length - 1;
                if (state.idx >= last) {
                    endTutorial(true);
                    return;
                }
                state.idx++;
                // Skip steps if target not found
                skipIfTargetMissingForward();
            }

            function prevStep() {
                if (state.idx <= 0) {
                    renderStep();
                    return;
                }
                state.idx--;
                skipIfTargetMissingBackward();
            }

            function skipIfTargetMissingForward() {
                // Move forward to first step that has a valid target (or no selector)
                let guard = 0;
                while (guard++ < state.steps.length) {
                    const step = state.steps[state.idx];
                    const target = getTargetEl(step);
                    if (!step.selector || (target && target.getBoundingClientRect)) break;
                    if (state.idx >= state.steps.length - 1) break;
                    state.idx++;
                }
                renderStep();
            }

            function skipIfTargetMissingBackward() {
                // Move backward to first step that has a valid target (or no selector)
                let guard = 0;
                while (guard++ < state.steps.length) {
                    const step = state.steps[state.idx];
                    const target = getTargetEl(step);
                    if (!step.selector || (target && target.getBoundingClientRect)) break;
                    if (state.idx <= 0) break;
                    state.idx--;
                }
                renderStep();
            }

            function startTutorial() {
                if (state.started) return;
                // Don’t start while the initial setup modal is open
                const setupActive = document.getElementById('setupModal')?.classList.contains('active');
                if (setupActive) return;

                buildSteps();

                state.overlay = document.getElementById('tutorialOverlay');
                state.card = document.getElementById('tutorialCard');
                state.highlight = document.getElementById('tutorialHighlight');
                state.elTitle = document.getElementById('tutorialTitle');
                state.elBody = document.getElementById('tutorialBody');
                state.elProgress = document.getElementById('tutorialProgress');
                state.btnPrev = document.getElementById('tutorialPrevBtn');
                state.btnNext = document.getElementById('tutorialNextBtn');
                state.btnSkip = document.getElementById('tutorialSkipBtn');

                state.sidebarInitiallyOpen = document.getElementById('sidebar')?.classList.contains('open');

                state.overlay.classList.add('active');
                state.overlay.style.display = 'flex';
                state.started = true;
                state.idx = 0;

                // Wire events
                state.btnPrev.onclick = prevStep;
                state.btnNext.onclick = () => {
                    const isFinal = state.idx === state.steps.length - 1 || state.steps[state.idx].final;
                    if (isFinal) endTutorial(true);
                    else nextStep();
                };
                state.btnSkip.onclick = () => endTutorial(true);
                state._onResize = () => positionStep();
                state._onScroll = () => positionStep();
                window.addEventListener('resize', state._onResize);
                window.addEventListener('scroll', state._onScroll, true);
                document.addEventListener('keydown', keyHandler);

                renderStep();
            }

            function keyHandler(e) {
                if (!state.started) return;
                if (e.key === 'Escape') {
                    endTutorial(true);
                } else if (e.key === 'ArrowRight' || e.key === 'Enter') {
                    state.btnNext.click();
                } else if (e.key === 'ArrowLeft') {
                    state.btnPrev.click();
                }
            }

            function endTutorial(markSeen) {
                // Hide
                state.overlay?.classList.remove('active');
                if (state.overlay) state.overlay.style.display = 'none';
                if (state.highlight) state.highlight.style.display = 'none';

                // Save flag
                if (markSeen) {
                    try { localStorage.setItem('nym_tutorial_seen', 'true'); } catch (_) { }
                }

                // Clean up
                window.removeEventListener('resize', state._onResize);
                window.removeEventListener('scroll', state._onScroll, true);
                document.removeEventListener('keydown', keyHandler);

                restoreSidebarAfterTutorial();

                state.started = false;
            }

            // Expose helper to app
            window.maybeStartTutorial = function (force = false) {
                try {
                    if (!force) {
                        const seen = localStorage.getItem('nym_tutorial_seen') === 'true';
                        if (seen) return;
                    }
                    // Delay a bit to let UI settle after login/restore
                    setTimeout(() => startTutorial(), 300);
                } catch (_) {
                    setTimeout(() => startTutorial(), 300);
                }
            };
        })();

        // NYM - Ephemeral Nostr Chat
        class NYM {
            constructor() {
                this.relayPool = new Map();
                this.blacklistedRelays = new Set();
                this.relayKinds = new Map();
                this.relayVerificationTimeout = 10000;
                this.monitorRelays = ['wss://relay.nostr.watch', 'wss://monitorlizard.nostr1.com'];
                this.broadcastRelays = [
                    'wss://relay.damus.io',
                    'wss://offchain.pub',
                    'wss://relay.primal.net',
                    'wss://nos.lol',
                    'wss://nostr21.com',
                    'wss://sendit.nosflare.com',
                    'wss://a.nos.lol',
                    'wss://adre.su',
                    'wss://alien.macneilmediagroup.com',
                    'wss://articles.layer3.news',
                    'wss://black.nostrcity.club',
                    'wss://bostr.bitcointxoko.com',
                    'wss://bostr.shop',
                    'wss://bostr.syobon.net',
                    'wss://bucket.coracle.social',
                    'wss://chorus.pjv.me',
                    'wss://communities.nos.social',
                    'wss://cyberspace.nostr1.com',
                    'wss://dev-nostr.bityacht.io',
                    'wss://dev-relay.lnfi.network',
                    'wss://fanfares.nostr1.com',
                    'wss://freelay.sovbit.host',
                    'wss://gnostr.com',
                    'wss://inbox.azzamo.net',
                    'wss://ithurtswhenip.ee',
                    'wss://khatru.nostrver.se',
                    'wss://kitchen.zap.cooking',
                    'wss://knostr.neutrine.com',
                    'wss://librerelay.aaroniumii.com',
                    'wss://multiplexer.huszonegy.world',
                    'wss://n.ok0.org',
                    'wss://no.str.cr',
                    'wss://nostrelites.org',
                    'wss://nostr-01.yakihonne.com',
                    'wss://nostr-02.dorafactory.org',
                    'wss://nostr-02.yakihonne.com',
                    'wss://nostr-03.dorafactory.org',
                    'wss://nostr-1.nbo.angani.co',
                    'wss://nostr-2.21crypto.ch',
                    'wss://nostr-dev.wellorder.net',
                    'wss://nostr-pub.wellorder.net',
                    'wss://nostr-relay-1.trustlessenterprise.com',
                    'wss://nostr-relay.amethyst.name',
                    'wss://nostr-relay.cbrx.io',
                    'wss://nostr-relay.moe.gift',
                    'wss://nostr-relay.online',
                    'wss://nostr-relay.psfoundation.info',
                    'wss://nostr-relay.schnitzel.world',
                    'wss://nostr-relay.shirogaku.xyz',
                    'wss://nostr-relay.zimage.com',
                    'wss://nostr-rs-relay-ishosta.phamthanh.me',
                    'wss://nostr-rs-relay.dev.fedibtc.com',
                    'wss://nostr-verif.slothy.win',
                    'wss://nostr-verified.wellorder.net',
                    'wss://nostr.0x7e.xyz',
                    'wss://nostr.21crypto.ch',
                    'wss://nostr.2b9t.xyz',
                    'wss://nostr.4rs.nl',
                    'wss://nostr.agentcampfire.com',
                    'wss://nostr.azzamo.net',
                    'wss://nostr.bilthon.dev',
                    'wss://nostr.blankfors.se',
                    'wss://nostr.camalolo.com',
                    'wss://nostr.carroarmato0.be',
                    'wss://nostr.chaima.info',
                    'wss://nostr.coincards.com',
                    'wss://nostr.coincrowd.fund',
                    'wss://nostr.community.ath.cx',
                    'wss://nostr.data.haus',
                    'wss://nostr.dbtc.link',
                    'wss://nostr.easydns.ca',
                    'wss://nostr.einundzwanzig.space',
                    'wss://nostr.excentered.com',
                    'wss://nostr.fbxl.net',
                    'wss://nostr.hekster.org',
                    'wss://nostr.hifish.org',
                    'wss://nostr.hoppe-relay.it.com',
                    'wss://nostr.huszonegy.world',
                    'wss://nostr.jfischer.org',
                    'wss://nostr.kalf.org',
                    'wss://nostr.kungfu-g.rip',
                    'wss://nostr.l484.com',
                    'wss://nostr.liberty.fans',
                    'wss://nostr.lojong.info',
                    'wss://nostr.makibisskey.work',
                    'wss://nostr.massmux.com',
                    'wss://nostr.middling.mydns.jp',
                    'wss://nostr.mom',
                    'wss://nostr.myshosholoza.co.za',
                    'wss://nostr.n7ekb.net',
                    'wss://nostr.namek.link',
                    'wss://nostr.night7.space',
                    'wss://nostr.nodeofsven.com',
                    'wss://nostr.notribe.net',
                    'wss://nostr.novacisko.cz',
                    'wss://nostr.now',
                    'wss://nostr.overmind.lol',
                    'wss://nostr.oxtr.dev',
                    'wss://nostr.plantroon.com',
                    'wss://nostr.prl.plus',
                    'wss://nostr.rblb.it',
                    'wss://nostr.red5d.dev',
                    'wss://nostr.rikmeijer.nl',
                    'wss://nostr.rohoss.com',
                    'wss://nostr.roundrockbitcoiners.com',
                    'wss://nostr.rtvslawenia.com',
                    'wss://nostr.sagaciousd.com',
                    'wss://nostr.sathoarder.com',
                    'wss://nostr.satstralia.com',
                    'wss://nostr.slothy.win',
                    'wss://nostr.smut.cloud',
                    'wss://nostr.spaceshell.xyz',
                    'wss://nostr.spicyz.io',
                    'wss://nostr.stakey.net',
                    'wss://nostr.tac.lol',
                    'wss://nostr.tadryanom.me',
                    'wss://nostr.tavux.tech',
                    'wss://nostr.tegila.com.br',
                    'wss://nostr.thaliyal.com',
                    'wss://nostr.thebiglake.org',
                    'wss://nostr.veladan.dev',
                    'wss://nostr.vulpem.com',
                    'wss://nostr.yael.at',
                    'wss://nostr.zenon.network',
                    'wss://nostrelay.circum.space',
                    'wss://nostrelay.memory-art.xyz',
                    'wss://nostrja-kari.heguro.com',
                    'wss://nostrue.com',
                    'wss://noxir.kpherox.dev',
                    'wss://nproxy.kristapsk.lv',
                    'wss://orangepiller.org',
                    'wss://orangesync.tech',
                    'wss://portal-relay.pareto.space',
                    'wss://premium.primal.net',
                    'wss://prl.plus',
                    'wss://promenade.fiatjaf.com',
                    'wss://purplerelay.com',
                    'wss://pyramid.fiatjaf.com',
                    'wss://r.bitcoinhold.net',
                    'wss://relay-admin.thaliyal.com',
                    'wss://relay-dev.satlantis.io',
                    'wss://relay-rpi.edufeed.org',
                    'wss://relay-testnet.k8s.layer3.news',
                    'wss://relay.13room.space',
                    'wss://relay.21e6.cz',
                    'wss://relay.agorist.space',
                    'wss://relay.angor.io',
                    'wss://relay.anzenkodo.workers.dev',
                    'wss://relay.artiostr.ch',
                    'wss://relay.artx.market',
                    'wss://relay.arx-ccn.com',
                    'wss://relay.bankless.at',
                    'wss://relay.barine.co',
                    'wss://relay.bitcoinartclock.com',
                    'wss://relay.bitcoinveneto.org',
                    'wss://relay.bullishbounty.com',
                    'wss://relay.chakany.systems',
                    'wss://relay.chorus.community',
                    'wss://relay.coinos.io',
                    'wss://relay.conduit.market',
                    'wss://relay.copylaradio.com',
                    'wss://relay.cosmicbolt.net',
                    'wss://relay.credenso.cafe',
                    'wss://relay.cypherflow.ai',
                    'wss://relay.davidebtc.me',
                    'wss://relay.degmods.com',
                    'wss://relay.digitalezukunft.cyou',
                    'wss://relay.dwadziesciajeden.pl',
                    'wss://relay.etch.social',
                    'wss://relay.evanverma.com',
                    'wss://relay.fountain.fm',
                    'wss://relay.fr13nd5.com',
                    'wss://relay.freeplace.nl',
                    'wss://relay.froth.zone',
                    'wss://relay.g1sms.fr',
                    'wss://relay.getsafebox.app',
                    'wss://relay.goodmorningbitcoin.com',
                    'wss://relay.hasenpfeffr.com',
                    'wss://relay.hivetalk.org',
                    'wss://relay.hodl.ar',
                    'wss://relay.holzeis.me',
                    'wss://relay.illuminodes.com',
                    'wss://relay.javi.space',
                    'wss://relay.jeffg.fyi',
                    'wss://relay.laantungir.net',
                    'wss://relay.letsfo.com',
                    'wss://relay.lexingtonbitcoin.org',
                    'wss://relay.lnfi.network',
                    'wss://relay.lumina.rocks',
                    'wss://relay.magiccity.live',
                    'wss://relay.mattybs.lol',
                    'wss://relay.mccormick.cx',
                    'wss://relay.mess.ch',
                    'wss://relay.minibolt.info',
                    'wss://relay.mostro.network',
                    'wss://relay.mwaters.net',
                    'wss://relay.netstr.io',
                    'wss://relay.nosto.re',
                    'wss://relay.nostr.band',
                    'wss://relay.nostr.com.au',
                    'wss://relay.nostr.net',
                    'wss://relay.nostr.wirednet.jp',
                    'wss://relay.nostrcal.com',
                    'wss://relay.nostrcheck.me',
                    'wss://relay.nostrdice.com',
                    'wss://relay.nostrhub.fr',
                    'wss://relay.nostrhub.tech',
                    'wss://relay.nostriot.com',
                    'wss://relay.nostromo.social',
                    'wss://relay.nostx.io',
                    'wss://relay.notoshi.win',
                    'wss://relay.nsnip.io',
                    'wss://relay.oldenburg.cool',
                    'wss://relay.orangepill.ovh',
                    'wss://relay.puresignal.news',
                    'wss://relay.ru.ac.th',
                    'wss://relay.satlantis.io',
                    'wss://relay.satsdays.com',
                    'wss://relay.siamdev.cc',
                    'wss://relay.sigit.io',
                    'wss://relay.sincensura.org',
                    'wss://relay.stream.labs.h3.se',
                    'wss://relay.tagayasu.xyz',
                    'wss://relay.tapestry.ninja',
                    'wss://relay.toastr.net',
                    'wss://relay.usefusion.ai',
                    'wss://relay.utxo.farm',
                    'wss://relay.varke.eu',
                    'wss://relay.verified-nostr.com',
                    'wss://relay.vrtmrz.net',
                    'wss://relay.wavefunc.live',
                    'wss://relay.wavlake.com',
                    'wss://relay.wellorder.net',
                    'wss://relay.wolfcoil.com',
                    'wss://relay.zone667.com',
                    'wss://relay01.lnfi.network',
                    'wss://relay02.lnfi.network',
                    'wss://relay03.lnfi.network',
                    'wss://relay04.lnfi.network',
                    'wss://relay1.nostrchat.io',
                    'wss://relay2.angor.io',
                    'wss://relay2.nostrchat.io',
                    'wss://relay5.bitransfer.org',
                    'wss://relayone.geektank.ai',
                    'wss://relayone.soundhsa.com',
                    'wss://relayrs.notoshi.win',
                    'wss://rn1.sotiras.org',
                    'wss://santo.iguanatech.net',
                    'wss://satsage.xyz',
                    'wss://schnorr.me',
                    'wss://slick.mjex.me',
                    'wss://social.proxymana.net',
                    'wss://soloco.nl',
                    'wss://srtrelay.c-stellar.net',
                    'wss://strfry.bonsai.com',
                    'wss://strfry.felixzieger.de',
                    'wss://strfry.openhoofd.nl',
                    'wss://strfry.shock.network',
                    'wss://temp.iris.to',
                    'wss://theoutpost.life',
                    'wss://tollbooth.stens.dev',
                    'wss://travis-shears-nostr-relay-v2.fly.dev',
                    'wss://vidono.apps.slidestr.net',
                    'wss://vitor.nostr1.com',
                    'wss://wheat.happytavern.co',
                    'wss://wot.brightbolt.net',
                    'wss://wot.codingarena.top',
                    'wss://wot.downisontheup.ca',
                    'wss://wot.dtonon.com',
                    'wss://wot.geektank.ai',
                    'wss://wot.nostr.net',
                    'wss://wot.nostr.party',
                    'wss://wot.nostr.place',
                    'wss://wot.sebastix.social',
                    'wss://wot.soundhsa.com',
                    'wss://wot.sudocarlos.com',
                    'wss://x.kojira.io',
                    'wss://zap.watch'
                ];
                this.discoveredRelays = new Set();
                this.relayList = [];
                this.lastRelayDiscovery = 0;
                this.relayDiscoveryInterval = 300000;
                this.maxRelaysForReq = 1000;
                this.relayTimeout = 2000;
                this.eventDeduplication = new Map();
                this.reconnectingRelays = new Set();
                this.blacklistedRelays = new Set();
                this.blacklistTimestamps = new Map();
                this.blacklistDuration = 600000;
                this.pubkey = null;
                this.privkey = null;
                this.nym = null;
                this.connectionMode = 'ephemeral';
                this.originalProfile = null;
                this.currentChannel = 'bar';
                this.currentGeohash = '';
                this.currentPM = null;
                this.messages = new Map();
                this.pmMessages = new Map();
                this.users = new Map();
                this.channelUsers = new Map();
                this.channels = new Map();
                this.pmConversations = new Map();
                this.unreadCounts = new Map();
                this.blockedUsers = new Set();
                this.blockedKeywords = new Set();
                this.blockedChannels = new Set();
                this.communityChannels = new Map();
                this.ownedCommunities = new Set();
                this.moderatedCommunities = new Set();
                this.communityBans = new Map();
                this.communityInvites = new Map();
                this.communityMembers = new Map();
                this.communityModerators = new Map();
                this.currentCommunity = null;
                this.processedModerationEvents = new Set();
                this.settings = this.loadSettings();
                this.commandHistory = [];
                this.historyIndex = -1;
                this.connected = false;
                this.messageQueue = [];
                this.autocompleteIndex = -1;
                this.commandPaletteIndex = -1;
                this.emojiAutocompleteIndex = -1;
                this.commonChannels = ['bar', 'random', 'nostr', 'bitcoin', 'tech', 'music', 'gaming', 'anime', 'memes', 'news', 'politics', 'science', 'art', 'food', 'sports'];
                this.commonGeohashes = ['w1', 'w2', 'dr5r', '9q8y', 'u4pr', 'gcpv', 'f2m6', 'xn77', 'tjm5'];
                this.userJoinedChannels = new Set(this.loadUserJoinedChannels());
                this.inPMMode = false;
                this.userSearchTerm = '';
                this.geohashRegex = /^[0-9bcdefghjkmnpqrstuvwxyz]{1,12}$/;
                this.pinnedChannels = new Set();
                this.reactions = new Map();
                this.failedRelays = new Map();
                this.relayRetryDelay = 15 * 60 * 1000;
                this.floodTracking = new Map();
                this.activeReactionPicker = null;
                this.activeReactionPickerButton = null;
                this.usingExtension = false;
                this.contextMenuTarget = null;
                this.contextMenuData = null;
                this.awayMessages = new Map();
                this.recentEmojis = [];
                this.allEmojis = {
                    'smileys': ['😊', '😂', '🤣', '😍', '🥰', '😘', '😎', '🤔', '😢', '😭', '😡', '🤬', '😱', '😨', '😰', '😥', '😓', '🤗', '🤭', '🤫', '🤥', '😶', '😐', '😑', '😬', '🙄', '😯', '😦', '😧', '😮', '😲', '🥱', '😴', '🤤', '😪', '😵', '🤐', '🥴', '🤢', '🤮', '🤧', '😷', '🤒', '🤕', '🤑', '🤠', '😈', '👿', '👹', '👺', '🤡', '💩', '👻', '💀', '☠️', '👽', '👾', '🤖', '🎃', '😺', '😸', '😹', '😻', '😼', '😽', '🙀', '😿', '😾'],
                    'gestures': ['👍', '👎', '👌', '✌️', '🤞', '🤟', '🤘', '🤙', '👈', '👉', '👆', '👇', '☝️', '✋', '🤚', '🖐️', '🖖', '👋', '🤏', '✍️', '👏', '🙌', '👐', '🤲', '🤝', '🙏', '💪', '🦾', '🦿', '🦵', '🦶', '👂', '🦻', '👃', '🧠', '🦷', '🦴', '👀', '👁️', '👅', '👄', '💋'],
                    'hearts': ['❤️', '🧡', '💛', '💚', '💙', '💜', '🖤', '🤍', '🤎', '💔', '❣️', '💕', '💞', '💓', '💗', '💖', '💘', '💝', '💟', '☮️', '✝️', '☪️', '🕉️', '☸️', '✡️', '🔯', '🕎', '☯️', '☦️', '🛐', '⛎', '♈', '♉', '♊', '♋', '♌', '♍', '♎', '♏', '♐', '♑', '♒', '♓'],
                    'symbols': ['💯', '💢', '💥', '💫', '💦', '💨', '🕳️', '💣', '💬', '👁️‍🗨️', '🗨️', '🗯️', '💭', '💤', '✨', '🌟', '💫', '⭐', '🌠', '🔥', '💥', '☄️', '🎆', '🎇', '🎈', '🎉', '🎊', '🎋', '🎍', '🎎', '🎏', '🎐', '🎑', '🧧', '🎀', '🎁', '🎗️', '🎟️', '🎫'],
                    'objects': ['⌚', '📱', '📲', '💻', '⌨️', '🖥️', '🖨️', '🖱️', '🖲️', '🕹️', '🗜️', '💽', '💾', '💿', '📀', '📼', '📷', '📸', '📹', '🎥', '📽️', '🎞️', '📞', '☎️', '📟', '📠', '📺', '📻', '🎙️', '🎚️', '🎛️', '⏱️', '⏲️', '⏰', '🕰️', '⌛', '⏳', '📡', '🔋', '🔌', '💡', '🔦', '🕯️', '🗑️', '🛢️', '💸', '💵', '💴', '💶', '💷', '💰', '💳', '🧾', '💎', '⚖️', '🔧', '🔨', '⚒️', '🛠️', '⛏️', '🔩', '⚙️', '⛓️', '🔫', '💣', '🔪', '🗡️', '⚔️', '🛡️', '🚬', '⚰️', '⚱️', '🏺', '🔮', '📿', '💈', '⚗️', '🔭', '🔬', '🕳️', '💊', '💉', '🩸', '🩹', '🩺', '🌡️', '🏷️', '🔖', '🚿', '🛁', '🛀', '🚰', '🚽', '🧻', '🧼', '🧽', '🧴', '🪒', '🧹', '🧺', '🔑', '🗝️', '🛏️', '🛋️', '🚪', '🪑', '🚿', '🛁', '🛀', '🧴', '🧷', '🧹', '🧺', '🧻', '🧼', '🧽', '🧯', '🛒', '🚬', '⚰️', '⚱️', '🗿'],
                    'food': ['🍏', '🍎', '🍐', '🍊', '🍋', '🍌', '🍉', '🍇', '🍓', '🍈', '🍒', '🍑', '🥭', '🍍', '🥥', '🥝', '🍅', '🍆', '🥑', '🥦', '🥬', '🥒', '🌶️', '🌽', '🥕', '🧄', '🧅', '🥔', '🍠', '🥐', '🥯', '🍞', '🥖', '🥨', '🧀', '🥚', '🍳', '🧈', '🥞', '🧇', '🥓', '🥩', '🍗', '🍖', '🦴', '🌭', '🍔', '🍟', '🍕', '🥪', '🥙', '🧆', '🌮', '🌯', '🥗', '🥘', '🥫', '🍝', '🍜', '🍲', '🍛', '🍣', '🍱', '🥟', '🦪', '🍤', '🍙', '🍚', '🍘', '🍥', '🥠', '🥮', '🍢', '🍡', '🍧', '🍨', '🍦', '🥧', '🧁', '🍰', '🎂', '🍮', '🍭', '🍬', '🍫', '🍿', '🍩', '🍪', '🌰', '🥜', '🍯', '🥛', '🍼', '☕', '🍵', '🧃', '🥤', '🍶', '🍺', '🍻', '🥂', '🍷', '🥃', '🍸', '🍹', '🧉', '🍾', '🧊'],
                    'activities': ['⚽', '🏀', '🏈', '⚾', '🥎', '🎾', '🏐', '🏉', '🥏', '🎱', '🪀', '🏓', '🏸', '🏒', '🏑', '🥍', '🏏', '🥅', '⛳', '🪁', '🏹', '🎣', '🤿', '🥊', '🥋', '🎽', '🛹', '🛷', '⛸️', '🥌', '🎿', '⛷️', '🏂', '🪂', '🏋️', '🤼', '🤸', '🤺', '🤾', '🏌️', '🏇', '🧘', '🏄', '🏊', '🤽', '🚣', '🧗', '🚴', '🚵', '🎪', '🎭', '🎨', '🎬', '🎤', '🎧', '🎼', '🎹', '🥁', '🎷', '🎺', '🎸', '🪕', '🎻', '🎲', '♟️', '🎯', '🎳', '🎮', '🎰', '🧩'],
                    'nature': ['🐵', '🐒', '🦍', '🦧', '🐶', '🐕', '🦮', '🐕‍🦺', '🐩', '🐺', '🦊', '🦝', '🐱', '🐈', '🐈‍⬛', '🦁', '🐯', '🐅', '🐆', '🐴', '🐎', '🦄', '🦓', '🦌', '🦬', '🐮', '🐂', '🐃', '🐄', '🐷', '🐖', '🐗', '🐽', '🐏', '🐑', '🐐', '🐪', '🐫', '🦙', '🦒', '🐘', '🦣', '🦏', '🦛', '🐭', '🐁', '🐀', '🐹', '🐰', '🐇', '🐿️', '🦫', '🦔', '🦇', '🐻', '🐻‍❄️', '🐨', '🐼', '🦥', '🦦', '🦨', '🦘', '🦡', '🐾', '🦃', '🐔', '🐓', '🐣', '🐤', '🐥', '🐦', '🐧', '🕊️', '🦅', '🦆', '🦢', '🦉', '🦤', '🪶', '🦩', '🦚', '🦜', '🐸', '🐊', '🐢', '🦎', '🐍', '🐲', '🐉', '🦕', '🦖', '🐳', '🐋', '🐬', '🦭', '🐟', '🐠', '🐡', '🦈', '🐙', '🐚', '🐌', '🦋', '🐛', '🐜', '🐝', '🪲', '🐞', '🦗', '🪳', '🕷️', '🕸️', '🦂', '🦟', '🪰', '🪱', '🦠', '💐', '🌸', '💮', '🏵️', '🌹', '🥀', '🌺', '🌻', '🌼', '🌷', '🌱', '🪴', '🌲', '🌳', '🌴', '🌵', '🌾', '🌿', '☘️', '🍀', '🍁', '🍂', '🍃']
                };
                this.emojiMap = {
                    'smile': '😊', 'laugh': '😂', 'rofl': '🤣', 'love': '😍', 'heart_eyes': '🥰',
                    'kiss': '😘', 'cool': '😎', 'thinking': '🤔', 'cry': '😢', 'sob': '😭',
                    'angry': '😡', 'rage': '🤬', 'scream': '😱', 'fearful': '😨', 'anxious': '😰',
                    'sad': '😥', 'disappointed': '😓', 'hug': '🤗', 'shush': '🤭', 'quiet': '🤫',
                    'lying': '🤥', 'neutral': '😐', 'expressionless': '😑', 'grimace': '😬', 'eye_roll': '🙄',
                    'surprised': '😯', 'frowning': '😦', 'anguished': '😧', 'shocked': '😮', 'astonished': '😲',
                    'yawn': '🥱', 'sleeping': '😴', 'drool': '🤤', 'sleepy': '😪', 'dizzy': '😵',
                    'zipper': '🤐', 'woozy': '🥴', 'sick': '🤢', 'vomit': '🤮', 'sneeze': '🤧',
                    'mask': '😷', 'thermometer': '🤒', 'bandage': '🤕', 'money': '🤑', 'cowboy': '🤠',
                    'devil': '😈', 'imp': '👿', 'ogre': '👹', 'goblin': '👺', 'clown': '🤡',
                    'poop': '💩', 'ghost': '👻', 'skull': '💀', 'alien': '👽', 'robot': '🤖',
                    'jack': '🎃', 'cat_smile': '😺', 'cat_grin': '😸', 'cat_joy': '😹', 'cat_love': '😻',
                    'cat_smirk': '😼', 'cat_kiss': '😽', 'cat_scream': '🙀', 'cat_cry': '😿', 'cat_angry': '😾',
                    'thumbsup': '👍', 'thumbsdown': '👎', 'ok': '👌', 'peace': '✌️', 'crossed': '🤞',
                    'rock': '🤟', 'metal': '🤘', 'call': '🤙', 'left': '👈', 'right': '👉',
                    'up': '👆', 'down': '👇', 'point': '☝️', 'hand': '✋', 'backhand': '🤚',
                    'vulcan': '🖖', 'wave': '👋', 'pinch': '🤏', 'writing': '✍️', 'clap': '👏',
                    'raised': '🙌', 'open': '👐', 'palms': '🤲', 'handshake': '🤝', 'pray': '🙏',
                    'muscle': '💪', 'ear': '👂', 'nose': '👃', 'brain': '🧠', 'eyes': '👀',
                    'heart': '❤️', 'orange_heart': '🧡', 'yellow_heart': '💛', 'green_heart': '💚',
                    'blue_heart': '💙', 'purple_heart': '💜', 'black_heart': '🖤', 'white_heart': '🤍',
                    'brown_heart': '🤎', 'broken': '💔', 'exclamation_heart': '❣️', 'hearts': '💕',
                    'revolving': '💞', 'heartbeat': '💓', 'growing': '💗', 'sparkling': '💖',
                    'cupid': '💘', 'gift_heart': '💝', 'heart_decoration': '💟',
                    '100': '💯', 'boom': '💥', 'fire': '🔥', 'star': '⭐', 'sparkles': '✨',
                    'lightning': '⚡', 'warning': '⚠️', 'check': '✅', 'x': '❌', 'question': '❓',
                    'exclamation': '❗', 'bangbang': '‼️', 'interrobang': '⁉️', 'zzz': '💤',
                    'party': '🎉', 'tada': '🎊', 'gift': '🎁', 'trophy': '🏆', 'medal': '🥇',
                    'soccer': '⚽', 'baseball': '⚾', 'basketball': '🏀', 'football': '🏈', 'tennis': '🎾',
                    'volleyball': '🏐', 'rugby': '🏉', 'pool': '🎱', 'ping_pong': '🏓', 'badminton': '🏸',
                    'hockey': '🏒', 'golf': '⛳', 'fishing': '🎣', 'boxing': '🥊', 'martial_arts': '🥋',
                    'running': '🏃', 'walking': '🚶', 'cyclist': '🚴', 'mountain': '⛰️', 'camping': '🏕️',
                    'beach': '🏖️', 'sunrise': '🌅', 'sunset': '🌆', 'night': '🌃', 'stars': '🌟',
                    'rainbow': '🌈', 'sun': '☀️', 'moon': '🌙', 'cloud': '☁️', 'rain': '🌧️',
                    'snow': '❄️', 'snowman': '⛄', 'thunder': '⛈️', 'tornado': '🌪️', 'fog': '🌫️',
                    'apple': '🍎', 'banana': '🍌', 'strawberry': '🍓', 'cherry': '🍒', 'peach': '🍑',
                    'watermelon': '🍉', 'grapes': '🍇', 'lemon': '🍋', 'orange': '🍊', 'pineapple': '🍍',
                    'mango': '🥭', 'avocado': '🥑', 'broccoli': '🥦', 'corn': '🌽', 'carrot': '🥕',
                    'hot_pepper': '🌶️', 'potato': '🥔', 'bread': '🍞', 'cheese': '🧀', 'egg': '🥚',
                    'bacon': '🥓', 'hamburger': '🍔', 'fries': '🍟', 'pizza': '🍕', 'hotdog': '🌭',
                    'sandwich': '🥪', 'taco': '🌮', 'burrito': '🌯', 'sushi': '🍣', 'ramen': '🍜',
                    'spaghetti': '🍝', 'cake': '🎂', 'birthday': '🎂', 'pie': '🥧', 'donut': '🍩',
                    'cookie': '🍪', 'chocolate': '🍫', 'candy': '🍬', 'lollipop': '🍭', 'honey': '🍯',
                    'coffee': '☕', 'tea': '🍵', 'beer': '🍺', 'beers': '🍻', 'wine': '🍷',
                    'cocktail': '🍸', 'tropical': '🍹', 'champagne': '🍾', 'sake': '🍶', 'milk': '🥛',
                    'computer': '💻', 'desktop': '🖥️', 'printer': '🖨️', 'keyboard': '⌨️', 'mouse': '🖱️',
                    'trackball': '🖲️', 'joystick': '🕹️', 'cd': '💿', 'dvd': '📀', 'vhs': '📼',
                    'camera': '📷', 'video': '📹', 'movie': '🎥', 'phone': '📱', 'telephone': '☎️',
                    'tv': '📺', 'radio': '📻', 'speaker': '🔊', 'mute': '🔇', 'bell': '🔔',
                    'alarm': '⏰', 'stopwatch': '⏱️', 'timer': '⏲️', 'clock': '🕐', 'hourglass': '⌛',
                    'mag': '🔍', 'bulb': '💡', 'flashlight': '🔦', 'candle': '🕯️', 'book': '📖',
                    'books': '📚', 'newspaper': '📰', 'scroll': '📜', 'memo': '📝', 'pencil': '✏️',
                    'pen': '🖊️', 'paintbrush': '🖌️', 'crayon': '🖍️', 'scissors': '✂️', 'pushpin': '📌',
                    'paperclip': '📎', 'link': '🔗', 'chains': '⛓️', 'lock': '🔒', 'unlock': '🔓',
                    'key': '🔑', 'hammer': '🔨', 'axe': '🪓', 'pick': '⛏️', 'wrench': '🔧',
                    'screwdriver': '🪛', 'gear': '⚙️', 'clamp': '🗜️', 'balance': '⚖️', 'magnet': '🧲',
                    'ladder': '🪜', 'test_tube': '🧪', 'petri': '🧫', 'dna': '🧬', 'microscope': '🔬',
                    'telescope': '🔭', 'satellite': '📡', 'syringe': '💉', 'pill': '💊', 'adhesive': '🩹',
                    'stethoscope': '🩺', 'thermometer_face': '🌡️', 'broom': '🧹', 'basket': '🧺', 'roll': '🧻',
                    'soap': '🧼', 'sponge': '🧽', 'bucket': '🪣', 'toothbrush': '🪥',
                    'gaming': '🎮', 'dice': '🎲', 'dart': '🎯', 'bowling': '🎳', 'slot': '🎰',
                    'puzzle': '🧩', 'teddy': '🧸', 'spades': '♠️', 'hearts_suit': '♥️', 'diamonds': '♦️',
                    'clubs': '♣️', 'chess': '♟️', 'mahjong': '🀄',
                    'car': '🚗', 'taxi': '🚕', 'bus': '🚌', 'truck': '🚚', 'racing': '🏎️',
                    'ambulance': '🚑', 'firetruck': '🚒', 'police': '🚓', 'motorcycle': '🏍️', 'bike': '🚲',
                    'scooter': '🛴', 'skateboard': '🛹', 'train': '🚆', 'metro': '🚇', 'tram': '🚊',
                    'monorail': '🚝', 'railway': '🚞', 'helicopter': '🚁', 'airplane': '✈️', 'rocket': '🚀',
                    'ufo': '🛸', 'ship': '🚢', 'boat': '⛵', 'speedboat': '🚤', 'anchor': '⚓',
                    'shrug': '🤷', 'facepalm': '🤦', 'celebrate': '🙌', 'mind_blown': '🤯',
                    'money_face': '🤑', 'nerd': '🤓', 'sunglasses': '😎', 'upside_down': '🙃',
                    'wink': '😉', 'stuck_out': '😛', 'zany': '🤪', 'raised_eyebrow': '🤨',
                    'smirk': '😏', 'unamused': '😒', 'sweat': '😅', 'cold_sweat': '😰',
                    'scream_cat': '🙀', 'pouting': '😡', 'triumph': '😤', 'relieved': '😌',
                    'pensive': '😔', 'confused': '😕', 'worried': '😟', 'flushed': '😳',
                    'hot': '🥵', 'cold': '🥶', 'exploding': '🤯', 'monocle': '🧐', 'nauseous': '🤢'
                };
                this.discoveredChannelsIndex = 0;
                this.swipeStartX = null;
                this.swipeThreshold = 50;
                this.enhancedEmojiModal = null;
                this.loadRecentEmojis();
                this.lightningAddress = null;
                this.userLightningAddresses = new Map();
                this.userAvatars = new Map();
                this.profileFetchQueue = [];
                this.profileFetchTimer = null;
                this.profileFetchBatchDelay = 100;
                this.zaps = new Map();
                this.currentZapTarget = null;
                this.currentZapInvoice = null;
                this.pendingLightningWaiters = new Map();
                this.zapCheckInterval = null;
                this.zapInvoiceData = null;
                this.listExpansionStates = new Map();
                this.userLocation = null;
                this.userColors = new Map();
                this.blurOthersImages = true;
                this.imageBlurSettings = this.loadImageBlurSettings();
                this.sortByProximity = localStorage.getItem('nym_sort_proximity') === 'true';
                this.verifiedDeveloper = {
                    npub: 'npub16jdfqgazrkapk0yrqm9rdxlnys7ck39c7zmdzxtxqlmmpxg04r0sd733sv',
                    pubkey: 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df',
                    title: 'NYM Developer'
                };
                this.isFlutterWebView = navigator.userAgent.includes('NYMApp') ||
                    navigator.userAgent.includes('Flutter');

                if (this.isFlutterWebView) {
                    console.log('Running in Flutter WebView - using enhanced connection monitoring');
                }
            }

            async handleChannelLink(channelInput, event) {
                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                }

                // Parse channel type from prefix
                let channelType = 'auto';
                let channelName = channelInput;

                if (channelInput.startsWith('c:')) {
                    channelType = 'community';
                    channelName = channelInput.substring(2);
                } else if (channelInput.startsWith('g:')) {
                    channelType = 'geohash';
                    channelName = channelInput.substring(2);
                } else if (channelInput.startsWith('e:')) {
                    channelType = 'ephemeral';
                    channelName = channelInput.substring(2);
                }

                // Handle based on type
                if (channelType === 'community') {
                    const communityId = channelName;

                    if (this.connectionMode === 'ephemeral') {
                        this.displaySystemMessage('Community channels require a persistent identity (extension or nsec login)');
                        return;
                    }

                    // Check if community exists
                    if (this.communityChannels.has(communityId)) {
                        const community = this.communityChannels.get(communityId);

                        // Check if private and has access
                        if (community.isPrivate) {
                            const hasAccess = this.ownedCommunities.has(communityId) ||
                                (this.communityModerators.has(communityId) &&
                                    this.communityModerators.get(communityId).has(this.pubkey)) ||
                                (this.communityMembers.has(communityId) &&
                                    this.communityMembers.get(communityId).has(this.pubkey)) ||
                                (this.communityInvites.has(communityId) &&
                                    this.communityInvites.get(communityId).has(this.pubkey));

                            if (!hasAccess) {
                                this.displaySystemMessage(`Cannot join private community "${community.name}" - invitation required`);
                                return;
                            }
                        }

                        // Add to UI if not present
                        if (!document.querySelector(`[data-community="${communityId}"]`)) {
                            this.addCommunityChannel(community.name, communityId, community.isPrivate);
                        }

                        this.switchToCommunity(communityId);
                        this.userJoinedChannels.add(communityId);
                        this.saveUserChannels();
                    } else {
                        this.displaySystemMessage('Community not found or you do not have access');
                    }
                } else if (channelType === 'geohash' || (channelType === 'auto' && this.isValidGeohash(channelName))) {
                    // Geohash channel
                    if (!this.channels.has(channelName)) {
                        this.addChannel(channelName, channelName);
                    }
                    this.switchChannel(channelName, channelName);
                    this.userJoinedChannels.add(channelName);
                    this.saveUserChannels();
                } else {
                    // Standard ephemeral channel
                    if (!this.channels.has(channelName)) {
                        this.addChannel(channelName, '');
                    }
                    this.switchChannel(channelName, '');
                    await this.createChannel(channelName);
                    this.userJoinedChannels.add(channelName);
                    this.saveUserChannels();
                }
            }

            showGeohashExplorer() {
                const modal = document.getElementById('geohashExplorerModal');
                if (modal) {
                    modal.style.display = 'flex';

                    // Wait for modal to be visible before initializing globe
                    setTimeout(() => {
                        // Check if canvas container exists
                        const canvasContainer = document.getElementById('geohashGlobeCanvas');
                        if (!canvasContainer || !canvasContainer.parentElement) {
                            console.error('Globe container not found');
                            return;
                        }

                        // Always reinitialize globe when opening
                        this.initializeGlobe();
                    }, 100);
                }
            }

            closeGeohashExplorer() {
                const modal = document.getElementById('geohashExplorerModal');
                if (modal) {
                    modal.style.display = 'none';
                }

                // Stop animation
                this.globeAnimationActive = false;

                // Clean up globe resources
                if (this.globe) {
                    // Dispose of renderer
                    if (this.globe.renderer) {
                        this.globe.renderer.dispose();
                        this.globe.renderer.forceContextLoss();
                        this.globe.renderer.domElement = null;
                    }

                    // Clean up scene
                    if (this.globe.scene) {
                        this.globe.scene.traverse((object) => {
                            if (object.geometry) {
                                object.geometry.dispose();
                            }
                            if (object.material) {
                                if (Array.isArray(object.material)) {
                                    object.material.forEach(material => material.dispose());
                                } else {
                                    object.material.dispose();
                                }
                            }
                        });
                    }

                    this.globe = null;
                }

                // Clean up resize handler
                if (this.globeResizeHandler) {
                    window.removeEventListener('resize', this.globeResizeHandler);
                    this.globeResizeHandler = null;
                }

                console.log('Geohash explorer closed and resources cleaned up');
            }

            initializeGlobe() {
                const container = document.getElementById('geohashGlobeCanvas');

                if (!container) {
                    console.error('Globe container not found');
                    return;
                }

                // Clear any existing content
                container.innerHTML = '';

                // Create globe viz container
                const globeViz = document.createElement('div');
                globeViz.id = 'globeViz';
                globeViz.style.width = '100%';
                globeViz.style.height = '100%';
                globeViz.style.position = 'absolute';
                globeViz.style.top = '0';
                globeViz.style.left = '0';
                container.appendChild(globeViz);

                // Determine if we should show "Your Location" in legend
                const showYourLocation = this.settings.sortByProximity && this.userLocation;

                // Re-add the controls and info panel HTML with conditional legend
                container.insertAdjacentHTML('beforeend', `
        <div class="geohash-info-panel" id="geohashInfoPanel" style="display: none;">
            <div class="geohash-info-title" id="geohashInfoTitle">Channel Info</div>
            <div id="geohashInfoContent"></div>
            <button class="geohash-join-btn" id="geohashJoinBtn">Join Channel</button>
        </div>

        <div class="geohash-controls">
            <button class="geohash-control-btn" onclick="nym.resetGlobeView()">Reset View</button>
        </div>

        <div class="geohash-legend">
            <div class="geohash-legend-item">
                <div class="geohash-legend-dot" style="background: var(--primary); box-shadow: 0 0 5px var(--primary);"></div>
                <span>Active Channels</span>
            </div>
            ${showYourLocation ? `
            <div class="geohash-legend-item">
                <div class="geohash-legend-dot" style="background: var(--warning);"></div>
                <span>Your Location</span>
            </div>
            ` : ''}
        </div>
    `);

                // Get geohash channels
                this.updateGeohashChannels();

                console.log('Geohash channels to plot:', this.geohashChannels.map(ch => ({
                    geohash: ch.geohash,
                    lat: ch.lat,
                    lng: ch.lng
                })));

                // Calculate optimal distance based on screen size
                const isMobile = window.innerWidth <= 768;
                const initialDistance = isMobile ? 400 : 300;

                // Create globe with dynamic sizing
                const Globe = new ThreeGlobe()
                    .globeImageUrl('https://unpkg.com/three-globe@2.31.0/example/img/earth-blue-marble.jpg')
                    .bumpImageUrl('https://unpkg.com/three-globe@2.31.0/example/img/earth-topology.png');

                // Setup renderer first
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                globeViz.appendChild(renderer.domElement);

                // Setup camera
                const camera = new THREE.PerspectiveCamera();
                camera.position.z = initialDistance;

                // Define updateSize function
                const updateSize = () => {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    renderer.setSize(width, height);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                };

                updateSize();

                // Setup scene with brighter lighting
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000011);
                scene.add(Globe);
                scene.add(new THREE.AmbientLight(0xffffff, 1.5));

                const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight1.position.set(5, 3, 5);
                scene.add(directionalLight1);

                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight2.position.set(-5, -3, -5);
                scene.add(directionalLight2);

                // Create a container group for points that will rotate with the globe
                const pointsGroup = new THREE.Group();
                scene.add(pointsGroup);

                const GLOBE_RADIUS = 100; // three-globe default radius

                const polar2Cartesian = (lat, lng, relAltitude = 0) => {
                    const phi = (90 - lat) * Math.PI / 180;
                    const theta = (lng - 90) * Math.PI / 180;  // Subtract 90 instead of add
                    const r = GLOBE_RADIUS * (1 + relAltitude);

                    return {
                        x: r * Math.sin(phi) * Math.cos(theta),
                        y: r * Math.cos(phi),
                        z: -r * Math.sin(phi) * Math.sin(theta)  // Negate the Z
                    };
                };

                // Create clickable point meshes
                const pointMeshes = [];
                const POINT_ALTITUDE = 0.01; // Just above surface

                // Create individual sphere meshes for each geohash channel
                this.geohashChannels.forEach((channel, index) => {
                    const geometry = new THREE.SphereGeometry(2.5, 16, 16);
                    const material = new THREE.MeshBasicMaterial({
                        color: channel.isJoined ? 0x00ff00 : 0x00ffff,
                        transparent: true,
                        opacity: 0.9
                    });
                    const sphere = new THREE.Mesh(geometry, material);

                    // Convert lat/lng to 3D position using three-globe's coordinate system
                    const pos = polar2Cartesian(channel.lat, channel.lng, POINT_ALTITUDE);
                    sphere.position.set(pos.x, pos.y, pos.z);

                    console.log(`Geohash ${channel.geohash}: lat=${channel.lat.toFixed(4)}, lng=${channel.lng.toFixed(4)} -> pos=(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);

                    // Store channel data on the mesh
                    sphere.userData = {
                        geohash: channel.geohash,
                        lat: channel.lat,
                        lng: channel.lng,
                        channelIndex: index,
                        isGeohashPoint: true
                    };

                    // Add to points group (not Globe) so we can control rotation separately
                    pointsGroup.add(sphere);
                    pointMeshes.push(sphere);
                });

                // Add user location if available (check both userLocation and proximity setting)
                const hasLocation = this.userLocation || (this.settings.sortByProximity && navigator.geolocation);

                if (this.userLocation) {
                    const geometry = new THREE.SphereGeometry(3, 16, 16);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.9
                    });
                    const sphere = new THREE.Mesh(geometry, material);

                    const pos = polar2Cartesian(this.userLocation.lat, this.userLocation.lng, POINT_ALTITUDE);
                    sphere.position.set(pos.x, pos.y, pos.z);

                    sphere.userData = {
                        isUserLocation: true
                    };

                    pointsGroup.add(sphere);

                    console.log(`User location: lat=${this.userLocation.lat.toFixed(4)}, lng=${this.userLocation.lng.toFixed(4)} -> pos=(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);
                } else if (this.settings.sortByProximity && navigator.geolocation) {
                    // If proximity sorting is enabled but location not yet loaded, try to get it now
                    console.log('Proximity sorting enabled, attempting to get location for globe...');
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            this.userLocation = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            };
                            console.log('Got location for globe, updating...');

                            // Add the yellow dot now that we have location
                            const geometry = new THREE.SphereGeometry(3, 16, 16);
                            const material = new THREE.MeshBasicMaterial({
                                color: 0xffff00,
                                transparent: true,
                                opacity: 0.9
                            });
                            const sphere = new THREE.Mesh(geometry, material);

                            const pos = polar2Cartesian(this.userLocation.lat, this.userLocation.lng, POINT_ALTITUDE);
                            sphere.position.set(pos.x, pos.y, pos.z);

                            sphere.userData = {
                                isUserLocation: true
                            };

                            pointsGroup.add(sphere);

                            console.log(`User location added: lat=${this.userLocation.lat.toFixed(4)}, lng=${this.userLocation.lng.toFixed(4)}`);
                        },
                        (error) => {
                            console.log('Could not get location for globe:', error);
                        }
                    );
                }

                // Interaction state
                let autoRotate = true;
                let mouseDownX = 0;
                let mouseDownY = 0;
                let mouseDownTime = 0;
                let totalDragDistance = 0;
                let isDragging = false;
                let hoveredMesh = null;
                const CLICK_THRESHOLD = 5;
                const CLICK_TIME_THRESHOLD = 300;

                // Raycaster for interaction detection
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                renderer.domElement.style.cursor = 'grab';

                // Helper function to get mouse coordinates
                const getMouseCoordinates = (clientX, clientY) => {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                };

                // Hover detection
                const checkHover = (clientX, clientY) => {
                    if (isDragging) return;

                    getMouseCoordinates(clientX, clientY);
                    raycaster.setFromCamera(mouse, camera);

                    const intersects = raycaster.intersectObjects(pointMeshes, false);

                    if (intersects.length > 0) {
                        const intersectedMesh = intersects[0].object;

                        if (intersectedMesh.userData.isGeohashPoint) {
                            hoveredMesh = intersectedMesh;
                            renderer.domElement.style.cursor = 'pointer';
                            intersectedMesh.scale.set(1.2, 1.2, 1.2);
                        }
                    } else {
                        if (hoveredMesh && hoveredMesh.userData.isGeohashPoint) {
                            hoveredMesh.scale.set(1, 1, 1);
                        }
                        hoveredMesh = null;
                        renderer.domElement.style.cursor = 'grab';
                    }
                };

                // Mousemove for hover
                renderer.domElement.addEventListener('mousemove', (e) => {
                    if (!isDragging) {
                        checkHover(e.clientX, e.clientY);
                    }
                });

                // Pointer down - start tracking
                renderer.domElement.addEventListener('pointerdown', (e) => {
                    e.preventDefault();

                    mouseDownX = e.clientX;
                    mouseDownY = e.clientY;
                    mouseDownTime = Date.now();
                    totalDragDistance = 0;
                    isDragging = false;
                    autoRotate = false;
                    renderer.domElement.style.cursor = 'grabbing';

                    const onPointerMove = (moveEvent) => {
                        const deltaX = moveEvent.clientX - mouseDownX;
                        const deltaY = moveEvent.clientY - mouseDownY;

                        totalDragDistance += Math.abs(deltaX) + Math.abs(deltaY);

                        if (totalDragDistance > CLICK_THRESHOLD) {
                            isDragging = true;
                            if (hoveredMesh && hoveredMesh.userData.isGeohashPoint) {
                                hoveredMesh.scale.set(1, 1, 1);
                            }
                            hoveredMesh = null;
                        }

                        // Apply rotation to both globe AND points group
                        const rotationDeltaX = deltaX * 0.005;
                        const rotationDeltaY = deltaY * 0.005;

                        Globe.rotation.y += rotationDeltaX;
                        Globe.rotation.x += rotationDeltaY;
                        Globe.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, Globe.rotation.x));

                        // Sync points group rotation with Globe
                        pointsGroup.rotation.copy(Globe.rotation);

                        mouseDownX = moveEvent.clientX;
                        mouseDownY = moveEvent.clientY;
                    };

                    const onPointerUp = (upEvent) => {
                        document.removeEventListener('pointermove', onPointerMove);
                        document.removeEventListener('pointerup', onPointerUp);

                        const clickDuration = Date.now() - mouseDownTime;
                        renderer.domElement.style.cursor = 'grab';

                        // Check if this was a click
                        if (totalDragDistance <= CLICK_THRESHOLD && clickDuration <= CLICK_TIME_THRESHOLD) {
                            getMouseCoordinates(upEvent.clientX, upEvent.clientY);
                            raycaster.setFromCamera(mouse, camera);

                            const intersects = raycaster.intersectObjects(pointMeshes, false);

                            if (intersects.length > 0) {
                                const clickedMesh = intersects[0].object;

                                if (clickedMesh.userData.isGeohashPoint) {
                                    const geohash = clickedMesh.userData.geohash;
                                    const clickedChannel = this.geohashChannels.find(ch => ch.geohash === geohash);

                                    if (clickedChannel) {
                                        console.log('Clicked on channel:', clickedChannel.geohash, 'at', clickedChannel.lat, clickedChannel.lng);
                                        this.selectGeohashChannel(clickedChannel);
                                    }
                                }
                            }
                        }

                        isDragging = false;
                        setTimeout(() => checkHover(upEvent.clientX, upEvent.clientY), 50);
                    };

                    document.addEventListener('pointermove', onPointerMove);
                    document.addEventListener('pointerup', onPointerUp);
                });

                // Wheel zoom
                renderer.domElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    camera.position.z += e.deltaY * 0.2;
                    camera.position.z = Math.max(150, Math.min(600, camera.position.z));
                });

                // Pinch-to-zoom support for mobile
                let touchDistance = 0;
                let initialCameraZ = camera.position.z;

                renderer.domElement.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        // Two-finger touch - start pinch
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        touchDistance = Math.sqrt(dx * dx + dy * dy);
                        initialCameraZ = camera.position.z;

                        // Stop auto-rotation during pinch
                        autoRotate = false;
                    }
                }, { passive: false });

                renderer.domElement.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();

                        // Calculate new distance between touches
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        const newDistance = Math.sqrt(dx * dx + dy * dy);

                        if (touchDistance > 0) {
                            // Calculate zoom factor based on pinch distance change
                            const scale = touchDistance / newDistance;
                            const newZ = initialCameraZ * scale;

                            // Apply zoom with limits
                            camera.position.z = Math.max(150, Math.min(600, newZ));
                        }
                    }
                }, { passive: false });

                renderer.domElement.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        // Reset pinch state when less than 2 fingers
                        touchDistance = 0;
                    }
                });

                // Animation loop
                const animate = () => {
                    if (!this.globeAnimationActive) return;

                    if (autoRotate) {
                        Globe.rotation.y += 0.002;
                        // Sync points group rotation with Globe during auto-rotation
                        pointsGroup.rotation.copy(Globe.rotation);
                    }

                    renderer.render(scene, camera);
                    requestAnimationFrame(animate);
                };

                // Store references
                this.globe = {
                    scene: Globe,
                    camera: camera,
                    renderer: renderer,
                    pointMeshes: pointMeshes,
                    pointsGroup: pointsGroup,
                    autoRotate: autoRotate,
                    setAutoRotate: (value) => {
                        autoRotate = value;
                        this.globe.autoRotate = value;
                    },
                    updatePoints: () => {
                        this.updateGeohashChannels();

                        // Remove existing point meshes from points group
                        pointMeshes.forEach(mesh => pointsGroup.remove(mesh));
                        pointMeshes.length = 0;

                        // Recreate point meshes
                        this.geohashChannels.forEach((channel, index) => {
                            const geometry = new THREE.SphereGeometry(2.5, 16, 16);
                            const material = new THREE.MeshBasicMaterial({
                                color: channel.isJoined ? 0x00ff00 : 0x00ffff,
                                transparent: true,
                                opacity: 0.9
                            });
                            const sphere = new THREE.Mesh(geometry, material);

                            const pos = polar2Cartesian(channel.lat, channel.lng, POINT_ALTITUDE);
                            sphere.position.set(pos.x, pos.y, pos.z);

                            sphere.userData = {
                                geohash: channel.geohash,
                                lat: channel.lat,
                                lng: channel.lng,
                                channelIndex: index,
                                isGeohashPoint: true
                            };

                            pointsGroup.add(sphere);
                            pointMeshes.push(sphere);
                        });

                        // Re-add user location if available
                        if (this.userLocation) {
                            const geometry = new THREE.SphereGeometry(3, 16, 16);
                            const material = new THREE.MeshBasicMaterial({
                                color: 0xffff00,
                                transparent: true,
                                opacity: 0.9
                            });
                            const sphere = new THREE.Mesh(geometry, material);

                            const pos = polar2Cartesian(this.userLocation.lat, this.userLocation.lng, POINT_ALTITUDE);
                            sphere.position.set(pos.x, pos.y, pos.z);

                            sphere.userData = {
                                isUserLocation: true
                            };

                            pointsGroup.add(sphere);
                        }

                        // Sync rotation after updating points
                        pointsGroup.rotation.copy(Globe.rotation);
                    }
                };

                this.globeAnimationActive = true;

                // Handle resize
                const handleResize = () => {
                    updateSize();
                };

                if (this.globeResizeHandler) {
                    window.removeEventListener('resize', this.globeResizeHandler);
                }
                this.globeResizeHandler = handleResize;
                window.addEventListener('resize', this.globeResizeHandler);

                // Start animation
                animate();

                console.log('Globe initialized with', this.geohashChannels.length, 'clickable points');
            }

            addGeohashChannelToGlobe(geohash) {
                // If globe is active, update it
                if (this.globe && this.globeAnimationActive) {
                    this.globe.updatePoints();
                }
            }

            updateGeohashChannels() {
                this.geohashChannels = [];

                // Get all geohash channels from discovered channels and user channels
                const allGeohashes = new Set();

                // From common geohashes
                this.commonGeohashes.forEach(g => allGeohashes.add(g.toLowerCase()));

                // From user's channels
                this.channels.forEach((value, key) => {
                    if (value.geohash) {
                        allGeohashes.add(value.geohash.toLowerCase());
                    }
                });

                // From stored messages
                this.messages.forEach((msgs, channel) => {
                    if (channel.startsWith('#') && this.isValidGeohash(channel.substring(1))) {
                        allGeohashes.add(channel.substring(1).toLowerCase());
                    }
                });

                // Convert to array with coordinates
                allGeohashes.forEach(geohash => {
                    try {
                        const coords = this.decodeGeohash(geohash);
                        const messageCount = (this.messages.get(`#${geohash}`) || []).length;
                        this.geohashChannels.push({
                            geohash: geohash.toLowerCase(), // Ensure lowercase
                            lat: coords.lat,
                            lng: coords.lng,
                            messages: messageCount,
                            isJoined: this.channels.has(geohash)
                        });
                    } catch (e) {
                        console.error('Error decoding geohash:', geohash, e);
                    }
                });
            }

            async selectGeohashChannel(channel) {
                this.selectedGeohash = channel.geohash.toLowerCase();

                // Stop auto-rotation when selecting a channel
                if (this.globe && this.globe.controls) {
                    this.globe.controls.autoRotate = false;
                    this.globe.autoRotate = false;
                }

                const infoPanel = document.getElementById('geohashInfoPanel');
                const infoTitle = document.getElementById('geohashInfoTitle');
                const infoContent = document.getElementById('geohashInfoContent');
                const joinBtn = document.getElementById('geohashJoinBtn');

                infoTitle.textContent = `#${channel.geohash.toLowerCase()}`;

                const distance = this.userLocation ?
                    this.calculateDistance(this.userLocation.lat, this.userLocation.lng, channel.lat, channel.lng).toFixed(1) + ' km away' :
                    '';

                // Get city and country from reverse geocoding
                let locationInfo = 'Loading location...';
                infoContent.innerHTML = `
        <div class="geohash-info-item">
            <strong>Coordinates:</strong> ${channel.lat.toFixed(4)}, ${channel.lng.toFixed(4)}
        </div>
        <div class="geohash-info-item" id="locationInfoItem">
            <strong>Location:</strong> ${locationInfo}
        </div>
        ${distance ? `<div class="geohash-info-item"><strong>Distance:</strong> ${distance}</div>` : ''}
        <div class="geohash-info-item">
            <strong>Messages:</strong> ${channel.messages}
        </div>
    `;

                // Update join button
                if (channel.isJoined) {
                    joinBtn.textContent = 'Go to Channel';
                } else {
                    joinBtn.textContent = 'Join Channel';
                }

                // Set up join button with proper handler
                joinBtn.onclick = () => {
                    this.joinSelectedGeohash();
                };

                infoPanel.style.display = 'block';

                // Fetch city and country asynchronously
                try {
                    const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${channel.lat}&lon=${channel.lng}&zoom=10`);
                    const data = await response.json();

                    const city = data.address.city || data.address.town || data.address.village || data.address.county || '';
                    const country = data.address.country || '';

                    locationInfo = [city, country].filter(x => x).join(', ') || 'Unknown location';

                    // Update the location info element
                    const locationInfoItem = document.getElementById('locationInfoItem');
                    if (locationInfoItem) {
                        locationInfoItem.innerHTML = `<strong>Location:</strong> ${locationInfo}`;
                    }
                } catch (error) {
                    console.error('Error fetching location:', error);
                    const locationInfoItem = document.getElementById('locationInfoItem');
                    if (locationInfoItem) {
                        locationInfoItem.innerHTML = `<strong>Location:</strong> Unknown`;
                    }
                }

                console.log('Selected geohash channel:', channel.geohash, 'at', channel.lat, channel.lng);
            }

            joinSelectedGeohash() {
                if (this.selectedGeohash) {
                    const geohash = this.selectedGeohash.toLowerCase();

                    console.log('Joining geohash channel:', geohash);

                    // Close the explorer modal
                    this.closeGeohashExplorer();

                    // Small delay to ensure modal closes before switching
                    setTimeout(() => {
                        // Add the channel if not already present
                        if (!this.channels.has(geohash)) {
                            this.addChannel(geohash, geohash);
                        }

                        // Switch to the channel
                        this.switchChannel(geohash, geohash);

                        // Mark as user-joined
                        this.userJoinedChannels.add(geohash);
                        this.saveUserChannels();

                        this.displaySystemMessage(`Joined geohash channel #${geohash}`);
                    }, 100);
                }
            }

            resetGlobeView() {
                if (this.globe) {
                    this.globe.camera.position.set(0, 0, 300);
                    this.globe.scene.rotation.set(0, 0, 0);
                    this.globe.setAutoRotate(true);
                    this.globe.autoRotate = true;

                    // Close any open geohash channel details
                    const infoPanel = document.getElementById('geohashInfoPanel');
                    if (infoPanel) {
                        infoPanel.style.display = 'none';
                    }

                    console.log('Globe view reset');
                }
            }

            getUserColorClass(pubkey) {
                if (this.settings.theme !== 'bitchat') return '';

                // Your own messages are always orange
                if (pubkey === this.pubkey) {
                    return 'bitchat-theme';
                }

                // Return cached color if exists
                if (this.userColors.has(pubkey)) {
                    return this.userColors.get(pubkey);
                }

                // Generate unique color based on pubkey hash
                const colorClass = this.generateUniqueColor(pubkey);
                this.userColors.set(pubkey, colorClass);
                return colorClass;
            }

            // Generate a unique color based on pubkey
            generateUniqueColor(pubkey) {
                let hash = 0;
                for (let i = 0; i < pubkey.length; i++) {
                    hash = pubkey.charCodeAt(i) + ((hash << 5) - hash);
                }

                // Generate HSL color
                const hue = Math.abs(hash) % 360;
                const saturation = 65 + (Math.abs(hash) % 35); // 65-100%
                const lightness = 60 + (Math.abs(hash) % 25);  // 60-85%

                // Create unique class name
                const uniqueClass = `bitchat-user-${Math.abs(hash) % 1000}`;

                // Add dynamic style if not exists
                if (!document.getElementById(uniqueClass)) {
                    const style = document.createElement('style');
                    style.id = uniqueClass;
                    style.textContent = `
            .${uniqueClass} {
                color: hsl(${hue}, ${saturation}%, ${lightness}%) !important;
            }
            .${uniqueClass} .nym-suffix {
                color: hsl(${hue}, ${saturation}%, ${lightness}%) !important;
            }
        `;
                    document.head.appendChild(style);
                }

                return uniqueClass;
            }

            shareChannel() {
                // Generate the share URL
                const baseUrl = window.location.origin + window.location.pathname;
                let channelPart;

                // Determine what to share based on current mode with prefixes to avoid conflicts
                if (this.currentCommunity) {
                    // For communities, use 'c:' prefix with community ID
                    channelPart = `c:${this.currentCommunity}`;
                } else if (this.currentGeohash) {
                    // For geohash channels, use 'g:' prefix
                    channelPart = `g:${this.currentGeohash}`;
                } else {
                    // For standard channels, use 'e:' prefix (ephemeral)
                    channelPart = `e:${this.currentChannel}`;
                }

                const shareUrl = `${baseUrl}#${channelPart}`;

                // Set the URL in the input
                document.getElementById('shareUrlInput').value = shareUrl;

                // Show the modal
                document.getElementById('shareModal').classList.add('active');

                // Auto-select the text
                setTimeout(() => {
                    document.getElementById('shareUrlInput').select();
                }, 100);
            }

            copyShareUrl() {
                const input = document.getElementById('shareUrlInput');
                input.select();

                navigator.clipboard.writeText(input.value).then(() => {
                    const btn = document.querySelector('.copy-url-btn');
                    const originalText = btn.textContent;
                    btn.textContent = 'COPIED!';
                    btn.classList.add('copied');

                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.classList.remove('copied');
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    this.displaySystemMessage('Failed to copy URL');
                });
            }

            shareToTwitter() {
                const url = document.getElementById('shareUrlInput').value;
                const channelName = this.currentGeohash || this.currentChannel;
                const text = `Join me in the #${channelName} channel on NYM - ephemeral Nostr chat`;
                const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
                window.open(twitterUrl, '_blank');
            }

            shareToNostr() {
                const url = document.getElementById('shareUrlInput').value;
                const channelName = this.currentGeohash || this.currentChannel;
                const content = `Join me in the #${channelName} channel on NYM - ephemeral Nostr chat\n\n${url}`;

                // Copy to clipboard with Nostr note format
                const note = `nostr:note1${content}`;
                navigator.clipboard.writeText(content).then(() => {
                    this.displaySystemMessage('Channel link copied for Nostr sharing');
                    closeModal('shareModal');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    this.displaySystemMessage('Failed to copy for Nostr');
                });
            }

            shareToClipboard() {
                this.copyShareUrl();
            }

            // Add a command for sharing
            async cmdShare() {
                this.shareChannel();
            }

            decodeGeohash(geohash) {
                const BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';
                const bounds = {
                    lat: [-90, 90],
                    lng: [-180, 180]
                };

                let isEven = true;
                for (let i = 0; i < geohash.length; i++) {
                    const cd = BASE32.indexOf(geohash[i].toLowerCase());
                    if (cd === -1) throw new Error('Invalid geohash character');

                    for (let j = 4; j >= 0; j--) {
                        const mask = 1 << j;
                        if (isEven) {
                            bounds.lng = (cd & mask) ?
                                [(bounds.lng[0] + bounds.lng[1]) / 2, bounds.lng[1]] :
                                [bounds.lng[0], (bounds.lng[0] + bounds.lng[1]) / 2];
                        } else {
                            bounds.lat = (cd & mask) ?
                                [(bounds.lat[0] + bounds.lat[1]) / 2, bounds.lat[1]] :
                                [bounds.lat[0], (bounds.lat[0] + bounds.lat[1]) / 2];
                        }
                        isEven = !isEven;
                    }
                }

                return {
                    lat: (bounds.lat[0] + bounds.lat[1]) / 2,
                    lng: (bounds.lng[0] + bounds.lng[1]) / 2
                };
            }

            getGeohashLocation(geohash) {
                try {
                    const coords = this.decodeGeohash(geohash);
                    const lat = coords.lat;
                    const lng = coords.lng;

                    // Format coordinates properly with N/S and E/W
                    const latStr = Math.abs(lat).toFixed(2) + '°' + (lat >= 0 ? 'N' : 'S');
                    const lngStr = Math.abs(lng).toFixed(2) + '°' + (lng >= 0 ? 'E' : 'W');

                    return `${latStr}, ${lngStr}`;
                } catch (e) {
                    console.error('Error decoding geohash:', e);
                    return '';
                }
            }

            calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371; // Earth radius in km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            isVerifiedDeveloper(pubkey) {
                return pubkey === this.verifiedDeveloper.pubkey;
            }

            validateGeohashInput(input) {
                // Geohash valid characters: 0-9, b-z excluding a, i, l, o
                const validChars = '0123456789bcdefghjkmnpqrstuvwxyz';
                return input.split('').every(char => validChars.includes(char.toLowerCase()));
            }

            // NSEC decode method
            decodeNsec(nsec) {
                try {
                    // Use nostr-tools nip19 decode
                    if (window.NostrTools && window.NostrTools.nip19) {
                        const decoded = window.NostrTools.nip19.decode(nsec);
                        if (decoded.type === 'nsec') {
                            return decoded.data;
                        }
                    }
                    throw new Error('Invalid nsec format');
                } catch (error) {
                    throw new Error('Failed to decode nsec: ' + error.message);
                }
            }

            updateRelayStatus() {
                const listEl = document.getElementById('connectedRelaysList');
                if (!listEl) return;

                // Group relays by type
                const broadcastRelays = [];
                const readRelays = [];
                const nosflareRelays = [];

                this.relayPool.forEach((relay, url) => {
                    if (relay.type === 'broadcast') {
                        broadcastRelays.push(url);
                    } else if (relay.type === 'nosflare') {
                        nosflareRelays.push(url);
                    } else if (relay.type === 'read') {
                        readRelays.push(url);
                    }
                });

                // Calculate total readable relays (broadcast relays can also be read from)
                const totalReadable = broadcastRelays.length + readRelays.length;

                let html = '';

                if (broadcastRelays.length > 0 || nosflareRelays.length > 0) {
                    html += '<div style="margin-bottom: 10px;"><strong style="color: var(--primary);">Default Relays:</strong><br/>';
                    broadcastRelays.forEach(url => {
                        html += `<div style="font-size: 11px; margin-left: 10px;">• ${url}</div>`;
                    });
                    nosflareRelays.forEach(url => {
                        html += `<div style="font-size: 11px; margin-left: 10px;">• ${url} (write-only)</div>`;
                    });
                    html += '</div>';
                }

                if (readRelays.length > 0) {
                    html += `<div><strong style="color: var(--secondary);">Additional Read Relays (${readRelays.length}):</strong><br/>`;
                    readRelays.slice(0, 10).forEach(url => {
                        html += `<div style="font-size: 11px; margin-left: 10px;">• ${url}</div>`;
                    });
                    if (readRelays.length > 10) {
                        html += `<div style="font-size: 11px; margin-left: 10px; color: var(--text-dim);">... and ${readRelays.length - 10} more</div>`;
                    }
                    html += '</div>';
                }

                html += `<div style="margin-top: 10px; font-size: 12px; color: var(--text-bright);">Total Connected: ${this.relayPool.size} relays (${totalReadable} readable)</div>`;

                listEl.innerHTML = html || '<div style="color: var(--text-dim); font-size: 12px;">No relays connected</div>';
            }

            async refreshRelays() {
                this.displaySystemMessage('Refreshing relay list...');
                this.lastRelayDiscovery = 0; // Force refresh
                await this.discoverRelays();
                await this.connectToRelays();
                this.updateRelayStatus();
            }

            isValidGeohash(str) {
                return this.geohashRegex.test(str.toLowerCase());
            }

            getChannelType(channel) {
                if (this.isValidGeohash(channel)) {
                    return 'geo';
                }
                return 'standard';
            }

            handleChannelSearch(searchTerm) {
                const term = searchTerm.toLowerCase();
                const resultsDiv = document.getElementById('channelSearchResults');

                // Filter existing channels
                this.filterChannels(term);

                // Show create/join prompt if search term exists
                if (term.length > 0) {
                    // Sanitize the search term (remove spaces and invalid characters)
                    const sanitized = term.replace(/[^a-z0-9-]/g, '');

                    if (!sanitized) {
                        resultsDiv.innerHTML = '<div class="search-create-prompt" style="color: var(--danger);">Invalid name. Use only letters, numbers, and hyphens.</div>';
                        return;
                    }

                    const isGeohash = this.isValidGeohash(sanitized);

                    // Check if it's a community channel
                    let matchedCommunity = null;
                    this.communityChannels.forEach((community, id) => {
                        if (community.name.toLowerCase() === sanitized || id.toLowerCase().includes(sanitized)) {
                            matchedCommunity = { id, community };
                        }
                    });

                    const exists = Array.from(this.channels.keys()).some(k => k.toLowerCase() === sanitized);

                    // Clear previous results
                    resultsDiv.innerHTML = '';

                    // Show matched community if found
                    if (matchedCommunity) {
                        const { id, community } = matchedCommunity;

                        // Check if user can access this community
                        const isOwned = this.ownedCommunities.has(id);
                        const isModerated = this.moderatedCommunities.has(id);
                        const isMember = this.communityMembers.has(id) &&
                            this.communityMembers.get(id).has(this.pubkey);
                        const canAccess = !community.isPrivate || isOwned || isModerated || isMember;

                        if (canAccess) {
                            const privacyBadge = community.isPrivate ? 'PRI' : 'PUB';
                            const privacyColor = community.isPrivate ? 'var(--purple)' : 'var(--primary)';

                            const prompt = document.createElement('div');
                            prompt.className = 'search-create-prompt';
                            prompt.style.cssText = 'display: flex; justify-content: space-between; align-items: center;';
                            prompt.innerHTML = `
                    <span>Join community "${community.name}"</span>
                    <span style="color: ${privacyColor}; border: 1px solid ${privacyColor}; padding: 2px 8px; border-radius: 3px; font-size: 10px;">${privacyBadge}</span>
                `;
                            prompt.onclick = () => {
                                this.switchToCommunity(id);
                                document.getElementById('channelSearch').value = '';
                                resultsDiv.innerHTML = '';
                                this.filterChannels('');
                            };
                            resultsDiv.appendChild(prompt);
                        }
                    }

                    // Show geohash option if valid
                    if (isGeohash && !exists) {
                        const location = this.getGeohashLocation(sanitized) || 'Unknown location';
                        const prompt = document.createElement('div');
                        prompt.className = 'search-create-prompt';
                        prompt.style.cssText = 'display: flex; justify-content: space-between; align-items: center;';
                        prompt.innerHTML = `
                <span>Join geohash "${sanitized}" (${location})</span>
                <span style="color: var(--warning); border: 1px solid var(--warning); padding: 2px 8px; border-radius: 3px; font-size: 10px;">GEO</span>
            `;
                        prompt.onclick = async () => {
                            this.addChannel(sanitized, sanitized);
                            this.switchChannel(sanitized, sanitized);
                            this.userJoinedChannels.add(sanitized);
                            document.getElementById('channelSearch').value = '';
                            resultsDiv.innerHTML = '';
                            this.filterChannels('');
                            this.saveUserChannels();
                        };
                        resultsDiv.appendChild(prompt);
                    }

                    // Show standard channel option if doesn't exist
                    if (!exists && !matchedCommunity) {
                        const prompt = document.createElement('div');
                        prompt.className = 'search-create-prompt';
                        prompt.style.cssText = 'display: flex; justify-content: space-between; align-items: center;';
                        prompt.innerHTML = `
                <span>Create/Join channel "${sanitized}"</span>
                <span style="color: var(--blue); border: 1px solid var(--blue); padding: 2px 8px; border-radius: 3px; font-size: 10px;">EPH</span>
            `;
                        prompt.onclick = async () => {
                            this.addChannel(sanitized, '');
                            this.switchChannel(sanitized, '');
                            await this.createChannel(sanitized);
                            this.userJoinedChannels.add(sanitized);
                            document.getElementById('channelSearch').value = '';
                            resultsDiv.innerHTML = '';
                            this.filterChannels('');
                            this.saveUserChannels();
                        };
                        resultsDiv.appendChild(prompt);
                    }

                    // Show create community option if logged in and name doesn't match existing
                    if (this.connectionMode !== 'ephemeral' && !matchedCommunity && !isGeohash) {
                        const prompt = document.createElement('div');
                        prompt.className = 'search-create-prompt';
                        prompt.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-top: 5px;';
                        prompt.innerHTML = `
                <span>Create public community "${sanitized}"</span>
                <span style="color: var(--primary); border: 1px solid var(--primary); padding: 2px 8px; border-radius: 3px; font-size: 10px;">PUB</span>
            `;
                        prompt.onclick = async () => {
                            const communityId = await this.createCommunityChannel(sanitized, `Public community for ${sanitized}`, false);
                            if (communityId) {
                                this.switchToCommunity(communityId);
                            }
                            document.getElementById('channelSearch').value = '';
                            resultsDiv.innerHTML = '';
                            this.filterChannels('');
                        };
                        resultsDiv.appendChild(prompt);
                    }

                    // Show warning if original term had invalid characters
                    if (term !== sanitized) {
                        const warning = document.createElement('div');
                        warning.className = 'search-create-prompt';
                        warning.style.cssText = 'color: var(--text-dim); font-size: 11px; margin-top: 5px; cursor: default;';
                        warning.innerHTML = `Note: Spaces and special characters removed. Using "${sanitized}"`;
                        warning.onclick = null;
                        resultsDiv.appendChild(warning);
                    }
                } else {
                    resultsDiv.innerHTML = '';
                }
            }

            loadRecentEmojis() {
                const saved = localStorage.getItem('nym_recent_emojis');
                if (saved) {
                    this.recentEmojis = JSON.parse(saved);
                }
            }

            saveRecentEmojis() {
                localStorage.setItem('nym_recent_emojis', JSON.stringify(this.recentEmojis.slice(0, 20)));
            }

            addToRecentEmojis(emoji) {
                // Remove if already exists
                this.recentEmojis = this.recentEmojis.filter(e => e !== emoji);
                // Add to beginning
                this.recentEmojis.unshift(emoji);
                // Keep only 20 recent
                this.recentEmojis = this.recentEmojis.slice(0, 20);
                this.saveRecentEmojis();
            }

            async initialize() {
                try {
                    // Check if nostr-tools is loaded
                    if (typeof window.NostrTools === 'undefined') {
                        throw new Error('nostr-tools not loaded');
                    }

                    // Setup event listeners
                    this.setupEventListeners();
                    this.setupCommands();
                    this.setupEmojiPicker();
                    this.setupContextMenu();
                    this.setupMobileGestures();

                    // Load saved preferences
                    this.applyTheme(this.settings.theme);
                    this.loadBlockedUsers();
                    this.loadBlockedKeywords();
                    this.loadBlockedChannels();
                    this.loadPinnedChannels();

                    // Load lightning address
                    await this.loadLightningAddress();

                    // Clean up old localStorage format
                    this.cleanupOldLightningAddress();

                    // Network change detection
                    this.setupNetworkMonitoring();

                    // Visibility change detection
                    this.setupVisibilityMonitoring();

                    console.log('NYM initialized successfully');
                } catch (error) {
                    console.error('Failed to initialize NYM:', error);
                    this.showNotification('Error', 'Failed to initialize: ' + error.message);
                }
            }

            setupVisibilityMonitoring() {
                // Track when app becomes visible/hidden
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        console.log('App became visible, checking connection health...');
                        const delay = this.isFlutterWebView ? 200 : 500;
                        setTimeout(() => {
                            this.checkConnectionHealth();

                            if (!this.connected && navigator.onLine) {
                                this.attemptReconnection();
                            }

                            // Always refresh subscriptions when we come back to foreground
                            setTimeout(() => this.resubscribeAllRelays(), 250);
                        }, delay);
                    } else {
                        console.log('App hidden');
                        // Stop monitoring when app goes to background
                        if (this.reconnectionInterval) {
                            clearInterval(this.reconnectionInterval);
                            this.reconnectionInterval = null;
                        }
                    }
                });

                // Also listen for page focus (for desktop)
                window.addEventListener('focus', () => {
                    console.log('Window focused, checking connection health...');
                    const delay = this.isFlutterWebView ? 200 : 500;
                    setTimeout(() => {
                        this.checkConnectionHealth();

                        // If disconnected, immediately start reconnection attempts
                        if (!this.connected && navigator.onLine) {
                            this.attemptReconnection();
                        }

                        // Always refresh subscriptions when window regains focus
                        setTimeout(() => this.resubscribeAllRelays(), 250);
                    }, delay);
                });

                // For Flutter WebView, also check on resume event
                if (this.isFlutterWebView) {
                    window.addEventListener('resume', () => {
                        console.log('App resumed, checking connection...');
                        setTimeout(() => {
                            this.checkConnectionHealth();

                            // If disconnected, immediately start reconnection attempts
                            if (!this.connected && navigator.onLine) {
                                this.attemptReconnection();
                            }

                            // Always refresh subscriptions when app resumes
                            setTimeout(() => this.resubscribeAllRelays(), 250);
                        }, 200);
                    });
                }
            }

            async checkConnectionHealth() {

                // First, check if we think we're connected
                let actuallyConnected = 0;
                const deadRelays = [];

                this.relayPool.forEach((relay, url) => {
                    if (relay.ws && relay.ws.readyState === WebSocket.OPEN) {
                        actuallyConnected++;
                    } else {
                        deadRelays.push(url);
                    }
                });

                // Clean up dead relays
                deadRelays.forEach(url => {
                    this.relayPool.delete(url);
                    this.relayKinds.delete(url);
                });

                // If we have no actual connections, force reconnect
                if (actuallyConnected === 0) {
                    this.connected = false;
                    this.updateConnectionStatus('Disconnected');

                    // Clear reconnecting set to allow fresh attempts
                    if (this.reconnectingRelays) {
                        this.reconnectingRelays.clear();
                    }

                    // Try to reconnect to broadcast relays
                    await this.reconnectToBroadcastRelays();

                    // ALSO reconnect to discovered relays after a short delay
                    setTimeout(() => {
                        this.retryDiscoveredRelays();
                    }, 2000);

                } else {
                    // We have some connections, but update status to reflect actual count
                    this.updateConnectionStatus();

                    // If we're missing some broadcast relays, try to restore them
                    const missingBroadcast = this.broadcastRelays.filter(url => !this.relayPool.has(url));
                    if (missingBroadcast.length > 0) {
                        this.reconnectToBroadcastRelays();
                    }

                    // ALSO check for missing discovered relays
                    const missingDiscovered = Array.from(this.discoveredRelays).filter(url =>
                        !this.relayPool.has(url) &&
                        !this.broadcastRelays.includes(url) &&
                        url !== this.nosflareRelay
                    );

                    if (missingDiscovered.length > 0) {
                        setTimeout(() => {
                            this.retryDiscoveredRelays();
                        }, 1000);
                    }
                }
            }

            async reconnectToBroadcastRelays() {

                let connectedCount = 0;

                for (const relayUrl of this.broadcastRelays) {
                    if (!this.relayPool.has(relayUrl) ||
                        (this.relayPool.get(relayUrl).ws &&
                            this.relayPool.get(relayUrl).ws.readyState !== WebSocket.OPEN)) {

                        try {
                            await this.connectToRelay(relayUrl, 'broadcast');
                            this.subscribeToSingleRelay(relayUrl);
                            connectedCount++;

                            if (connectedCount === 1) {
                                // After first successful connection
                                this.connected = true;
                                this.updateConnectionStatus();
                            }
                        } catch (err) {
                            this.trackRelayFailure(relayUrl);
                        }

                        // Small delay between connections to avoid overwhelming
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }

                this.updateConnectionStatus();
            }

            setupNetworkMonitoring() {
                // Track reconnection attempts
                this.reconnectionAttempts = 0;
                this.maxReconnectionAttempts = 10;
                this.reconnectionInterval = null;

                // Listen for online/offline events
                window.addEventListener('online', () => {
                    this.displaySystemMessage('Network connection restored, reconnecting...');
                    this.reconnectionAttempts = 0; // Reset attempts on network restore

                    // Force update connection status
                    this.updateConnectionStatus('Reconnecting...');

                    // Clear any existing reconnection interval
                    if (this.reconnectionInterval) {
                        clearInterval(this.reconnectionInterval);
                        this.reconnectionInterval = null;
                    }

                    // Clear all reconnecting flags to allow fresh attempts
                    if (this.reconnectingRelays) {
                        this.reconnectingRelays.clear();
                    }

                    // Clear relay pool of dead connections
                    this.relayPool.forEach((relay, url) => {
                        if (!relay.ws || relay.ws.readyState !== WebSocket.OPEN) {
                            this.relayPool.delete(url);
                            this.relayKinds.delete(url);
                        }
                    });

                    // Clear blacklist temporarily to allow retry
                    const tempBlacklist = new Set(this.blacklistedRelays);
                    this.blacklistedRelays.clear();

                    // Attempt to reconnect to all broadcast relays
                    this.broadcastRelays.forEach(relayUrl => {
                        if (!this.relayPool.has(relayUrl)) {
                            this.connectToRelay(relayUrl, 'broadcast')
                                .then(() => {
                                    this.subscribeToSingleRelay(relayUrl);
                                    this.updateConnectionStatus();
                                })
                                .catch(err => {
                                    // Restore to blacklist if it fails again
                                    if (tempBlacklist.has(relayUrl)) {
                                        this.blacklistedRelays.add(relayUrl);
                                    }
                                    this.updateConnectionStatus();
                                });
                        }
                    });
                });

                window.addEventListener('offline', () => {

                    // Force cleanup of relay pool
                    this.relayPool.forEach((relay, url) => {
                        if (relay.ws) {
                            try {
                                relay.ws.close();
                            } catch (e) {
                                // Ignore close errors
                            }
                        }
                        this.relayPool.delete(url);
                        this.relayKinds.delete(url);
                    });

                    this.connected = false;
                    this.displaySystemMessage('Network connection lost');
                    this.updateConnectionStatus('Disconnected');
                });

                // Start automatic reconnection monitoring
                this.startReconnectionMonitoring();
            }

            startReconnectionMonitoring() {
                // Only monitor when app is visible/active
                this.reconnectionInterval = null;

                const startMonitoring = () => {
                    // Clear any existing interval
                    if (this.reconnectionInterval) {
                        clearInterval(this.reconnectionInterval);
                    }

                    // Only start if disconnected and visible
                    if (!this.connected && !document.hidden) {
                        console.log('Starting active reconnection monitoring (app is visible)...');
                        this.reconnectionInterval = setInterval(() => {
                            // Only attempt if still visible
                            if (!document.hidden && !this.connected && navigator.onLine) {
                                this.attemptReconnection();
                            } else if (document.hidden) {
                                // Stop monitoring if app goes to background
                                console.log('App backgrounded, pausing reconnection monitoring');
                                clearInterval(this.reconnectionInterval);
                                this.reconnectionInterval = null;
                            }
                        }, 5000);
                    }
                };

                const stopMonitoring = () => {
                    if (this.reconnectionInterval) {
                        console.log('Stopping reconnection monitoring');
                        clearInterval(this.reconnectionInterval);
                        this.reconnectionInterval = null;
                    }
                };

                // Listen for visibility changes
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        // App came to foreground - check immediately then start monitoring
                        setTimeout(() => {
                            this.checkConnectionHealth();
                            if (!this.connected && navigator.onLine) {
                                this.attemptReconnection();
                                startMonitoring();
                            }
                        }, 200);
                    } else {
                        // App went to background - stop monitoring
                        stopMonitoring();
                    }
                });

                // Start monitoring if currently visible and needed
                if (!document.hidden) {
                    startMonitoring();
                }
            }

            async attemptReconnection() {
                // Prevent multiple simultaneous reconnection attempts
                if (this.isReconnecting) {
                    console.log('Reconnection already in progress, skipping...');
                    return;
                }

                // Check if we've exceeded max attempts
                if (this.reconnectionAttempts >= this.maxReconnectionAttempts) {
                    console.log('Max reconnection attempts reached. Manual reconnection required.');
                    this.updateConnectionStatus('Disconnected - Click to reconnect');
                    return;
                }

                this.isReconnecting = true;
                this.reconnectionAttempts++;

                console.log(`Attempting automatic reconnection (attempt ${this.reconnectionAttempts}/${this.maxReconnectionAttempts})...`);
                this.updateConnectionStatus(`Reconnecting (${this.reconnectionAttempts}/${this.maxReconnectionAttempts})...`);

                try {
                    // Clear dead connections first
                    this.relayPool.forEach((relay, url) => {
                        if (!relay.ws || relay.ws.readyState !== WebSocket.OPEN) {
                            this.relayPool.delete(url);
                            this.relayKinds.delete(url);
                        }
                    });

                    // Try to connect to at least one broadcast relay
                    let connected = false;
                    for (const relayUrl of this.broadcastRelays) {
                        if (this.relayPool.has(relayUrl)) {
                            const relay = this.relayPool.get(relayUrl);
                            if (relay.ws && relay.ws.readyState === WebSocket.OPEN) {
                                connected = true;
                                break;
                            }
                        }

                        try {
                            await this.connectToRelayWithTimeout(relayUrl, 'broadcast', 3000);
                            this.subscribeToSingleRelay(relayUrl);
                            connected = true;
                            break;
                        } catch (err) {
                        }
                    }

                    if (connected) {
                        this.connected = true;
                        this.reconnectionAttempts = 0; // Reset on success
                        this.updateConnectionStatus();

                        // Reconnect to other relays in background
                        this.reconnectToBroadcastRelays();
                    }
                } catch (error) {
                    //
                } finally {
                    this.isReconnecting = false;
                }
            }

            setupMobileGestures() {
                if (window.innerWidth <= 768) {
                    // Touch events for swipe to open menu
                    document.addEventListener('touchstart', (e) => {
                        const touch = e.touches[0];
                        // Only track swipes starting from left edge
                        if (touch.clientX < 50) {
                            this.swipeStartX = touch.clientX;
                        }
                    });

                    document.addEventListener('touchmove', (e) => {
                        if (this.swipeStartX !== null) {
                            const touch = e.touches[0];
                            const swipeDistance = touch.clientX - this.swipeStartX;

                            if (swipeDistance > this.swipeThreshold) {
                                this.toggleSidebar();
                                this.swipeStartX = null;
                            }
                        }
                    });

                    document.addEventListener('touchend', () => {
                        this.swipeStartX = null;
                    });
                }
            }

            closeSidebar() {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.remove('open');
                document.getElementById('mobileOverlay').classList.remove('active');
            }

            setupContextMenu() {
                // Close context menu on click outside - using event delegation
                document.addEventListener('click', (e) => {
                    const contextMenu = document.getElementById('contextMenu');

                    // Only proceed if context menu is actually active
                    if (!contextMenu.classList.contains('active')) {
                        return;
                    }

                    // If clicking outside the context menu and not on enhanced emoji modal
                    if (!e.target.closest('.context-menu') && !e.target.closest('.enhanced-emoji-modal')) {
                        contextMenu.classList.remove('active');
                    }
                });

                // Context menu actions
                document.getElementById('ctxMention').addEventListener('click', () => {
                    if (this.contextMenuData) {
                        const baseNym = this.contextMenuData.nym;
                        const pubkey = this.contextMenuData.pubkey;
                        const suffix = this.getPubkeySuffix(pubkey);
                        const fullNym = `${baseNym}#${suffix}`;
                        this.insertMention(fullNym);
                    }
                    document.getElementById('contextMenu').classList.remove('active');
                });

                document.getElementById('ctxPM').addEventListener('click', () => {
                    if (this.contextMenuData) {
                        const baseNym = this.contextMenuData.nym;
                        const suffix = this.getPubkeySuffix(this.contextMenuData.pubkey);
                        const fullNym = `${baseNym}#${suffix}`;
                        this.openUserPM(fullNym, this.contextMenuData.pubkey);
                    }
                    document.getElementById('contextMenu').classList.remove('active');
                });

                // Add zap handler
                document.getElementById('ctxZap').addEventListener('click', async () => {
                    if (this.contextMenuData && this.contextMenuData.messageId) {
                        const { messageId, pubkey, nym } = this.contextMenuData;

                        // Close context menu immediately
                        document.getElementById('contextMenu').classList.remove('active');

                        // Show loading message
                        this.displaySystemMessage(`Checking if @${nym} can receive zaps...`);

                        try {
                            // Always fetch fresh to ensure we have the latest
                            const lnAddress = await this.fetchLightningAddressForUser(pubkey);

                            if (lnAddress) {
                                // User has lightning address, show zap modal
                                this.showZapModal(messageId, pubkey, nym);
                            } else {
                                // No lightning address found
                                this.displaySystemMessage(`@${nym} cannot receive zaps (no lightning address set)`);
                            }
                        } catch (error) {
                            console.error('Error fetching lightning address:', error);
                            this.displaySystemMessage(`Failed to check if @${nym} can receive zaps`);
                        }
                    }
                });

                // Add slap handler
                let slapOption = document.getElementById('ctxSlap');
                if (!slapOption) {
                    // Create slap option if it doesn't exist
                    slapOption = document.createElement('div');
                    slapOption.className = 'context-menu-item';
                    slapOption.id = 'ctxSlap';
                    slapOption.textContent = 'Slap with Trout';

                    // Insert after PM option
                    const pmOption = document.getElementById('ctxPM');
                    if (pmOption && pmOption.nextSibling) {
                        pmOption.parentNode.insertBefore(slapOption, pmOption.nextSibling);
                    } else if (pmOption) {
                        pmOption.parentNode.appendChild(slapOption);
                    }
                }

                // Add the click handler for slap
                slapOption.addEventListener('click', () => {
                    if (this.contextMenuData) {
                        // Pass the pubkey directly as the argument
                        this.cmdSlap(this.contextMenuData.pubkey);
                    }
                    document.getElementById('contextMenu').classList.remove('active');
                });

                document.getElementById('ctxReact').addEventListener('click', () => {
                    if (this.contextMenuData && this.contextMenuData.messageId) {
                        document.getElementById('contextMenu').classList.remove('active');

                        // Use a delay to ensure context menu closes first
                        setTimeout(() => {
                            // Create a temporary button element for positioning (centered for mobile)
                            const tempButton = document.createElement('button');
                            tempButton.style.position = 'fixed';
                            tempButton.style.left = '50%';
                            tempButton.style.bottom = '50%';
                            tempButton.style.opacity = '0';
                            tempButton.style.pointerEvents = 'none';
                            document.body.appendChild(tempButton);

                            this.showEnhancedReactionPicker(this.contextMenuData.messageId, tempButton);

                            // Remove temp button after modal is created
                            setTimeout(() => tempButton.remove(), 100);
                        }, 100);
                    }
                });

                document.getElementById('ctxQuote').addEventListener('click', () => {
                    if (this.contextMenuData && this.contextMenuData.content) {
                        const input = document.getElementById('messageInput');
                        const baseNym = this.contextMenuData.nym;
                        const suffix = this.getPubkeySuffix(this.contextMenuData.pubkey);
                        const fullNym = `${baseNym}#${suffix}`;
                        input.value = `> @${fullNym}: ${this.contextMenuData.content}\n\n`;
                        input.focus();
                    }
                    document.getElementById('contextMenu').classList.remove('active');
                });

                document.getElementById('ctxBlock').addEventListener('click', () => {
                    if (this.contextMenuData) {
                        // Pass the pubkey directly as the argument
                        this.cmdBlock(this.contextMenuData.pubkey);
                    }
                    document.getElementById('contextMenu').classList.remove('active');
                });

                // Add copy pubkey handler
                document.getElementById('ctxCopyPubkey').addEventListener('click', async () => {
                    if (this.contextMenuData && this.contextMenuData.pubkey) {
                        try {
                            await navigator.clipboard.writeText(this.contextMenuData.pubkey);
                            this.displaySystemMessage(`Copied pubkey to clipboard`);
                        } catch (err) {
                            console.error('Failed to copy pubkey:', err);
                            console.log('Pubkey was:', this.contextMenuData.pubkey);
                            this.displaySystemMessage('Failed to copy pubkey');
                        }
                    } else {
                        console.error('No pubkey in contextMenuData:', this.contextMenuData);
                        this.displaySystemMessage('No pubkey available to copy');
                    }
                    document.getElementById('contextMenu').classList.remove('active');
                });
            }

            showContextMenu(e, nym, pubkey, content = null, messageId = null) {
                e.preventDefault();
                e.stopPropagation();

                const menu = document.getElementById('contextMenu');
                // Parse base nym from display format - this removes HTML tags
                const parsedNym = this.parseNymFromDisplay(nym);
                // Get just the base nym without any suffix
                const baseNym = parsedNym.split('#')[0] || parsedNym;
                const suffix = this.getPubkeySuffix(pubkey);
                const fullNym = `${baseNym}#${suffix}`;

                this.contextMenuData = { nym: baseNym, pubkey, content, messageId };

                // First, clear any existing dynamic menu items (community moderation options)
                const existingModItems = menu.querySelectorAll('.context-menu-item.moderation');
                existingModItems.forEach(item => item.remove());

                // Add slap option if it doesn't exist
                let slapOption = document.getElementById('ctxSlap');
                if (!slapOption) {
                    // Create slap option
                    slapOption = document.createElement('div');
                    slapOption.className = 'context-menu-item';
                    slapOption.id = 'ctxSlap';
                    slapOption.textContent = 'Slap with Trout';

                    // Insert after PM option
                    const pmOption = document.getElementById('ctxPM');
                    if (pmOption && pmOption.nextSibling) {
                        pmOption.parentNode.insertBefore(slapOption, pmOption.nextSibling);
                    } else if (pmOption) {
                        pmOption.parentNode.appendChild(slapOption);
                    }
                }

                // Show slap option only if not yourself
                slapOption.style.display = pubkey === this.pubkey ? 'none' : 'block';

                // Add community moderation options if in a community and user is admin/mod
                if (this.currentCommunity && pubkey !== this.pubkey) {
                    const isAdmin = this.ownedCommunities.has(this.currentCommunity);
                    const isMod = this.communityModerators.has(this.currentCommunity) &&
                        this.communityModerators.get(this.currentCommunity).has(this.pubkey);

                    if (isAdmin || isMod) {
                        const community = this.communityChannels.get(this.currentCommunity);
                        const isTargetAdmin = community && community.admin === pubkey;
                        const isTargetMod = this.communityModerators.has(this.currentCommunity) &&
                            this.communityModerators.get(this.currentCommunity).has(pubkey);
                        const isTargetBanned = this.communityBans.has(this.currentCommunity) &&
                            this.communityBans.get(this.currentCommunity).has(pubkey);

                        // Add separator
                        const separator = document.createElement('div');
                        separator.className = 'context-menu-item moderation';
                        separator.style.borderTop = '1px solid var(--border)';
                        separator.style.pointerEvents = 'none';
                        separator.style.padding = '0';
                        separator.style.margin = '5px 0';
                        menu.appendChild(separator);

                        // Add moderation label
                        const modLabel = document.createElement('div');
                        modLabel.className = 'context-menu-item moderation';
                        modLabel.style.fontSize = '10px';
                        modLabel.style.color = 'var(--text-dim)';
                        modLabel.style.pointerEvents = 'none';
                        modLabel.textContent = 'COMMUNITY MODERATION';
                        menu.appendChild(modLabel);

                        // Kick option (can't kick admin or other mods if you're a mod)
                        if (!isTargetAdmin && !(isMod && isTargetMod) && !isTargetBanned) {
                            const kickOption = document.createElement('div');
                            kickOption.className = 'context-menu-item moderation';
                            kickOption.textContent = 'Kick';
                            kickOption.onclick = () => {
                                this.cmdKick(fullNym);
                                menu.classList.remove('active');
                            };
                            menu.appendChild(kickOption);
                        }

                        // Ban/Unban option
                        if (!isTargetAdmin && !(isMod && isTargetMod)) {
                            const banOption = document.createElement('div');
                            banOption.className = 'context-menu-item moderation danger';
                            banOption.textContent = isTargetBanned ? 'Unban' : 'Ban';
                            banOption.onclick = () => {
                                if (isTargetBanned) {
                                    this.cmdUnban(fullNym);
                                } else {
                                    this.cmdBan(fullNym);
                                }
                                menu.classList.remove('active');
                            };
                            menu.appendChild(banOption);
                        }

                        // Admin-only options
                        if (isAdmin && !isTargetAdmin) {
                            // Add/Remove moderator
                            const modOption = document.createElement('div');
                            modOption.className = 'context-menu-item moderation';
                            modOption.style.color = 'var(--secondary)';
                            modOption.textContent = isTargetMod ? 'Remove Moderator' : 'Make Moderator';
                            modOption.onclick = () => {
                                if (isTargetMod) {
                                    this.cmdRemoveMod(fullNym);
                                } else {
                                    this.cmdAddMod(fullNym);
                                }
                                menu.classList.remove('active');
                            };
                            menu.appendChild(modOption);
                        }
                    }
                }

                // Add zap option handling
                const zapOption = document.getElementById('ctxZap');
                if (zapOption) {
                    // Show zap option if:
                    // 1. Not your own message
                    // 2. Has a valid message ID
                    if (pubkey !== this.pubkey && messageId) {
                        zapOption.style.display = 'block';
                    } else {
                        zapOption.style.display = 'none';
                    }
                }

                // Hide block option if it's your own message
                const blockOption = document.getElementById('ctxBlock');
                if (pubkey === this.pubkey) {
                    blockOption.style.display = 'none';
                } else {
                    blockOption.style.display = 'block';
                    blockOption.textContent = this.blockedUsers.has(baseNym) ? 'Unblock User' : 'Block User';
                }

                // Hide PM option if it's yourself
                document.getElementById('ctxPM').style.display = pubkey === this.pubkey ? 'none' : 'block';

                // Show/hide quote option
                document.getElementById('ctxQuote').style.display = content ? 'block' : 'none';

                // Show/hide React option
                const reactOption = document.getElementById('ctxReact');
                reactOption.style.display = messageId ? 'block' : 'none';

                // Add active class first to make visible
                menu.classList.add('active');

                // Get dimensions after making visible
                const menuRect = menu.getBoundingClientRect();
                const windowHeight = window.innerHeight;
                const windowWidth = window.innerWidth;

                let top = e.pageY;
                let left = e.pageX;

                // Check if menu would go off bottom of screen
                if (top + menuRect.height > windowHeight) {
                    top = windowHeight - menuRect.height - 10;
                }

                // Check if menu would go off right of screen
                if (left + menuRect.width > windowWidth) {
                    left = windowWidth - menuRect.width - 10;
                }

                // Ensure menu doesn't go off top or left
                top = Math.max(10, top);
                left = Math.max(10, left);

                menu.style.left = left + 'px';
                menu.style.top = top + 'px';

                // Prevent the click from immediately closing the menu
                e.stopImmediatePropagation();
            }

            showMobileReactionPicker(messageId) {
                const picker = document.createElement('div');
                picker.className = 'reaction-picker active';
                picker.style.position = 'fixed';
                picker.style.bottom = '50%';
                picker.style.left = '50%';
                picker.style.transform = 'translate(-50%, 50%)';
                picker.style.zIndex = '1001';
                picker.style.display = 'grid';
                picker.style.gridTemplateColumns = 'repeat(5, 1fr)';

                picker.innerHTML = ['👍', '❤️', '😂', '🔥', '👎', '😮', '🤔', '💯', '🎉', '👏'].map(emoji =>
                    `<button class="reaction-emoji" onclick="nym.sendReaction('${messageId}', '${emoji}'); this.parentElement.remove();">${emoji}</button>`
                ).join('');

                document.body.appendChild(picker);

                // Close on click outside
                setTimeout(() => {
                    document.addEventListener('click', (e) => {
                        if (!picker.contains(e.target)) {
                            picker.remove();
                        }
                    }, { once: true });
                }, 100);
            }

            loadBlockedKeywords() {
                const saved = localStorage.getItem('nym_blocked_keywords');
                if (saved) {
                    this.blockedKeywords = new Set(JSON.parse(saved));
                }
                this.updateKeywordList();
            }

            saveBlockedKeywords() {
                localStorage.setItem('nym_blocked_keywords', JSON.stringify(Array.from(this.blockedKeywords)));
            }

            addBlockedKeyword() {
                const input = document.getElementById('newKeywordInput');
                const keyword = input.value.trim().toLowerCase();

                if (keyword) {
                    this.blockedKeywords.add(keyword);
                    this.saveBlockedKeywords();
                    this.updateKeywordList();
                    input.value = '';

                    // Hide messages containing this keyword
                    document.querySelectorAll('.message').forEach(msg => {
                        const content = msg.querySelector('.message-content');
                        if (content && content.textContent.toLowerCase().includes(keyword)) {
                            msg.classList.add('blocked');
                        }
                    });

                    this.displaySystemMessage(`Blocked keyword: "${keyword}"`);

                    // Sync to Nostr for persistent connections
                    if (this.connectionMode !== 'ephemeral') {
                        this.saveSyncedSettings();
                    }
                }
            }

            removeBlockedKeyword(keyword) {
                this.blockedKeywords.delete(keyword);
                this.saveBlockedKeywords();
                this.updateKeywordList();

                // Re-check all messages
                document.querySelectorAll('.message').forEach(msg => {
                    const author = msg.dataset.author;
                    const content = msg.querySelector('.message-content');

                    if (content && !this.blockedUsers.has(author)) {
                        const hasBlockedKeyword = Array.from(this.blockedKeywords).some(kw =>
                            content.textContent.toLowerCase().includes(kw)
                        );

                        if (!hasBlockedKeyword) {
                            msg.classList.remove('blocked');
                        }
                    }
                });

                this.displaySystemMessage(`Unblocked keyword: "${keyword}"`);

                // Sync to Nostr for persistent connections
                if (this.connectionMode !== 'ephemeral') {
                    this.saveSyncedSettings();
                }
            }

            updateKeywordList() {
                const list = document.getElementById('keywordList');
                if (this.blockedKeywords.size === 0) {
                    list.innerHTML = '<div style="color: var(--text-dim); font-size: 12px;">No blocked keywords</div>';
                } else {
                    list.innerHTML = Array.from(this.blockedKeywords).map(keyword => `
                        <div class="keyword-item">
                            <span>${this.escapeHtml(keyword)}</span>
                            <button class="remove-keyword-btn" onclick="nym.removeBlockedKeyword('${this.escapeHtml(keyword).replace(/'/g, "\\'")}')">Remove</button>
                        </div>
                    `).join('');
                }
            }

            hasBlockedKeyword(text) {
                const lowerText = text.toLowerCase();
                return Array.from(this.blockedKeywords).some(keyword => lowerText.includes(keyword));
            }

            generateRandomNym() {
                const adjectives = [
                    'quantum', 'neon', 'cyber', 'shadow', 'plasma',
                    'echo', 'nexus', 'void', 'flux', 'ghost',
                    'phantom', 'stealth', 'cryptic', 'dark', 'neural',
                    'binary', 'matrix', 'digital', 'virtual', 'zero',
                    'null', 'anon', 'masked', 'hidden', 'cipher',
                    'enigma', 'spectral', 'rogue', 'omega', 'alpha',
                    'delta', 'sigma', 'vortex', 'turbo', 'razor',
                    'blade', 'frost', 'storm', 'glitch', 'pixel'
                ];

                const nouns = [
                    'ghost', 'nomad', 'drift', 'pulse', 'wave',
                    'spark', 'node', 'byte', 'mesh', 'link',
                    'runner', 'hacker', 'coder', 'agent', 'proxy',
                    'daemon', 'virus', 'worm', 'bot', 'droid',
                    'reaper', 'shadow', 'wraith', 'specter', 'shade',
                    'entity', 'unit', 'core', 'nexus', 'cypher',
                    'breach', 'exploit', 'overflow', 'inject', 'root',
                    'kernel', 'shell', 'terminal', 'console', 'script'
                ];

                const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
                const noun = nouns[Math.floor(Math.random() * nouns.length)];

                // Use the last 4 chars of pubkey
                const suffix = this.getPubkeySuffix(this.pubkey);

                return `${adj}_${noun}#${suffix}`;
            }

            formatNymWithPubkey(nym, pubkey) {
                // If nym already has a # suffix, don't add another
                if (nym.includes('#')) {
                    return nym;
                }

                // Get last 4 characters of pubkey
                const suffix = pubkey ? pubkey.slice(-4) : '????';
                return `${nym}<span class="nym-suffix">#${suffix}</span>`;
            }

            getPubkeySuffix(pubkey) {
                return pubkey ? pubkey.slice(-4) : '????';
            }

            parseNymFromDisplay(displayNym) {
                if (!displayNym) return '';
                let n = displayNym.replace(/<span\s+class=["']nym-suffix["'][^>]*>.*?<\/span>/gi, '');
                n = n.replace(/\s*#([0-9a-f]{4})\s*$/i, '');
                return n.trim();
            }

            async connectToRelays() {
                try {
                    this.updateConnectionStatus('Connecting...');

                    // Check if we're already connected to ANY broadcast relay from pre-connection
                    let initialConnected = false;
                    let connectedRelayUrl = null;

                    for (const relayUrl of this.broadcastRelays) {
                        if (this.relayPool.has(relayUrl)) {
                            const relay = this.relayPool.get(relayUrl);
                            if (relay && relay.ws && relay.ws.readyState === WebSocket.OPEN) {
                                initialConnected = true;
                                connectedRelayUrl = relayUrl;
                                break;
                            }
                        }
                    }

                    // If not already connected, try to connect to broadcast relays one by one
                    if (!initialConnected) {
                        for (const relayUrl of this.broadcastRelays) {
                            if (!this.shouldRetryRelay(relayUrl)) {
                                continue;
                            }

                            try {
                                await this.connectToRelayWithTimeout(relayUrl, 'broadcast', 2000);
                                initialConnected = true;
                                connectedRelayUrl = relayUrl;
                                break;
                            } catch (err) {
                                this.trackRelayFailure(relayUrl);
                            }
                        }
                    }

                    if (!initialConnected) {
                        throw new Error('Could not connect to any broadcast relay');
                    }

                    // Enable input immediately after first relay connects
                    document.getElementById('messageInput').disabled = false;
                    document.getElementById('sendBtn').disabled = false;
                    this.connected = true;

                    // Set initial channel label for #bar
                    document.getElementById('currentChannel').innerHTML = '#bar <span style="font-size: 12px; color: var(--text-dim);">(Ephemeral)</span>';

                    // Start subscriptions on all connected relays
                    this.subscribeToAllRelays();

                    // Update status to show we're connected
                    this.updateConnectionStatus();
                    this.displaySystemMessage(`Connected to the Nostr network via multiple relays...`);

                    // Load synced settings for persistent connections
                    if (this.connectionMode !== 'ephemeral') {
                        // Wait a bit longer to ensure relays are ready
                        setTimeout(() => {
                            this.loadSyncedSettings();
                        }, 2000); // Increased from 1000ms
                    }

                    // Now connect to remaining broadcast relays in background
                    this.broadcastRelays.forEach(relayUrl => {
                        if (!this.relayPool.has(relayUrl) && this.shouldRetryRelay(relayUrl)) {
                            this.connectToRelay(relayUrl, 'broadcast')
                                .then(() => {
                                    this.subscribeToSingleRelay(relayUrl);
                                    this.updateConnectionStatus();
                                })
                                .catch(err => {
                                    this.trackRelayFailure(relayUrl);
                                });
                        }
                    });

                    // Connect to nosflare for sending only (no subscriptions)
                    if (this.shouldRetryRelay(this.nosflareRelay)) {
                        this.connectToRelay(this.nosflareRelay, 'nosflare')
                            .then(() => {
                                this.updateConnectionStatus();
                            })
                            .catch(err => {
                                this.trackRelayFailure(this.nosflareRelay);
                            });
                    }

                    // Discover additional relays in the background
                    setTimeout(() => {
                        this.discoverRelays().then(() => {
                            // Connect to discovered relays for additional reading sources
                            const relaysToConnect = Array.from(this.discoveredRelays)
                                .filter(url => !this.relayPool.has(url) && this.shouldRetryRelay(url))
                                .slice(0, this.maxRelaysForReq);

                            if (relaysToConnect.length > 0) {
                                // Stagger connections to avoid overwhelming the browser
                                relaysToConnect.forEach((relayUrl, index) => {
                                    setTimeout(() => {
                                        this.connectToRelayWithTimeout(relayUrl, 'read', this.relayTimeout)
                                            .then(() => {
                                                this.subscribeToSingleRelay(relayUrl);
                                                this.updateConnectionStatus();
                                            })
                                            .catch(err => {
                                                this.trackRelayFailure(relayUrl);
                                            });
                                    }, index * 100);
                                });
                            }
                        });
                    }, 100);

                } catch (error) {
                    this.updateConnectionStatus('Connection Failed');
                    this.displaySystemMessage('Failed to connect to relays: ' + error.message);

                    // Re-enable input anyway in case user wants to retry
                    document.getElementById('messageInput').disabled = false;
                    document.getElementById('sendBtn').disabled = false;
                }
            }

            async quickConnect() {
                // Try broadcast relays in order with very short timeout
                for (const relayUrl of this.broadcastRelays) {
                    if (!this.shouldRetryRelay(relayUrl)) {
                        continue;
                    }

                    try {
                        await this.connectToRelayWithTimeout(relayUrl, 'broadcast', 1500); // 1.5 second timeout

                        // Enable input immediately
                        document.getElementById('messageInput').disabled = false;
                        document.getElementById('sendBtn').disabled = false;
                        this.connected = true;

                        // Start subscriptions
                        this.subscribeToSingleRelay(relayUrl);

                        this.updateConnectionStatus();
                        return true;
                    } catch (err) {
                        this.trackRelayFailure(relayUrl);
                    }
                }

                return false; // All broadcast relays failed
            }

            resubscribeAllRelays() {
                this.relayPool.forEach((relay, url) => {
                    if (relay.type === 'nosflare') return; // write-only
                    if (!relay.ws || relay.ws.readyState !== WebSocket.OPEN) return;

                    // Close existing subscriptions before resubscribing
                    this.closeSubscriptionsForRelay(url);
                    this.subscribeToSingleRelay(url);
                });
            }

            closeSubscriptionsForRelay(relayUrl) {
                const relay = this.relayPool.get(relayUrl);
                if (!relay || !relay.ws || relay.ws.readyState !== WebSocket.OPEN) return;

                // Never send to nosflare
                if (['wss://sendit.nosflare.com', 'wss://relay.nosflare.com'].includes(relayUrl)) return;

                // Close all active subscriptions for this relay
                if (relay.subscriptions) {
                    relay.subscriptions.forEach(subId => {
                        relay.ws.send(JSON.stringify(["CLOSE", subId]));
                    });
                    relay.subscriptions.clear();
                } else {
                    // Initialize subscriptions set if it doesn't exist
                    relay.subscriptions = new Set();
                }
            }

            subscribeToSingleRelay(relayUrl) {
                const relay = this.relayPool.get(relayUrl);
                if (!relay || !relay.ws || relay.ws.readyState !== WebSocket.OPEN) return;

                // Never send REQ to nosflare
                if (['wss://sendit.nosflare.com', 'wss://relay.nosflare.com'].includes(relayUrl)) return;

                const ws = relay.ws;

                const subId = "nym-" + Math.random().toString(36).substring(7);

                // Track this subscription
                if (!relay.subscriptions) {
                    relay.subscriptions = new Set();
                }
                relay.subscriptions.add(subId);

                // Build filters array
                const filters = [
                    // Messages in geohash channels
                    {
                        kinds: [20000],
                        limit: 500,
                        since: Math.floor(Date.now() / 1000) - 86400
                    },
                    // Messages in standard channels
                    {
                        kinds: [23333],
                        limit: 500,
                        since: Math.floor(Date.now() / 1000) - 86400
                    },
                    // Messages in communities
                    {
                        kinds: [4550],
                        limit: 500
                    },
                    // Moderation events
                    {
                        kinds: [1984],
                        limit: 500
                    },
                    // Reactions for geohash channels
                    {
                        kinds: [7],
                        "#k": ["20000"],
                        limit: 500,
                        since: Math.floor(Date.now() / 1000) - 86400
                    },
                    // Reactions for standard channels
                    {
                        kinds: [7],
                        "#k": ["23333"],
                        limit: 500,
                        since: Math.floor(Date.now() / 1000) - 86400
                    },
                    // Reactions for PMs
                    {
                        kinds: [7],
                        "#k": ["1059"],
                        limit: 500
                    },
                    // Reactions for community posts
                    {
                        kinds: [7],
                        "#k": ["4550"],
                        limit: 500
                    },
                    // Community reports
                    {
                        kinds: [1984],
                        limit: 500
                    },
                    // Zap receipts
                    {
                        kinds: [9735],
                        limit: 500,
                        since: Math.floor(Date.now() / 1000) - 86400
                    },
                    // All public community definitions
                    {
                        kinds: [34550],
                        limit: 500
                    }
                ];

                if (this.pubkey) {
                    filters.push(
                        // Gift wraps addressed to me
                        {
                            kinds: [1059],
                            "#p": [this.pubkey],
                            limit: 500
                        },
                        // Profile/community definitions by me
                        {
                            kinds: [34550],
                            authors: [this.pubkey],
                            limit: 500
                        },
                        // Any reactions with #p = my pubkey
                        {
                            kinds: [7],
                            "#p": [this.pubkey],
                            since: Math.floor(Date.now() / 1000) - 86400,
                            limit: 500
                        }
                    );
                }

                // Send single REQ with all filters
                ws.send(JSON.stringify(["REQ", subId, ...filters]));
            }

            async connectToRelayWithTimeout(relayUrl, type, timeout) {
                return Promise.race([
                    this.connectToRelay(relayUrl, type),
                    new Promise((_, reject) =>
                        setTimeout(() => reject(new Error(`Timeout connecting to ${relayUrl}`)), timeout)
                    )
                ]);
            }

            shouldRetryRelay(relayUrl) {
                const failedAttempt = this.failedRelays.get(relayUrl);
                if (!failedAttempt) return true;

                const now = Date.now();
                const canRetry = now - failedAttempt > this.relayRetryDelay;

                if (!canRetry) {
                    //
                }

                return canRetry;
            }

            trackRelayFailure(relayUrl) {
                this.failedRelays.set(relayUrl, Date.now());
            }

            clearRelayFailure(relayUrl) {
                this.failedRelays.delete(relayUrl);
            }

            async connectToRelay(relayUrl, type = 'read') {
                return new Promise((resolve, reject) => {
                    try {
                        // Check if blacklisted but also check if expired
                        if (this.blacklistedRelays.has(relayUrl)) {
                            if (!this.isBlacklistExpired(relayUrl)) {
                                // Still blacklisted
                                resolve();
                                return;
                            }
                            // Was expired and removed, continue connecting
                        }

                        if (!this.shouldRetryRelay(relayUrl)) {
                            resolve();
                            return;
                        }

                        // Skip if already connected
                        if (this.relayPool.has(relayUrl)) {
                            const existingRelay = this.relayPool.get(relayUrl);
                            if (existingRelay.ws && existingRelay.ws.readyState === WebSocket.OPEN) {
                                resolve();
                                return;
                            }
                        }

                        const ws = new WebSocket(relayUrl);
                        let verificationTimeout;
                        let connectionTimeout;

                        // Add connection timeout (5 seconds)
                        connectionTimeout = setTimeout(() => {
                            if (ws.readyState !== WebSocket.OPEN) {
                                ws.close();
                                this.blacklistedRelays.add(relayUrl);
                                this.blacklistTimestamps.set(relayUrl, Date.now());
                                reject(new Error('Connection timeout'));
                            }
                        }, 5000);

                        ws.onopen = () => {
                            clearTimeout(connectionTimeout);

                            this.relayPool.set(relayUrl, {
                                ws,
                                type,
                                status: 'connected',
                                connectedAt: Date.now()
                            });

                            this.clearRelayFailure(relayUrl);

                            // For broadcast/nosflare relays, just resolve
                            if (type === 'broadcast' || type === 'nosflare') {
                                resolve();
                                return;
                            }

                            // For read relays, set up verification timeout
                            if (type === 'read') {
                                // Initialize kinds tracking for this relay
                                if (!this.relayKinds.has(relayUrl)) {
                                    this.relayKinds.set(relayUrl, new Set());
                                }

                                // Set timeout to check if relay sends our required kinds
                                verificationTimeout = setTimeout(() => {
                                    const receivedKinds = this.relayKinds.get(relayUrl);
                                    const hasRequiredKinds =
                                        receivedKinds && (
                                            receivedKinds.has(20000) ||
                                            receivedKinds.has(23333) ||
                                            receivedKinds.has(7) ||
                                            receivedKinds.has(1059)
                                        );

                                    if (!hasRequiredKinds) {
                                        ws.close();
                                        this.relayPool.delete(relayUrl);
                                        this.relayKinds.delete(relayUrl);
                                        this.blacklistedRelays.add(relayUrl);
                                        this.blacklistTimestamps.set(relayUrl, Date.now());
                                        this.updateConnectionStatus();
                                    }
                                }, this.relayVerificationTimeout);
                            }

                            resolve();
                        };

                        ws.onmessage = (event) => {
                            try {
                                const msg = JSON.parse(event.data);
                                this.handleRelayMessage(msg, relayUrl);
                            } catch (e) {
                            }
                        };

                        ws.onerror = (error) => {
                            clearTimeout(verificationTimeout);
                            clearTimeout(connectionTimeout);

                            // Immediately blacklist on connection error
                            this.blacklistedRelays.add(relayUrl);
                            this.blacklistTimestamps.set(relayUrl, Date.now());

                            reject(error);
                        };

                        ws.onclose = () => {
                            clearTimeout(verificationTimeout);
                            clearTimeout(connectionTimeout);

                            // If connection closed before opening, blacklist it
                            if (ws.readyState !== WebSocket.OPEN) {
                                this.blacklistedRelays.add(relayUrl);
                                this.blacklistTimestamps.set(relayUrl, Date.now());
                            }

                            // Immediately remove from pool and update status
                            this.relayPool.delete(relayUrl);
                            this.relayKinds.delete(relayUrl);

                            // Force status update after disconnect
                            this.updateConnectionStatus();

                            // Reconnect ALL relay types (broadcast, nosflare, AND read relays)
                            if (this.connected && !this.blacklistedRelays.has(relayUrl)) {
                                // Track disconnections
                                if (!this.reconnectingRelays) {
                                    this.reconnectingRelays = new Set();
                                }

                                // Only reconnect if not already reconnecting this URL
                                if (this.reconnectingRelays.has(relayUrl)) {
                                    return;
                                }

                                this.reconnectingRelays.add(relayUrl);

                                // Implement exponential backoff for reconnection
                                const attemptReconnect = (attempt = 0) => {
                                    const maxAttempts = 10;
                                    const baseDelay = 5000;
                                    const maxDelay = 60000;

                                    // Calculate exponential backoff delay
                                    const delay = Math.min(baseDelay * Math.pow(1.5, attempt), maxDelay);

                                    setTimeout(() => {
                                        // Check WebSocket state and network connectivity
                                        if (!navigator.onLine) {
                                            this.reconnectingRelays.delete(relayUrl);
                                            this.updateConnectionStatus();
                                            return;
                                        }

                                        // Check if we're still supposed to be connected
                                        if (!this.connected) {
                                            this.reconnectingRelays.delete(relayUrl);
                                            this.updateConnectionStatus();
                                            return;
                                        }

                                        this.connectToRelay(relayUrl, type)
                                            .then(() => {
                                                // Re-subscribe after reconnection for ALL relay types
                                                if (type === 'broadcast' || type === 'read') {
                                                    this.subscribeToSingleRelay(relayUrl);
                                                }
                                                this.updateConnectionStatus();

                                                // Remove from reconnecting set
                                                this.reconnectingRelays.delete(relayUrl);

                                                if (this.reconnectingRelays.size === 0) {

                                                    // After broadcast relays reconnect, also retry discovered relays
                                                    if (type === 'broadcast') {
                                                        setTimeout(() => {
                                                            this.retryDiscoveredRelays();
                                                        }, 2000);
                                                    }
                                                }
                                            })
                                            .catch(err => {
                                                this.trackRelayFailure(relayUrl);
                                                this.updateConnectionStatus();

                                                // Try again if we haven't exceeded max attempts
                                                if (attempt < maxAttempts - 1) {
                                                    attemptReconnect(attempt + 1);
                                                } else {
                                                    this.reconnectingRelays.delete(relayUrl);
                                                    this.updateConnectionStatus();
                                                }
                                            });
                                    }, delay);
                                };

                                // Start reconnection attempts
                                attemptReconnect(0);
                            }
                        };

                    } catch (error) {
                        console.error(`Connection failed for ${relayUrl}:`, error);
                        this.blacklistedRelays.add(relayUrl);
                        this.blacklistTimestamps.set(relayUrl, Date.now());
                        this.trackRelayFailure(relayUrl);
                        reject(error);
                    }
                });
            }

            isBlacklistExpired(relayUrl) {
                if (!this.blacklistTimestamps.has(relayUrl)) {
                    return true; // Not in timestamp map, shouldn't be blacklisted
                }

                const blacklistedAt = this.blacklistTimestamps.get(relayUrl);
                const now = Date.now();

                // Reduce blacklist duration from 5 minutes to 2 minutes
                const blacklistDuration = 120000; // 2 minutes instead of 5

                if (now - blacklistedAt > blacklistDuration) {
                    // Expired, remove from blacklist
                    this.blacklistedRelays.delete(relayUrl);
                    this.blacklistTimestamps.delete(relayUrl);
                    return true;
                }

                return false;
            }

            async retryDiscoveredRelays() {

                // Clean expired blacklist entries first
                for (const relayUrl of this.blacklistedRelays) {
                    this.isBlacklistExpired(relayUrl);
                }

                // Try to connect to any discovered relays we're not connected to
                const relaysToTry = [];

                // From previously discovered relays (this is the main source)
                for (const relay of this.discoveredRelays) {
                    if (!this.relayPool.has(relay) &&
                        !this.blacklistedRelays.has(relay) &&
                        !this.broadcastRelays.includes(relay) &&
                        relay !== this.nosflareRelay &&
                        !relaysToTry.includes(relay) &&
                        this.shouldRetryRelay(relay)) {
                        relaysToTry.push(relay);
                    }
                }

                if (relaysToTry.length > 0) {

                    // Try connecting to them with staggered timing
                    for (let i = 0; i < Math.min(relaysToTry.length, 20); i++) { // Try up to 20 relays
                        const relayUrl = relaysToTry[i];
                        setTimeout(() => {
                            this.connectToRelayWithTimeout(relayUrl, 'read', this.relayTimeout)
                                .then(() => {
                                    this.subscribeToSingleRelay(relayUrl);
                                    this.updateConnectionStatus();
                                })
                                .catch(err => {
                                    this.trackRelayFailure(relayUrl);
                                });
                        }, i * 200); // Stagger by 200ms
                    }
                } else {

                    // If we have no discovered relays, try to discover them again
                    this.discoverRelays().then(() => {
                        // After discovery, try connecting to newly discovered relays
                        const newRelaysToTry = Array.from(this.discoveredRelays)
                            .filter(url => !this.relayPool.has(url) &&
                                !this.blacklistedRelays.has(url) &&
                                !this.broadcastRelays.includes(url) &&
                                url !== this.nosflareRelay &&
                                this.shouldRetryRelay(url))
                            .slice(0, 10);

                        if (newRelaysToTry.length > 0) {
                            newRelaysToTry.forEach((relayUrl, index) => {
                                setTimeout(() => {
                                    this.connectToRelayWithTimeout(relayUrl, 'read', this.relayTimeout)
                                        .then(() => {
                                            this.subscribeToSingleRelay(relayUrl);
                                            this.updateConnectionStatus();
                                        })
                                        .catch(err => {
                                            this.trackRelayFailure(relayUrl);
                                        });
                                }, index * 200);
                            });
                        }
                    });
                }
            }

            syncMissingMessages() {
                // For current channel, check if stored messages are displayed
                const currentKey = this.currentGeohash ? `#${this.currentGeohash}` : this.currentChannel;
                const storedMessages = this.messages.get(currentKey) || [];

                storedMessages.forEach(message => {
                    // Check if message is already in DOM
                    if (!document.querySelector(`[data-message-id="${message.id}"]`)) {
                        // Message is stored but not displayed, display it now
                        this.displayMessage(message);
                    }
                });

                // For PMs if in PM mode
                if (this.inPMMode && this.currentPM) {
                    const conversationKey = this.getPMConversationKey(this.currentPM);
                    const pmMessages = this.pmMessages.get(conversationKey) || [];

                    pmMessages.forEach(message => {
                        if (!document.querySelector(`[data-message-id="${message.id}"]`)) {
                            this.displayMessage(message);
                        }
                    });
                }
            }

            // Generate QR code for invoice
            generateQRCode(text, elementId) {
                const element = document.getElementById(elementId);
                if (!element) return;

                // Create QR code using canvas
                const qr = new QRCode(element, {
                    text: text,
                    width: 256,
                    height: 256,
                    colorDark: "#000000",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.L
                });
            }

            // Fetch invoice from LNURL
            async fetchLightningInvoice(lnAddress, amountSats, comment) {
                try {
                    const [username, domain] = lnAddress.split('@');
                    if (!username || !domain) {
                        throw new Error('Invalid lightning address format');
                    }

                    // Fetch LNURL endpoint
                    const lnurlResponse = await fetch(`https://${domain}/.well-known/lnurlp/${username}`);
                    if (!lnurlResponse.ok) {
                        throw new Error('Failed to fetch LNURL endpoint');
                    }

                    const lnurlData = await lnurlResponse.json();

                    // Convert sats to millisats
                    const amountMillisats = parseInt(amountSats) * 1000;

                    // Check bounds
                    if (amountMillisats < lnurlData.minSendable || amountMillisats > lnurlData.maxSendable) {
                        throw new Error(`Amount must be between ${lnurlData.minSendable / 1000} and ${lnurlData.maxSendable / 1000} sats`);
                    }

                    // Build callback URL
                    const callbackUrl = new URL(lnurlData.callback);
                    callbackUrl.searchParams.set('amount', amountMillisats);

                    // Add comment if allowed
                    if (comment && lnurlData.commentAllowed) {
                        callbackUrl.searchParams.set('comment', comment.substring(0, lnurlData.commentAllowed));
                    }

                    // Add nostr params for zap
                    if (lnurlData.allowsNostr && lnurlData.nostrPubkey) {
                        // Create zap request event
                        const zapRequest = await this.createZapRequest(amountSats, comment);
                        if (zapRequest) {
                            callbackUrl.searchParams.set('nostr', JSON.stringify(zapRequest));
                        }
                    }

                    // Fetch invoice
                    const invoiceResponse = await fetch(callbackUrl.toString());
                    if (!invoiceResponse.ok) {
                        throw new Error('Failed to fetch invoice');
                    }

                    const invoiceData = await invoiceResponse.json();

                    if (invoiceData.pr) {
                        return {
                            pr: invoiceData.pr,
                            successAction: invoiceData.successAction,
                            verify: invoiceData.verify,
                            amount: amountSats
                        };
                    } else {
                        throw new Error('No payment request in response');
                    }
                } catch (error) {
                    console.error('Error fetching lightning invoice:', error);
                    throw error;
                }
            }

            // Resolve any pending waiters for a user's lightning address
            notifyLightningAddress(pubkey, address) {
                const waiters = this.pendingLightningWaiters.get(pubkey);
                if (!waiters) return;
                for (const resolve of Array.from(waiters)) {
                    try { resolve(address); } catch (_) { }
                }
                this.pendingLightningWaiters.delete(pubkey);
            }

            // Wait for a user's lightning address to be discovered
            waitForLightningAddress(pubkey, timeoutMs = 8000) {
                // If already cached, resolve immediately
                if (this.userLightningAddresses.has(pubkey)) {
                    return Promise.resolve(this.userLightningAddresses.get(pubkey));
                }

                return new Promise((resolve) => {
                    const resolver = (addr) => resolve(addr || null);

                    // Register waiter
                    if (!this.pendingLightningWaiters.has(pubkey)) {
                        this.pendingLightningWaiters.set(pubkey, new Set());
                    }
                    const set = this.pendingLightningWaiters.get(pubkey);
                    set.add(resolver);

                    // Timeout fallback
                    const timer = setTimeout(() => {
                        // Clean up this resolver to prevent leaks
                        const s = this.pendingLightningWaiters.get(pubkey);
                        if (s) {
                            s.delete(resolver);
                            if (s.size === 0) this.pendingLightningWaiters.delete(pubkey);
                        }
                        resolve(null);
                    }, timeoutMs);

                    // Wrap resolver to clear timeout when it fires
                    const wrapped = (addr) => {
                        clearTimeout(timer);
                        resolve(addr || null);
                    };

                    // Replace the bare resolver with a wrapped one that clears the timeout
                    set.delete(resolver);
                    set.add(wrapped);
                });
            }

            async fetchLightningAddressForUser(pubkey) {
                // Serve from cache if available
                if (this.userLightningAddresses.has(pubkey)) {
                    return this.userLightningAddresses.get(pubkey);
                }

                try { this.requestUserProfile(pubkey); } catch (_) { }

                // Fire a direct, one-shot profile request to all connected relays
                const subId = 'ln-addr-' + Math.random().toString(36).slice(2);
                const req = ["REQ", subId, { kinds: [0], authors: [pubkey], limit: 1 }];
                try { this.sendToRelay(req); } catch (_) { }

                // Wait for handleEvent(kind 0) to notice LUD16/LUD06 (or timeout)
                const addr = await this.waitForLightningAddress(pubkey, 8000);

                try { this.sendToRelay(["CLOSE", subId]); } catch (_) { }

                return addr;
            }

            async loadLightningAddress() {
                // Only load if we have a pubkey
                if (!this.pubkey) return;

                // First, try to load from pubkey-specific localStorage
                const saved = localStorage.getItem(`nym_lightning_address_${this.pubkey}`);
                if (saved) {
                    this.lightningAddress = saved;
                    this.updateLightningAddressDisplay();
                    return;
                }

                // If not in localStorage, try to fetch from Nostr profile
                const profileAddress = await this.fetchLightningAddressForUser(this.pubkey);
                if (profileAddress) {
                    this.lightningAddress = profileAddress;
                    // Cache it in localStorage for this pubkey
                    localStorage.setItem(`nym_lightning_address_${this.pubkey}`, profileAddress);
                    this.updateLightningAddressDisplay();
                }
            }

            async saveLightningAddress(address) {
                if (address) {
                    this.lightningAddress = address;
                    // Save with pubkey-specific key
                    localStorage.setItem(`nym_lightning_address_${this.pubkey}`, address);

                    // Always save to Nostr profile (merging with existing data)
                    await this.saveToNostrProfile();
                } else {
                    this.lightningAddress = null;
                    localStorage.removeItem(`nym_lightning_address_${this.pubkey}`);
                    // Only remove from local storage
                }

                this.updateLightningAddressDisplay();
            }

            updateLightningAddressDisplay() {
                const display = document.getElementById('lightningAddressDisplay');
                const value = document.getElementById('lightningAddressValue');

                if (this.lightningAddress && display && value) {
                    display.style.display = 'flex';
                    value.textContent = this.lightningAddress;
                } else if (display) {
                    display.style.display = 'none';
                }
            }

            async saveToNostrProfile() {
                if (!this.pubkey) return;

                try {
                    let profileToSave;

                    // For persistent connections, preserve existing profile data
                    if (this.connectionMode !== 'ephemeral') {
                        // Fetch current profile if we don't have it
                        if (!this.originalProfile) {
                            await this.fetchProfileFromRelay(this.pubkey);
                        }

                        // Start with existing profile or empty object
                        profileToSave = { ...(this.originalProfile || {}) };

                        // Update only the specific fields we manage, don't delete others
                        profileToSave.name = this.nym;
                        profileToSave.display_name = this.nym;

                        // Update lightning address if we have one
                        if (this.lightningAddress) {
                            profileToSave.lud16 = this.lightningAddress;
                        }
                    } else {
                        // Ephemeral mode - minimal profile
                        profileToSave = {
                            name: this.nym,
                            display_name: this.nym,
                            lud16: this.lightningAddress,
                            about: `NYM user - ${this.nym}`
                        };
                    }

                    const profileEvent = {
                        kind: 0,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [],
                        content: JSON.stringify(profileToSave),
                        pubkey: this.pubkey
                    };

                    // Sign based on connection mode
                    let signedEvent;
                    if (this.connectionMode === 'extension' && window.nostr) {
                        signedEvent = await window.nostr.signEvent(profileEvent);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(profileEvent, this.privkey);
                    }

                    if (signedEvent) {
                        this.sendToRelay(["EVENT", signedEvent]);
                        console.log('Profile saved to Nostr, preserved fields:', Object.keys(profileToSave));
                    }
                } catch (error) {
                    console.error('Failed to save profile:', error);
                }
            }

            async fetchLightningAddressFromProfile(pubkey) {
                // Create a request for the user's profile
                const subscription = [
                    "REQ",
                    "profile-ln-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [0],
                        authors: [pubkey],
                        limit: 1
                    }
                ];

                // Send request
                this.sendToRelay(subscription);

                // Set timeout to close subscription
                setTimeout(() => {
                    this.sendToRelay(["CLOSE", subscription[1]]);
                }, 3000);
            }

            // Show zap modal
            showZapModal(messageId, recipientPubkey, recipientNym) {
                // Check if recipient has lightning address
                const lnAddress = this.userLightningAddresses.get(recipientPubkey);

                if (!lnAddress) {
                    this.displaySystemMessage(`${recipientNym} doesn't have a lightning address set`);
                    return;
                }

                // Store target info
                this.currentZapTarget = {
                    messageId,
                    recipientPubkey,
                    recipientNym,
                    lnAddress
                };

                // Reset modal state
                document.getElementById('zapAmountSection').style.display = 'block';
                document.getElementById('zapInvoiceSection').style.display = 'none';
                document.getElementById('zapRecipientInfo').textContent = `Zapping @${recipientNym}`;
                document.getElementById('zapCustomAmount').value = '';
                document.getElementById('zapComment').value = '';
                document.getElementById('zapSendBtn').textContent = 'Generate Invoice';
                document.getElementById('zapSendBtn').onclick = () => this.generateZapInvoice();

                // Clear selected amounts
                document.querySelectorAll('.zap-amount-btn').forEach(btn => {
                    btn.classList.remove('selected');
                    btn.onclick = (e) => {
                        document.querySelectorAll('.zap-amount-btn').forEach(b => b.classList.remove('selected'));
                        e.target.closest('.zap-amount-btn').classList.add('selected');
                        document.getElementById('zapCustomAmount').value = '';
                    };
                });

                // Show modal
                document.getElementById('zapModal').classList.add('active');
            }

            showProfileZapModal(recipientPubkey, recipientNym, lnAddress) {
                // Store target info for profile zap (no messageId)
                this.currentZapTarget = {
                    messageId: null, // No message ID for profile zaps
                    recipientPubkey,
                    recipientNym,
                    lnAddress,
                    isProfileZap: true
                };

                // Reset modal state
                document.getElementById('zapAmountSection').style.display = 'block';
                document.getElementById('zapInvoiceSection').style.display = 'none';
                document.getElementById('zapRecipientInfo').textContent = `Zapping @${recipientNym}'s profile`;
                document.getElementById('zapCustomAmount').value = '';
                document.getElementById('zapComment').value = '';
                document.getElementById('zapSendBtn').textContent = 'Generate Invoice';
                document.getElementById('zapSendBtn').onclick = () => this.generateZapInvoice();

                // Clear selected amounts
                document.querySelectorAll('.zap-amount-btn').forEach(btn => {
                    btn.classList.remove('selected');
                    btn.onclick = (e) => {
                        document.querySelectorAll('.zap-amount-btn').forEach(b => b.classList.remove('selected'));
                        e.target.closest('.zap-amount-btn').classList.add('selected');
                        document.getElementById('zapCustomAmount').value = '';
                    };
                });

                // Show modal
                document.getElementById('zapModal').classList.add('active');
            }

            cleanupOldLightningAddress() {
                // Remove old non-pubkey-specific entry if it exists
                const oldAddress = localStorage.getItem('nym_lightning_address');
                if (oldAddress) {
                    localStorage.removeItem('nym_lightning_address');
                    console.log('Cleaned up old lightning address format');
                }
            }

            // Create zap request event (NIP-57)
            async createZapRequest(amountSats, comment) {
                try {
                    if (!this.currentZapTarget) {
                        console.error('No target for zap request');
                        return null;
                    }

                    const zapRequest = {
                        kind: 9734,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['p', this.currentZapTarget.recipientPubkey], // Recipient of zap
                            ['amount', (parseInt(amountSats) * 1000).toString()], // Amount in millisats
                            ['relays', ...this.broadcastRelays.slice(0, 5)] // Limit to 5 relays
                        ],
                        content: comment || '',
                        pubkey: this.pubkey
                    };

                    // Add event tag only if this is a message zap (not profile zap)
                    if (this.currentZapTarget.messageId) {
                        zapRequest.tags.unshift(['e', this.currentZapTarget.messageId]); // Event being zapped

                        let originalKind = '23333'; // Default
                        if (this.inPMMode) {
                            originalKind = '1059'; // PMs via NIP-17
                        } else if (this.currentCommunity) {
                            originalKind = '4550'; // Community post
                        } else if (this.currentGeohash) {
                            originalKind = '20000';
                        }
                        zapRequest.tags.push(['k', originalKind]);
                    }

                    // Sign the request
                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        signedEvent = await window.nostr.signEvent(zapRequest);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(zapRequest, this.privkey);
                    }

                    return signedEvent;
                } catch (error) {
                    console.error('Failed to create zap request:', error);
                    return null;
                }
            }

            // Generate and display invoice
            async generateZapInvoice() {
                if (!this.currentZapTarget) return;

                // Get amount
                const selectedBtn = document.querySelector('.zap-amount-btn.selected');
                const customAmount = document.getElementById('zapCustomAmount').value;
                const amount = customAmount || (selectedBtn ? selectedBtn.dataset.amount : null);

                if (!amount || amount <= 0) {
                    this.displaySystemMessage('Please select or enter an amount');
                    return;
                }

                const comment = document.getElementById('zapComment').value || '';

                // Show loading state
                document.getElementById('zapAmountSection').style.display = 'none';
                document.getElementById('zapInvoiceSection').style.display = 'block';
                document.getElementById('zapStatus').className = 'zap-status checking';
                document.getElementById('zapStatus').innerHTML = '<span class="loader"></span> Generating invoice...';

                try {
                    // Fetch the invoice
                    const invoice = await this.fetchLightningInvoice(
                        this.currentZapTarget.lnAddress,
                        amount,
                        comment
                    );

                    if (invoice) {
                        this.currentZapInvoice = invoice;
                        this.zapInvoiceData = {
                            ...invoice,
                            messageId: this.currentZapTarget.messageId,
                            recipientPubkey: this.currentZapTarget.recipientPubkey
                        };

                        // Display invoice
                        this.displayZapInvoice(invoice);

                        // Start checking for payment
                        this.checkZapPayment(invoice);
                    }
                } catch (error) {
                    console.error('Failed to generate invoice:', error);
                    document.getElementById('zapStatus').className = 'zap-status';
                    document.getElementById('zapStatus').innerHTML = `Failed: ${error.message}`;
                }
            }

            // Display the invoice with QR code
            displayZapInvoice(invoice) {
                document.getElementById('zapStatus').style.display = 'none';
                document.getElementById('zapInvoiceDisplay').style.display = 'block';

                // Display invoice text
                const invoiceEl = document.getElementById('zapInvoice');
                invoiceEl.textContent = invoice.pr;

                // Generate QR code
                const qrContainer = document.getElementById('zapQRCode');
                qrContainer.innerHTML = ''; // Clear existing QR

                // Set container to center content
                qrContainer.style.cssText = 'text-align: center; display: flex; justify-content: center; align-items: center;';

                // Create QR code element with white border styling
                const qrDiv = document.createElement('div');
                qrDiv.id = 'zapQRCodeCanvas';
                qrDiv.style.cssText = 'display: inline-block; padding: 15px; background: white; border: 5px solid white; border-radius: 10px;';
                qrContainer.appendChild(qrDiv);

                // Generate QR using the invoice
                try {
                    new QRCode(qrDiv, {
                        text: invoice.pr,  // Just the raw invoice, no lightning: prefix
                        width: 200,
                        height: 200,
                        colorDark: "#000000",
                        colorLight: "#ffffff",
                        correctLevel: QRCode.CorrectLevel.L
                    });

                    console.log('Generated QR code for invoice:', invoice.pr.substring(0, 50) + '...');
                } catch (err) {
                    console.error('QRCode generation failed:', err);
                    // Fallback if QRCode library not loaded
                    qrContainer.innerHTML = `
            <div style="display: inline-block; padding: 20px; border: 5px solid white; background: white; color: black; text-align: center; border-radius: 10px;">
                <div style="font-size: 14px; margin-bottom: 10px;">Lightning Invoice</div>
                <div style="font-size: 10px; word-break: break-all;">${invoice.pr.substring(0, 60)}...</div>
                <div style="margin-top: 10px; font-size: 12px; color: red;">QR generation failed - copy invoice manually</div>
            </div>
        `;
                }

                // Update button
                document.getElementById('zapSendBtn').textContent = 'Close';
                document.getElementById('zapSendBtn').onclick = () => this.closeZapModal();
            }

            // Check if payment was made
            async checkZapPayment(invoice) {
                if (!invoice.verify) {
                    // No verify URL, just wait for zap receipt event
                    this.listenForZapReceipt();
                    return;
                }

                let checkCount = 0;
                const maxChecks = 60; // Check for up to 60 seconds

                this.zapCheckInterval = setInterval(async () => {
                    checkCount++;

                    try {
                        const response = await fetch(invoice.verify);
                        const data = await response.json();

                        if (data.settled || data.paid) {
                            // Payment confirmed!
                            clearInterval(this.zapCheckInterval);
                            this.handleZapPaymentSuccess(invoice.amount);
                        } else if (checkCount >= maxChecks) {
                            // Timeout
                            clearInterval(this.zapCheckInterval);
                            document.getElementById('zapStatus').style.display = 'block';
                            document.getElementById('zapStatus').className = 'zap-status';
                            document.getElementById('zapStatus').innerHTML = 'Payment timeout - please check your wallet';
                        }
                    } catch (error) {
                        console.error('Error checking payment:', error);
                    }
                }, 1000); // Check every second
            }

            // Listen for zap receipt events
            listenForZapReceipt() {
                // Subscribe to zap receipt events (kind 9735) for this specific event
                const subscription = [
                    "REQ",
                    "zap-receipt-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [9735],
                        "#e": [this.currentZapTarget.messageId],
                        since: Math.floor(Date.now() / 1000) - 300, // Last 5 minutes
                        limit: 10
                    }
                ];

                this.sendToRelay(subscription);

                // Also close the subscription after 60 seconds
                setTimeout(() => {
                    this.sendToRelay(["CLOSE", subscription[1]]);
                }, 60000);
            }

            // Handle successful payment
            handleZapPaymentSuccess(amount) {
                if (!this.currentZapTarget) return;

                // Clear check interval
                if (this.zapCheckInterval) {
                    clearInterval(this.zapCheckInterval);
                    this.zapCheckInterval = null;
                }

                // Update UI
                document.getElementById('zapInvoiceDisplay').style.display = 'none';
                document.getElementById('zapStatus').style.display = 'block';
                document.getElementById('zapStatus').className = 'zap-status paid';
                document.getElementById('zapStatus').innerHTML = `
        <div style="font-size: 24px; margin-bottom: 10px;">⚡</div>
        <div>Zap sent successfully!</div>
        <div style="font-size: 20px; margin-top: 10px;">${amount} sats</div>
    `;

                // Close modal after 2 seconds
                setTimeout(() => {
                    this.closeZapModal();
                }, 2000);
            }

            // Handle zap receipt events (NIP-57)
            handleZapReceipt(event) {
                if (event.kind !== 9735) return;

                // Parse zap receipt
                const eTag = event.tags.find(t => t[0] === 'e');
                const pTag = event.tags.find(t => t[0] === 'p');
                const boltTag = event.tags.find(t => t[0] === 'bolt11');
                const descriptionTag = event.tags.find(t => t[0] === 'description');

                if (!eTag || !boltTag) return;

                const messageId = eTag[1];
                const bolt11 = boltTag[1];

                // Parse amount from bolt11
                const amount = this.parseAmountFromBolt11(bolt11);

                if (amount) {
                    // Get zapper pubkey from description if available
                    let zapperPubkey = event.pubkey;

                    if (descriptionTag) {
                        try {
                            const zapRequest = JSON.parse(descriptionTag[1]);
                            if (zapRequest.pubkey) {
                                zapperPubkey = zapRequest.pubkey;
                            }

                            // Optional: Verify the k tag to ensure it's for supported kinds
                            const kTag = zapRequest.tags?.find(t => t[0] === 'k');
                            if (kTag && !['20000', '23333', '1059', '4550'].includes(kTag[1])) {
                                return;
                            }
                        } catch (e) {
                            // Ignore parse errors
                        }
                    }

                    // Initialize zaps tracking for this message if needed
                    if (!this.zaps.has(messageId)) {
                        this.zaps.set(messageId, {
                            receipts: new Set(), // Track receipt IDs to prevent duplicates
                            amounts: new Map()   // Map of pubkey -> total amount
                        });
                    }

                    const messageZaps = this.zaps.get(messageId);

                    // Check if we've already processed this receipt (deduplication)
                    if (messageZaps.receipts.has(event.id)) {
                        return; // Already processed this zap receipt
                    }

                    // Mark this receipt as processed
                    messageZaps.receipts.add(event.id);

                    // Update the amount for this zapper
                    const currentAmount = messageZaps.amounts.get(zapperPubkey) || 0;
                    messageZaps.amounts.set(zapperPubkey, currentAmount + amount);

                    // Update display for this message
                    this.updateMessageZaps(messageId);

                    // Check if this is for our current pending zap
                    if (this.currentZapTarget &&
                        this.currentZapTarget.messageId === messageId &&
                        zapperPubkey === this.pubkey) {
                        this.handleZapPaymentSuccess(amount);
                    }
                }
            }

            // Parse amount from bolt11 invoice (simplified)
            parseAmountFromBolt11(bolt11) {
                const match = bolt11.match(/lnbc(\d+)([munp])/i);
                if (match) {
                    const amount = parseInt(match[1]);
                    const multiplier = match[2];

                    switch (multiplier) {
                        case 'm': return amount * 100000; // millisats to sats
                        case 'u': return amount * 100; // microsats to sats
                        case 'n': return Math.round(amount / 10); // nanosats to sats
                        case 'p': return Math.round(amount / 10000); // picosats to sats
                        default: return amount;
                    }
                }
                return null;
            }

            // Update message with zap display
            updateMessageZaps(messageId) {
                const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
                if (!messageEl) return;

                const messageZaps = this.zaps.get(messageId);

                // Find or create reactions row
                let reactionsRow = messageEl.querySelector('.reactions-row');
                if (!reactionsRow) {
                    reactionsRow = document.createElement('div');
                    reactionsRow.className = 'reactions-row';
                    messageEl.appendChild(reactionsRow);
                }

                // Remove existing zap badges
                const existingZap = reactionsRow.querySelector('.zap-badge');
                if (existingZap) {
                    existingZap.remove();
                }
                const existingZapBtn = reactionsRow.querySelector('.add-zap-btn');
                if (existingZapBtn) {
                    existingZapBtn.remove();
                }

                // Only add badges if there are zaps
                if (messageZaps && messageZaps.amounts.size > 0) {
                    // Calculate total zaps from the amounts map
                    let totalZaps = 0;
                    messageZaps.amounts.forEach(amount => {
                        totalZaps += amount;
                    });

                    const zapBadge = document.createElement('span');
                    zapBadge.className = 'zap-badge';
                    zapBadge.innerHTML = `
            <svg class="zap-icon" viewBox="0 0 24 24">
                <path d="M13 2L3 14h8l-1 8 10-12h-8l1-8z"/>
            </svg>
            ${totalZaps}
        `;

                    const zapperCount = messageZaps.amounts.size;
                    zapBadge.title = `${zapperCount} zapper${zapperCount > 1 ? 's' : ''} • ${totalZaps} sats total`;

                    // Insert at beginning of reactions row
                    reactionsRow.insertBefore(zapBadge, reactionsRow.firstChild);

                    // Add quick zap button ONLY if zaps exist and not own message
                    const pubkey = messageEl.dataset.pubkey;
                    if (pubkey && pubkey !== this.pubkey) {
                        const addZapBtn = document.createElement('span');
                        addZapBtn.className = 'add-zap-btn';
                        addZapBtn.innerHTML = `
                <svg viewBox="0 0 24 24">
                    <path d="M11 2L1 14h8l-1 8 10-12h-8l1-8z" stroke="var(--text)" fill="var(--text)"/>
                    <circle cx="19" cy="6" r="5" fill="var(--text)" stroke="none"></circle>
                    <line x1="19" y1="4" x2="19" y2="8" stroke="var(--bg)" stroke-width="1.5" stroke-linecap="round"></line>
                    <line x1="17" y1="6" x2="21" y2="6" stroke="var(--bg)" stroke-width="1.5" stroke-linecap="round"></line>
                </svg>
            `;
                        addZapBtn.title = 'Quick zap';
                        addZapBtn.onclick = async (e) => {
                            e.stopPropagation();
                            await this.handleQuickZap(messageId, pubkey, messageEl);
                        };

                        // Insert after zap badge
                        reactionsRow.insertBefore(addZapBtn, zapBadge.nextSibling);
                    }
                }
            }

            async handleQuickZap(messageId, pubkey, messageEl) {
                // Get the author's nym
                const author = messageEl.dataset.author;

                // Show loading message
                this.displaySystemMessage(`Checking if @${author} can receive zaps...`);

                try {
                    // Always fetch fresh to ensure we have the latest
                    const lnAddress = await this.fetchLightningAddressForUser(pubkey);

                    if (lnAddress) {
                        // User has lightning address, show zap modal
                        this.showZapModal(messageId, pubkey, author);
                    } else {
                        // No lightning address found
                        this.displaySystemMessage(`@${author} cannot receive zaps (no lightning address set)`);
                    }
                } catch (error) {
                    console.error('Error fetching lightning address:', error);
                    this.displaySystemMessage(`Failed to check if @${author} can receive zaps`);
                }
            }

            // Close zap modal
            closeZapModal() {
                const modal = document.getElementById('zapModal');
                modal.classList.remove('active');

                // Clear interval if running
                if (this.zapCheckInterval) {
                    clearInterval(this.zapCheckInterval);
                    this.zapCheckInterval = null;
                }

                // Reset state
                this.currentZapTarget = null;
                this.currentZapInvoice = null;
                this.zapInvoiceData = null;
            }

            // Copy invoice to clipboard
            copyZapInvoice() {
                if (!this.currentZapInvoice) return;

                navigator.clipboard.writeText(this.currentZapInvoice.pr).then(() => {
                    // Show feedback
                    const btn = event.target;
                    const originalText = btn.textContent;
                    btn.textContent = 'Copied!';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    this.displaySystemMessage('Failed to copy invoice');
                });
            }

            // Open invoice in wallet
            openInWallet() {
                if (!this.currentZapInvoice) return;

                // Try multiple methods to open wallet
                const invoice = this.currentZapInvoice.pr;

                // Check if invoice already has lightning: prefix
                const invoiceToOpen = invoice.toLowerCase().startsWith('lightning:') ?
                    invoice : `lightning:${invoice}`;

                // Try Flutter bridge first (for NYM native app)
                if (window.nymOpenExternal) {
                    console.log('Using nymOpenExternal for:', invoiceToOpen);
                    window.nymOpenExternal(invoiceToOpen);
                } else {
                    // Fallback to standard window.open (for regular browsers)
                    console.log('Fallback to window.open for:', invoiceToOpen);
                    window.open(invoiceToOpen, '_blank');
                }

                // Also copy to clipboard as fallback (just the raw invoice)
                navigator.clipboard.writeText(invoice).then(() => {
                    this.displaySystemMessage('Invoice copied - paste in your wallet');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    this.displaySystemMessage('Failed to copy invoice');
                });
            }


            // Discovering relays via NIP-66
            async discoverRelays() {
                try {
                    // Check if we need to refresh the relay list
                    const now = Date.now();
                    if (now - this.lastRelayDiscovery < this.relayDiscoveryInterval && this.discoveredRelays.size > 0) {
                        return;
                    }

                    // Try to load from cache first
                    this.loadCachedRelays();

                    // Connect to monitor relays to get relay list
                    for (const monitorRelay of this.monitorRelays) {
                        try {
                            await this.fetchRelaysFromMonitor(monitorRelay);
                        } catch (error) {
                            console.error(`Failed to fetch from monitor ${monitorRelay}:`, error);
                        }
                    }

                    // Save discovered relays to cache
                    this.saveCachedRelays();

                    this.lastRelayDiscovery = now;

                } catch (error) {
                    console.error('Failed to discover relays:', error);
                    // Fall back to broadcast relays if discovery fails
                    if (this.discoveredRelays.size === 0) {
                        this.broadcastRelays.forEach(relay => this.discoveredRelays.add(relay));
                    }
                }
            }

            async fetchRelaysFromMonitor(monitorUrl) {
                return new Promise((resolve, reject) => {
                    const ws = new WebSocket(monitorUrl);
                    const timeout = setTimeout(() => {
                        ws.close();
                        reject(new Error('Timeout fetching relay list'));
                    }, 10000);

                    ws.onopen = () => {
                        // Request relay metadata events (NIP-66 kind 30066)
                        const subscription = [
                            "REQ",
                            "relay-list-" + Math.random().toString(36).substring(7),
                            {
                                kinds: [30066], // NIP-66 relay metadata
                                limit: 500
                            }
                        ];
                        ws.send(JSON.stringify(subscription));
                    };

                    ws.onmessage = (event) => {
                        try {
                            const msg = JSON.parse(event.data);
                            if (Array.isArray(msg) && msg[0] === 'EVENT') {
                                const relayEvent = msg[2];
                                if (relayEvent && relayEvent.kind === 30066) {
                                    this.parseRelayMetadata(relayEvent);
                                }
                            } else if (Array.isArray(msg) && msg[0] === 'EOSE') {
                                clearTimeout(timeout);
                                ws.close();
                                resolve();
                            }
                        } catch (e) {
                            console.error('Failed to parse monitor message:', e);
                        }
                    };

                    ws.onerror = (error) => {
                        clearTimeout(timeout);
                        reject(error);
                    };
                });
            }

            parseRelayMetadata(event) {
                try {
                    // Extract relay URL from d tag
                    const dTag = event.tags.find(t => t[0] === 'd');
                    if (!dTag || !dTag[1]) return;

                    const relayUrl = dTag[1];

                    // Check if relay supports required NIPs
                    const nTags = event.tags.filter(t => t[0] === 'n');
                    const supportsRequired = nTags.some(t => t[1] === '1') || nTags.length === 0; // Basic protocol support

                    if (supportsRequired && relayUrl.startsWith('wss://')) {
                        this.discoveredRelays.add(relayUrl);
                    }
                } catch (error) {
                    console.error('Failed to parse relay metadata:', error);
                }
            }

            loadCachedRelays() {
                try {
                    const cached = localStorage.getItem('nym_discovered_relays');
                    if (cached) {
                        const data = JSON.parse(cached);
                        if (data.timestamp && Date.now() - data.timestamp < this.relayDiscoveryInterval) {
                            data.relays.forEach(relay => this.discoveredRelays.add(relay));
                        }
                    }
                } catch (error) {
                    console.error('Failed to load cached relays:', error);
                }
            }

            saveCachedRelays() {
                try {
                    const data = {
                        timestamp: Date.now(),
                        relays: Array.from(this.discoveredRelays)
                    };
                    localStorage.setItem('nym_discovered_relays', JSON.stringify(data));
                } catch (error) {
                    console.error('Failed to save cached relays:', error);
                }
            }

            async loadSyncedSettings() {
                if (!this.pubkey || this.connectionMode === 'ephemeral') return;

                // Request NIP-78 settings (kind 30078)
                const settingsSubscription = [
                    "REQ",
                    "settings-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [30078],
                        authors: [this.pubkey],
                        "#d": ["nym-settings"],
                        limit: 1
                    }
                ];

                this.sendToRelay(settingsSubscription);

                // Request standard mute list (kind 10000)
                const muteSubscription = [
                    "REQ",
                    "mutes-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [10000],
                        authors: [this.pubkey],
                        limit: 1
                    }
                ];

                this.sendToRelay(muteSubscription);

                // Close subscriptions after timeout
                setTimeout(() => {
                    this.sendToRelay(["CLOSE", settingsSubscription[1]]);
                    this.sendToRelay(["CLOSE", muteSubscription[1]]);
                }, 3000);
            }

            async saveSyncedSettings() {
                if (!this.pubkey) return;

                try {
                    // For ephemeral users, only sync lightning address
                    if (this.connectionMode === 'ephemeral') {
                        if (!this.lightningAddress) {
                            console.log('Ephemeral user - no lightning address to sync');
                            return;
                        }

                        const settingsData = {
                            lightningAddress: this.lightningAddress
                        };

                        const settingsEvent = {
                            kind: 30078,
                            created_at: Math.floor(Date.now() / 1000),
                            tags: [
                                ["d", "nym-settings"],
                                ["title", "NYM Settings"],
                                ["encrypted"]
                            ],
                            content: JSON.stringify(settingsData),
                            pubkey: this.pubkey
                        };

                        if (this.privkey) {
                            const signedSettingsEvent = window.NostrTools.finalizeEvent(settingsEvent, this.privkey);
                            this.sendToRelay(["EVENT", signedSettingsEvent]);
                            console.log('Lightning address synced for ephemeral user (kind 30078)');
                        }
                        return; // Don't sync anything else for ephemeral users
                    }

                    // Save NYM-specific settings (kind 30078)
                    const settingsData = {
                        theme: this.settings.theme,
                        sound: this.settings.sound,
                        autoscroll: this.settings.autoscroll,
                        showTimestamps: this.settings.showTimestamps,
                        timeFormat: this.settings.timeFormat,
                        sortByProximity: this.settings.sortByProximity,
                        blurOthersImages: this.blurOthersImages,
                        pinnedChannels: Array.from(this.pinnedChannels),
                        blockedChannels: Array.from(this.blockedChannels),
                        userJoinedChannels: Array.from(this.userJoinedChannels),
                        lightningAddress: this.lightningAddress,
                        dmForwardSecrecyEnabled: !!this.settings.dmForwardSecrecyEnabled,
                        dmTTLSeconds: this.settings.dmTTLSeconds || 86400
                    };

                    const settingsEvent = {
                        kind: 30078,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ["d", "nym-settings"],
                            ["title", "NYM Settings"],
                            ["encrypted"]
                        ],
                        content: JSON.stringify(settingsData),
                        pubkey: this.pubkey
                    };

                    // Sign and send settings event
                    let signedSettingsEvent;
                    if (this.connectionMode === 'extension' && window.nostr) {
                        signedSettingsEvent = await window.nostr.signEvent(settingsEvent);
                    } else if (this.connectionMode === 'nsec' && this.privkey) {
                        signedSettingsEvent = window.NostrTools.finalizeEvent(settingsEvent, this.privkey);
                    }

                    if (signedSettingsEvent) {
                        this.sendToRelay(["EVENT", signedSettingsEvent]);
                    }

                    // Save mute list (kind 10000)
                    const muteTags = [];

                    // Add blocked users as 'p' tags
                    for (const pubkey of this.blockedUsers) {
                        muteTags.push(["p", pubkey]);
                    }

                    // Add blocked keywords/phrases as 'word' tags
                    for (const keyword of this.blockedKeywords) {
                        muteTags.push(["word", keyword]);
                    }

                    const muteEvent = {
                        kind: 10000,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: muteTags,
                        content: "",
                        pubkey: this.pubkey
                    };

                    // Sign and send mute event
                    let signedMuteEvent;
                    if (this.connectionMode === 'extension' && window.nostr) {
                        signedMuteEvent = await window.nostr.signEvent(muteEvent);
                    } else if (this.connectionMode === 'nsec' && this.privkey) {
                        signedMuteEvent = window.NostrTools.finalizeEvent(muteEvent, this.privkey);
                    }

                    if (signedMuteEvent) {
                        this.sendToRelay(["EVENT", signedMuteEvent]);
                        console.log('Mute list synced to Nostr (kind 10000):', {
                            blockedUsers: this.blockedUsers.size,
                            blockedKeywords: this.blockedKeywords.size
                        });
                    }

                } catch (error) {
                    console.error('Failed to save synced settings:', error);
                }
            }

            discoverChannels() {
                // Create a mixed array of all channels
                const allChannels = [];

                // Add all standard channels
                this.commonChannels.forEach(channel => {
                    // Don't re-add if already exists or if user-joined
                    if (!this.channels.has(channel) && !this.userJoinedChannels.has(channel)) {
                        allChannels.push({
                            name: channel,
                            geohash: '',
                            type: 'standard',
                            sortKey: Math.random()
                        });
                    }
                });

                // Add all geohash channels
                this.commonGeohashes.forEach(geohash => {
                    // Don't re-add if already exists or if user-joined
                    if (!this.channels.has(geohash) && !this.userJoinedChannels.has(geohash)) {
                        allChannels.push({
                            name: geohash,
                            geohash: geohash,
                            type: 'geo',
                            sortKey: Math.random()
                        });
                    }
                });

                // Sort randomly to mix standard and geo channels
                allChannels.sort((a, b) => a.sortKey - b.sortKey);

                // Add channels to UI in mixed order
                allChannels.forEach(channel => {
                    this.addChannel(channel.name, channel.geohash);
                });
            }

            sendToRelay(message) {
                const msg = JSON.stringify(message);

                if (Array.isArray(message) && message[0] === 'EVENT') {
                    // For EVENT messages, send to broadcast relays and nosflare
                    this.broadcastEvent(message);
                } else if (Array.isArray(message) && message[0] === 'REQ') {
                    // For REQ messages, send to all relays EXCEPT sendit.nosflare.com
                    this.sendRequestToAllRelaysExceptNosflare(message);
                } else {
                    // For other messages (CLOSE, etc.), send to all relays
                    this.relayPool.forEach((relay, url) => {
                        if (relay.ws && relay.ws.readyState === WebSocket.OPEN) {
                            relay.ws.send(msg);
                        }
                    });
                }
            }

            sendRequestToAllRelaysExceptNosflare(message) {
                const msg = JSON.stringify(message);

                // Send REQ to all connected relays EXCEPT sendit.nosflare.com
                this.relayPool.forEach((relay, url) => {
                    if (relay.ws && relay.ws.readyState === WebSocket.OPEN && !['wss://sendit.nosflare.com', 'wss://relay.nosflare.com'].includes(url)) {
                        relay.ws.send(msg);
                    }
                });
            }

            broadcastEvent(message) {
                const msg = JSON.stringify(message);

                let evt = null;
                try {
                    if (Array.isArray(message) && message[0] === 'EVENT' && message[1] && typeof message[1] === 'object') {
                        evt = message[1];
                    }
                } catch (_) { }

                const wideFanout = evt && (evt.kind === 7 || evt.kind === 20000 || evt.kind === 23333 || evt.kind === 4550 || evt.kind === 1984 || evt.kind === 34550 || evt.kind === 9734 || evt.kind === 9735);

                if (wideFanout) {
                    // Send to every connected relay for maximum propagation
                    this.relayPool.forEach((relay, url) => {
                        if (relay.ws && relay.ws.readyState === WebSocket.OPEN) {
                            relay.ws.send(msg);
                        }
                    });
                } else {
                    // Broadcast relays + nosflare
                    this.broadcastRelays.forEach(relayUrl => {
                        const relay = this.relayPool.get(relayUrl);
                        if (relay && relay.ws && relay.ws.readyState === WebSocket.OPEN) {
                            relay.ws.send(msg);
                        }
                    });

                    // Also send to nosflare if connected, to ensure a widely reachable write endpoint
                    const nosflare = this.relayPool.get('wss://sendit.nosflare.com');
                    if (nosflare && nosflare.ws && nosflare.ws.readyState === WebSocket.OPEN) {
                        nosflare.ws.send(msg);
                    }
                }
            }

            sendRequestToAllRelays(message) {
                const msg = JSON.stringify(message);

                // Send REQ to all connected relays EXCEPT nosflare
                this.relayPool.forEach((relay, url) => {
                    if (relay.ws && relay.ws.readyState === WebSocket.OPEN && relay.type !== 'nosflare') {
                        relay.ws.send(msg);
                    }
                });
            }

            subscribeToAllRelays() {
                // Get all relays except nosflare
                const readableRelays = Array.from(this.relayPool.entries())
                    .filter(([url, relay]) => relay.type !== 'nosflare' && relay.ws && relay.ws.readyState === WebSocket.OPEN);

                if (readableRelays.length === 0) {
                    console.log('No readable relays connected yet');
                    return;
                }

                // Send subscriptions to each readable relay
                readableRelays.forEach(([url, relay]) => {
                    this.subscribeToSingleRelay(url);
                });

                // Also do channel discovery
                this.discoverChannels();
            }

            handleRelayMessage(msg, relayUrl) {
                if (!Array.isArray(msg)) return;

                const [type, ...data] = msg;

                switch (type) {
                    case 'EVENT':
                        const [subscriptionId, event] = data;

                        // Track what kinds this relay is sending us
                        if (event && event.kind) {
                            if (!this.relayKinds.has(relayUrl)) {
                                this.relayKinds.set(relayUrl, new Set());
                            }
                            const relayKindTracker = this.relayKinds.get(relayUrl);

                            // For reactions (kind 7), only count them if they have the right k tags
                            if (event.kind === 7) {
                                const kTag = event.tags?.find(t => t[0] === 'k');
                                if (kTag && ['20000', '23333', '1059', '4550'].includes(kTag[1])) {
                                    relayKindTracker.add(7);
                                }
                            } else {
                                // For other kinds, add them directly
                                relayKindTracker.add(event.kind);
                            }
                        }

                        // Handle profile events (kind 0) for lightning addresses
                        if (event && event.kind === 0) {
                            try {
                                const profile = JSON.parse(event.content);
                                const pubkey = event.pubkey;

                                if (profile.lud16 || profile.lud06) {
                                    const lnAddress = profile.lud16 || profile.lud06;
                                    this.userLightningAddresses.set(pubkey, lnAddress);
                                }

                                if (profile.name || profile.username || profile.display_name) {
                                    const profileName = (profile.name || profile.username || profile.display_name).substring(0, 20);
                                    if (!this.users.has(pubkey) || this.users.get(pubkey).nym.startsWith('anon-')) {
                                        this.users.set(pubkey, {
                                            nym: profileName,
                                            pubkey,
                                            lastSeen: Date.now(),
                                            status: 'online',
                                            channels: new Set()
                                        });
                                    } else {
                                        // Update existing user name without discarding channels/status
                                        const u = this.users.get(pubkey);
                                        u.nym = profileName;
                                        u.lastSeen = Date.now();
                                        this.users.set(pubkey, u);
                                    }

                                    // Refresh PM sidebar entry and any open PM header
                                    this.updatePMNicknameFromProfile(pubkey, profileName);
                                }
                            } catch (e) { }
                        }
                        // Deduplicate events by ID
                        if (event && event.id) {
                            if (this.eventDeduplication.has(event.id)) {
                                // We've already processed this event
                                return;
                            }

                            // Mark event as seen
                            this.eventDeduplication.set(event.id, true);

                            // Clean up old events periodically (keep last 10000)
                            if (this.eventDeduplication.size > 10000) {
                                const entriesToDelete = this.eventDeduplication.size - 10000;
                                let deleted = 0;
                                for (const key of this.eventDeduplication.keys()) {
                                    if (deleted >= entriesToDelete) break;
                                    this.eventDeduplication.delete(key);
                                    deleted++;
                                }
                            }
                        }

                        this.handleEvent(event);
                        break;
                    case 'OK':
                        // Event was accepted
                        break;
                    case 'EOSE':
                        // End of stored events
                        break;
                    case 'NOTICE':
                        const notice = data[0];
                        break;
                }
            }

            cleanupNonResponsiveRelays() {
                const now = Date.now();

                this.relayPool.forEach((relay, url) => {
                    if (relay.type === 'read') {
                        const kinds = this.relayKinds.get(url);

                        // Check if relay has sent any of our required kinds
                        if (kinds && kinds.size > 0) {
                            const hasRequiredKinds =
                                kinds.has(20000) || // geohash channels
                                kinds.has(23333) || // standard channels  
                                kinds.has(7) ||     // reactions (already filtered for our k tags)
                                kinds.has(1059);    // PMs

                            if (!hasRequiredKinds) {
                                relay.ws.close();
                                this.relayPool.delete(url);
                                this.relayKinds.delete(url);
                                this.blacklistedRelays.add(url);
                                this.updateConnectionStatus();
                            }
                        } else if (now - relay.connectedAt > this.relayVerificationTimeout) {
                            // No kinds received within timeout
                            relay.ws.close();
                            this.relayPool.delete(url);
                            this.relayKinds.delete(url);
                            this.blacklistedRelays.add(url);
                            this.updateConnectionStatus();
                        }
                    }
                });
            }

            async handleEvent(event) {
                const messageAge = Date.now() - (event.created_at * 1000);
                const isHistorical = messageAge > 10000; // Older than 10 seconds

                // Handle NIP-72 moderation events FIRST (before processing messages)
                if (event.kind === 5 && event.tags.some(t => t[0] === 'a' && t[1]?.includes('34550:'))) {
                    // Community deletion event
                    const aTag = event.tags.find(t => t[0] === 'a');
                    if (aTag) {
                        const [kind, adminPubkey, communityId] = aTag[1].split(':');

                        // Verify the deletion is from the community admin
                        const community = this.communityChannels.get(communityId);
                        if (community && community.admin === event.pubkey && event.pubkey === adminPubkey) {
                            // Remove the community
                            this.communityChannels.delete(communityId);
                            this.ownedCommunities.delete(communityId);
                            this.moderatedCommunities.delete(communityId);

                            // Remove from UI
                            const item = document.querySelector(`[data-community="${communityId}"]`);
                            if (item) item.remove();

                            this.displaySystemMessage(`Community "${community.name}" has been deleted by admin`);

                            // If currently viewing this community, switch to bar
                            if (this.currentCommunity === communityId) {
                                this.switchChannel('bar', '');
                            }
                        }
                    }
                    return;
                }

                // Handle NIP-72 moderation events FIRST (before processing messages)
                if (event.kind === 1984) { // NIP-56 reporting/moderation events
                    const pTag = event.tags.find(t => t[0] === 'p');
                    const aTag = event.tags.find(t => t[0] === 'a');
                    const actionTag = event.tags.find(t => t[0] === 'action');

                    if (pTag && aTag && actionTag) {
                        const targetPubkey = pTag[1];
                        const [kind, adminPubkey, communityId] = aTag[1].split(':');
                        const action = actionTag[1];

                        // Verify the moderation event is from admin or mod
                        const community = this.communityChannels.get(communityId);
                        if (!community) return;

                        const isFromAdmin = event.pubkey === community.admin;
                        const isFromMod = this.communityModerators.has(communityId) &&
                            this.communityModerators.get(communityId).has(event.pubkey);

                        if (!isFromAdmin && !isFromMod) {
                            console.log('Ignoring moderation event from non-admin/mod');
                            return;
                        }

                        // Mark this moderation event as processed
                        if (this.processedModerationEvents.has(event.id)) {
                            return; // Already processed
                        }
                        this.processedModerationEvents.add(event.id);

                        // Clean up old processed events (keep last 1000)
                        if (this.processedModerationEvents.size > 1000) {
                            const toDelete = Array.from(this.processedModerationEvents).slice(0, -1000);
                            toDelete.forEach(id => this.processedModerationEvents.delete(id));
                        }

                        // Process the moderation action
                        switch (action) {
                            case 'ban':
                                if (!this.communityBans.has(communityId)) {
                                    this.communityBans.set(communityId, new Set());
                                }
                                this.communityBans.get(communityId).add(targetPubkey);

                                // Hide messages from banned user if viewing this community
                                if (this.currentCommunity === communityId) {
                                    document.querySelectorAll('.message').forEach(msg => {
                                        if (msg.dataset.pubkey === targetPubkey) {
                                            msg.remove();
                                        }
                                    });
                                }

                                // Clean up stored messages
                                this.cleanupBannedMessages(communityId, targetPubkey);

                                // Show notification ONLY if in this community AND not from current user
                                if (this.currentCommunity === communityId && event.pubkey !== this.pubkey) {
                                    const targetNym = this.getNymFromPubkey(targetPubkey);
                                    const modNym = this.getNymFromPubkey(event.pubkey);
                                    this.displaySystemMessage(`${targetNym} was banned by ${modNym}`);
                                }
                                break;

                            case 'unban':
                                if (this.communityBans.has(communityId)) {
                                    this.communityBans.get(communityId).delete(targetPubkey);
                                }

                                // Show notification ONLY if in this community AND not from current user
                                if (this.currentCommunity === communityId && event.pubkey !== this.pubkey) {
                                    const targetNym = this.getNymFromPubkey(targetPubkey);
                                    const modNym = this.getNymFromPubkey(event.pubkey);
                                    this.displaySystemMessage(`${targetNym} was unbanned by ${modNym}`);
                                }
                                break;

                            case 'kick':
                                // Get expiry timestamp
                                const expiryTag = event.tags.find(t => t[0] === 'expiry');
                                if (expiryTag) {
                                    const kickExpiry = parseInt(expiryTag[1]);

                                    // Initialize temporary kicks map if needed
                                    if (!this.communityTemporaryKicks) {
                                        this.communityTemporaryKicks = new Map();
                                    }
                                    if (!this.communityTemporaryKicks.has(communityId)) {
                                        this.communityTemporaryKicks.set(communityId, new Map());
                                    }

                                    // Add the kick
                                    this.communityTemporaryKicks.get(communityId).set(targetPubkey, kickExpiry);

                                    // If the kicked user is us and we're in this community, kick us out
                                    if (targetPubkey === this.pubkey && this.currentCommunity === communityId) {
                                        const communityName = community.name;
                                        this.displaySystemMessage(`You have been kicked from ${communityName}. You can rejoin in 15 minutes.`);

                                        // Switch to #bar after a short delay
                                        setTimeout(() => {
                                            this.switchChannel('bar', '');
                                        }, 1500);
                                    }

                                    // Set up auto-cleanup after expiry
                                    const timeRemaining = kickExpiry - Date.now();
                                    if (timeRemaining > 0) {
                                        setTimeout(() => {
                                            if (this.communityTemporaryKicks.has(communityId)) {
                                                const kicks = this.communityTemporaryKicks.get(communityId);
                                                if (kicks.has(targetPubkey)) {
                                                    kicks.delete(targetPubkey);
                                                    if (targetPubkey === this.pubkey) {
                                                        this.displaySystemMessage(`Your kick from ${community?.name || 'the community'} has expired. You can rejoin now.`);
                                                    }
                                                }
                                            }
                                        }, timeRemaining);
                                    }
                                }
                                break;
                        }
                    }
                    return;
                }

                if (event.kind === 20000) {
                    // Handle geohash channel messages
                    const nymTag = event.tags.find(t => t[0] === 'n');
                    const geohashTag = event.tags.find(t => t[0] === 'g');

                    const nym = nymTag ? nymTag[1] : this.getNymFromPubkey(event.pubkey);
                    const geohash = geohashTag ? geohashTag[1] : '';

                    // Check if user is blocked or message contains blocked keywords
                    if (this.isNymBlocked(nym) || this.hasBlockedKeyword(event.content)) {
                        return;
                    }

                    if (this.isSpamMessage(event.content)) {
                        return;
                    }

                    // Check flooding FOR THIS CHANNEL (only for non-historical messages)
                    if (!isHistorical && this.isFlooding(event.pubkey, geohash)) {
                        return;
                    }

                    // Only track flood for new messages in this channel
                    if (!isHistorical) {
                        this.trackMessage(event.pubkey, geohash, isHistorical);
                    }

                    // Track notification state for this channel
                    const channelKey = geohash;
                    if (!this.channelNotificationTracking) {
                        this.channelNotificationTracking = new Map();
                    }
                    if (!this.channelNotificationTracking.has(channelKey)) {
                        this.channelNotificationTracking.set(channelKey, new Set());
                    }
                    const alreadyNotified = this.channelNotificationTracking.get(channelKey).has(event.id);

                    // Check for BRB auto-response (UNIVERSAL) - only for NEW messages
                    if (!isHistorical && this.isMentioned(event.content) && this.awayMessages.has(this.pubkey)) {
                        // Check if we haven't already responded to this user in this session
                        const responseKey = `brb_universal_${this.pubkey}_${nym}`;
                        if (!sessionStorage.getItem(responseKey)) {
                            sessionStorage.setItem(responseKey, '1');

                            // Send auto-response to the same channel where mentioned
                            const response = `@${nym} [Auto-Reply] ${this.awayMessages.get(this.pubkey)}`;
                            await this.publishMessage(response, geohash, geohash);
                        }
                    }

                    // Add channel if it's new (and not blocked)
                    if (geohash && !this.channels.has(geohash) && !this.isChannelBlocked(geohash, geohash)) {
                        this.addChannelToList(geohash, geohash);
                    }

                    const message = {
                        id: event.id,
                        author: nym,
                        pubkey: event.pubkey,
                        content: event.content,
                        timestamp: new Date(event.created_at * 1000),
                        channel: geohash ? geohash : 'unknown',
                        geohash: geohash,
                        isOwn: event.pubkey === this.pubkey,
                        isHistorical: isHistorical
                    };

                    // Don't display duplicate of own messages
                    if (!this.isDuplicateMessage(message)) {
                        this.displayMessage(message);
                        this.updateUserPresence(nym, event.pubkey, message.channel, geohash);

                        // Show notification if mentioned and not blocked
                        const shouldNotify = !message.isOwn &&
                            this.isMentioned(message.content) &&
                            !this.isNymBlocked(nym) &&
                            !isHistorical &&
                            !alreadyNotified &&
                            (document.hidden || this.currentChannel !== geohash || this.currentGeohash !== geohash);

                        if (shouldNotify) {
                            // Mark as notified
                            this.channelNotificationTracking.get(channelKey).add(event.id);

                            const channelInfo = {
                                type: 'geohash',
                                channel: geohash,
                                geohash: geohash,
                                id: event.id
                            };
                            this.showNotification(nym, message.content, channelInfo);
                        }
                    }
                } else if (event.kind === 23333) {
                    // Handle standard channel messages
                    const nymTag = event.tags.find(t => t[0] === 'n');
                    const channelTag = event.tags.find(t => t[0] === 'd');

                    const nym = nymTag ? nymTag[1] : this.getNymFromPubkey(event.pubkey);
                    const channel = channelTag ? channelTag[1] : 'bar';

                    // Check if user is blocked or message contains blocked keywords
                    if (this.isNymBlocked(nym) || this.hasBlockedKeyword(event.content)) {
                        return;
                    }

                    if (this.isSpamMessage(event.content)) {
                        return;
                    }

                    // Check flooding FOR THIS CHANNEL (only for non-historical messages)
                    if (!isHistorical && this.isFlooding(event.pubkey, channel)) {
                        return;
                    }

                    // Only track flood for new messages in this channel
                    if (!isHistorical) {
                        this.trackMessage(event.pubkey, channel, isHistorical);
                    }

                    // Track notification state for this channel
                    const channelKey = channel;
                    if (!this.channelNotificationTracking) {
                        this.channelNotificationTracking = new Map();
                    }
                    if (!this.channelNotificationTracking.has(channelKey)) {
                        this.channelNotificationTracking.set(channelKey, new Set());
                    }
                    const alreadyNotified = this.channelNotificationTracking.get(channelKey).has(event.id);

                    // Check for BRB auto-response (UNIVERSAL) - only for NEW messages
                    if (!isHistorical && this.isMentioned(event.content) && this.awayMessages.has(this.pubkey)) {
                        // Check if we haven't already responded to this user in this session
                        const responseKey = `brb_universal_${this.pubkey}_${nym}`;
                        if (!sessionStorage.getItem(responseKey)) {
                            sessionStorage.setItem(responseKey, '1');

                            // Send auto-response to the same channel where mentioned
                            const response = `@${nym} [Auto-Reply] ${this.awayMessages.get(this.pubkey)}`;
                            await this.publishMessage(response, channel, '');
                        }
                    }

                    // Add channel if it's new (and not blocked)
                    if (!this.channels.has(channel) && !this.isChannelBlocked(channel, '')) {
                        this.addChannelToList(channel, '');
                    }

                    const message = {
                        id: event.id,
                        author: nym,
                        pubkey: event.pubkey,
                        content: event.content,
                        timestamp: new Date(event.created_at * 1000),
                        channel: channel,
                        geohash: '',
                        isOwn: event.pubkey === this.pubkey,
                        isHistorical: isHistorical
                    };

                    // Don't display duplicate of own messages
                    if (!this.isDuplicateMessage(message)) {
                        this.displayMessage(message);
                        this.updateUserPresence(nym, event.pubkey, channel, '');

                        // Show notification if mentioned and not blocked
                        const shouldNotify = !message.isOwn &&
                            this.isMentioned(message.content) &&
                            !this.isNymBlocked(nym) &&
                            !isHistorical &&
                            !alreadyNotified &&
                            (document.hidden || this.currentChannel !== channel || this.currentGeohash !== '');

                        if (shouldNotify) {
                            // Mark as notified
                            this.channelNotificationTracking.get(channelKey).add(event.id);

                            const channelInfo = {
                                type: 'standard',
                                channel: channel,
                                geohash: '',
                                id: event.id
                            };
                            this.showNotification(nym, message.content, channelInfo);
                        }
                    }
                } else if (event.kind === 34550) {
                    // Handle COMMUNITY DEFINITIONS
                    const dTag = event.tags.find(t => t[0] === 'd');

                    if (dTag) {
                        const nameTag = event.tags.find(t => t[0] === 'name');
                        const descTag = event.tags.find(t => t[0] === 'description');
                        const imageTag = event.tags.find(t => t[0] === 'image');
                        const privacyTag = event.tags.find(t => t[0] === 'private' || t[0] === 'public');

                        if (!nameTag) {
                            return;
                        }

                        const communityId = dTag[1];
                        const name = nameTag[1];
                        const description = descTag ? descTag[1] : '';
                        const imageUrl = imageTag ? imageTag[1] : '';
                        const isPrivate = privacyTag ? privacyTag[0] === 'private' : false;

                        // Store or update community
                        this.communityChannels.set(communityId, {
                            name: name,
                            description: description,
                            imageUrl: imageUrl,
                            isPrivate: isPrivate,
                            admin: event.pubkey,
                            createdAt: event.created_at * 1000
                        });

                        // IMPORTANT: Don't show communities to ephemeral users
                        if (this.connectionMode === 'ephemeral') {
                            return; // Skip adding to UI for ephemeral users
                        }

                        // Filter out communities with spaces - don't add to UI
                        if (name.includes(' ')) {
                            return; // Don't add to UI, just store in map
                        }

                        // Check if this is the official NYM community
                        const isNYMCommunity = event.pubkey === this.verifiedDeveloper.pubkey &&
                            name.toLowerCase() === 'nym';

                        // For private communities, only show if user is a member, mod, or admin
                        if (isPrivate && !isNYMCommunity) {
                            const isAdmin = event.pubkey === this.pubkey;
                            const isMod = this.communityModerators.has(communityId) &&
                                this.communityModerators.get(communityId).has(this.pubkey);
                            const isMember = this.communityMembers.has(communityId) &&
                                this.communityMembers.get(communityId).has(this.pubkey);

                            if (!isAdmin && !isMod && !isMember) {
                                return; // Don't show private communities unless member
                            }
                        }

                        // Track if user owns this community
                        if (event.pubkey === this.pubkey) {
                            this.ownedCommunities.add(communityId);
                        }

                        // Parse moderators
                        const modTags = event.tags.filter(t => t[0] === 'p' && t[3] === 'moderator');
                        if (modTags.length > 0) {
                            if (!this.communityModerators.has(communityId)) {
                                this.communityModerators.set(communityId, new Set());
                            }
                            // Clear existing mods and repopulate from latest definition
                            this.communityModerators.get(communityId).clear();
                            modTags.forEach(tag => {
                                const modPubkey = tag[1];
                                this.communityModerators.get(communityId).add(modPubkey);

                                if (modPubkey === this.pubkey) {
                                    this.moderatedCommunities.add(communityId);

                                    // Add to UI if we're a moderator
                                    if (!document.querySelector(`[data-community="${communityId}"]`)) {
                                        this.addCommunityChannel(name, communityId, isPrivate);
                                        this.userJoinedChannels.add(communityId);
                                        this.saveUserChannels();
                                    }
                                }
                            });
                        } else {
                            // No moderator tags - clear moderators for this community
                            if (this.communityModerators.has(communityId)) {
                                this.communityModerators.get(communityId).clear();
                            }
                        }

                        // Parse banned users from community definition
                        const bannedTags = event.tags.filter(t => t[0] === 'p' && t[3] === 'banned');
                        if (bannedTags.length > 0) {
                            if (!this.communityBans.has(communityId)) {
                                this.communityBans.set(communityId, new Set());
                            }
                            // Clear existing bans and repopulate from latest definition
                            this.communityBans.get(communityId).clear();
                            bannedTags.forEach(tag => {
                                const bannedPubkey = tag[1];
                                this.communityBans.get(communityId).add(bannedPubkey);
                            });

                            // If we're currently viewing this community, remove banned users' messages
                            if (this.currentCommunity === communityId) {
                                bannedTags.forEach(tag => {
                                    const bannedPubkey = tag[1];
                                    // Remove from DOM
                                    document.querySelectorAll(`.message[data-pubkey="${bannedPubkey}"]`).forEach(msg => {
                                        msg.remove();
                                    });
                                    // Clean up stored messages
                                    this.cleanupBannedMessages(communityId, bannedPubkey);
                                });
                            }
                        } else {
                            // No banned tags means no bans - clear any local bans for this community
                            if (this.communityBans.has(communityId)) {
                                this.communityBans.get(communityId).clear();
                            }
                        }

                        // Add to UI if not already present
                        if (!document.querySelector(`[data-community="${communityId}"]`)) {

                            if (isNYMCommunity || event.pubkey === this.pubkey || !isPrivate) {
                                this.addCommunityChannel(name, communityId, isPrivate);

                                // Only mark as user-joined if owned or NYM community
                                if (isNYMCommunity || event.pubkey === this.pubkey) {
                                    this.userJoinedChannels.add(communityId);
                                }

                                // AUTO-PIN THE NYM COMMUNITY
                                if (isNYMCommunity) {
                                    this.pinnedChannels.add(communityId);
                                    this.savePinnedChannels();
                                }

                                if (event.pubkey === this.pubkey) {
                                    this.saveUserChannels();
                                }
                            }
                        }
                    }
                } else if (event.kind === 4550) {
                    // Handle COMMUNITY POSTS
                    const aTag = event.tags.find(t => t[0] === 'a');

                    if (aTag) {
                        const nymTag = event.tags.find(t => t[0] === 'n');

                        // Parse a tag: "34550:adminPubkey:communityId"
                        const [kind, adminPubkey, communityId] = aTag[1].split(':');

                        // CHECK IF USER IS BANNED BEFORE PROCESSING
                        if (this.communityBans.has(communityId) &&
                            this.communityBans.get(communityId).has(event.pubkey)) {
                            console.log(`Blocked message from banned user ${event.pubkey} in community ${communityId}`);
                            return; // Don't process messages from banned users AT ALL
                        }

                        // ALSO CHECK IF USER IS GLOBALLY BLOCKED
                        const nymForCheck = nymTag ? nymTag[1] : this.getNymFromPubkey(event.pubkey);
                        if (this.blockedUsers.has(event.pubkey) || this.isNymBlocked(nymForCheck)) {
                            console.log(`Blocked message from globally blocked user ${event.pubkey}`);
                            return;
                        }

                        const nym = nymTag ? nymTag[1] : this.getNymFromPubkey(event.pubkey);

                        // Check if user is blocked globally
                        if (this.isNymBlocked(nym) || this.hasBlockedKeyword(event.content)) {
                            return;
                        }

                        if (this.isSpamMessage(event.content)) {
                            return;
                        }

                        // Check if message is from this community
                        if (!this.communityChannels.has(communityId)) {
                            // Store community info if we don't have it
                            this.communityChannels.set(communityId, {
                                name: communityId.split('-')[0],
                                admin: adminPubkey,
                                createdAt: Date.now()
                            });
                        }

                        const messageAge = Date.now() - (event.created_at * 1000);
                        const isHistorical = messageAge > 10000;

                        // Check flooding
                        if (!isHistorical && this.isFlooding(event.pubkey, communityId)) {
                            return;
                        }

                        if (!isHistorical) {
                            this.trackMessage(event.pubkey, communityId, isHistorical);
                        }

                        const message = {
                            id: event.id,
                            author: nym,
                            pubkey: event.pubkey,
                            content: event.content,
                            timestamp: new Date(event.created_at * 1000),
                            channel: communityId,
                            geohash: '',
                            isCommunity: true,
                            communityId: communityId,
                            isOwn: event.pubkey === this.pubkey,
                            isHistorical: isHistorical
                        };

                        // Store message - Only store if not from banned user
                        if (!this.messages.has(communityId)) {
                            this.messages.set(communityId, []);
                        }

                        const exists = this.messages.get(communityId).some(m => m.id === event.id);
                        if (!exists) {
                            this.messages.get(communityId).push(message);
                            this.messages.get(communityId).sort((a, b) => a.timestamp - b.timestamp);
                        }

                        // Display if in this community - will be filtered by loadCommunityMessages
                        if (this.currentCommunity === communityId) {
                            if (!exists) {
                                this.displayMessage(message);
                                this.updateUserPresence(nym, event.pubkey, communityId, '');

                                // Track notification state for this community
                                if (!this.channelNotificationTracking) {
                                    this.channelNotificationTracking = new Map();
                                }
                                if (!this.channelNotificationTracking.has(communityId)) {
                                    this.channelNotificationTracking.set(communityId, new Set());
                                }
                                const alreadyNotified = this.channelNotificationTracking.get(communityId).has(event.id);

                                // Show notification if mentioned and not blocked
                                const shouldNotify = !message.isOwn &&
                                    this.isMentioned(message.content) &&
                                    !this.isNymBlocked(nym) &&
                                    !isHistorical &&
                                    !alreadyNotified &&
                                    (document.hidden || this.currentCommunity !== communityId);

                                if (shouldNotify) {
                                    // Mark as notified
                                    this.channelNotificationTracking.get(communityId).add(event.id);

                                    const channelInfo = {
                                        type: 'community',
                                        communityId: communityId,
                                        channel: communityId,
                                        id: event.id
                                    };
                                    this.showNotification(nym, message.content, channelInfo);
                                }
                            }
                        } else if (!message.isOwn && !isHistorical && !exists) {
                            // Update unread count for other communities
                            this.updateUnreadCount(communityId);
                        }
                    }
                } else if (event.kind === 7) {
                    // Handle reactions (NIP-25)
                    this.handleReaction(event);
                } else if (event.kind === 9735) {
                    // Handle zap receipt (NIP-57)
                    this.handleZapReceipt(event);
                } else if (event.kind === 1059) {
                    // Handle NIP-17 gift wrap (NIP-59 + NIP-44)
                    await this.handleGiftWrapDM(event);
                } else if (event.kind === 10000) {
                    // Handle mute list of users/keywords
                    this.handleMuteList(event);
                } else if (event.kind === 30078) {
                    // Handle synced settings
                    this.handleSyncedSettings(event);
                } else if (event.kind === 0) {
                    // Handle profile events (kind 0) for lightning addresses
                    try {
                        const profile = JSON.parse(event.content);
                        const pubkey = event.pubkey;

                        // Store lightning address if present
                        if (profile.lud16 || profile.lud06) {
                            const lnAddress = profile.lud16 || profile.lud06;
                            this.userLightningAddresses.set(pubkey, lnAddress);
                        }

                        // Update nym if we don't have one for this user
                        if (profile.name || profile.username || profile.display_name) {
                            const profileName = profile.name || profile.username || profile.display_name;
                            if (!this.users.has(pubkey) || this.users.get(pubkey).nym.startsWith('anon-')) {
                                this.users.set(pubkey, {
                                    nym: profileName.substring(0, 20),
                                    pubkey: pubkey,
                                    lastSeen: Date.now(),
                                    status: 'online',
                                    channels: new Set()
                                });
                            }
                        }
                    } catch (e) {
                        // Ignore profile parse errors
                    }
                }
            }

            isSpamMessage(content) {
                // Check if spam filter is disabled
                if (this.spamFilterEnabled === false) return false;

                // Remove whitespace to check the core content
                const trimmed = content.trim();

                // Allow empty messages or very short ones
                if (trimmed.length < 20) return false;

                // Block client spam
                if (trimmed.includes('joined the channel via bitchat.land')) return true;

                // Block non-nym community messages
                if (trimmed.includes('["client","chorus"]')) return true;

                // Check if it's a URL (contains :// or starts with www.)
                if (trimmed.includes('://') || trimmed.startsWith('www.')) return false;

                // Check for Lightning invoices (lnbc, lntb, lnts prefixes)
                if (/^ln(bc|tb|ts)/i.test(trimmed)) return false;

                // Check for Cashu tokens
                if (/^cashu/i.test(trimmed)) return false;

                // Check for Nostr identifiers (npub/nsec/note/nevent/naddr)
                if (/^(npub|nsec|note|nevent|naddr)1[a-z0-9]+$/i.test(trimmed)) return false;

                // Check for code blocks or formatted content
                if (trimmed.includes('```') || trimmed.includes('`')) return false;

                const words = trimmed.split(/[\s\u3000\u2000-\u200B\u0020\u00A0.,;!?。、，；！？\n]/);
                const longestWord = Math.max(...words.map(w => w.length));

                if (longestWord > 100) {
                    if (trimmed.startsWith('data:image')) return false;

                    const hasOnlyAlphaNumeric = /^[a-zA-Z0-9]+$/.test(trimmed);
                    if (hasOnlyAlphaNumeric && trimmed.length > 100) {
                        return true;
                    }

                    if (/^[a-zA-Z0-9]+$/.test(words.find(w => w.length > 100))) {
                        const longWord = words.find(w => w.length > 100);
                        const charFreq = {};
                        for (const char of longWord) {
                            charFreq[char] = (charFreq[char] || 0) + 1;
                        }

                        const frequencies = Object.values(charFreq);
                        const avgFreq = longWord.length / Object.keys(charFreq).length;
                        const variance = frequencies.reduce((sum, freq) => sum + Math.pow(freq - avgFreq, 2), 0) / frequencies.length;

                        if (variance < 2 && longWord.length > 100) {
                            return true;
                        }
                    }
                }

                return false;
            }

            async sendBRBResponse(mentioner, awayMessage) {
                // Send auto-response only once per mentioner
                const responseKey = `brb_${this.pubkey}_${mentioner}`;
                if (sessionStorage.getItem(responseKey)) {
                    return; // Already sent response to this user
                }

                sessionStorage.setItem(responseKey, '1');
                const response = `@${mentioner} [Auto-Reply] ${awayMessage}`;
                await this.publishMessage(response, this.currentChannel, this.currentGeohash);
            }

            handleSyncedSettings(event) {
                if (event.pubkey !== this.pubkey) return;

                try {
                    const settings = JSON.parse(event.content);

                    // Restore image blur settings
                    if (settings.blurOthersImages !== undefined) {
                        this.blurOthersImages = settings.blurOthersImages;
                        localStorage.setItem(`nym_image_blur_${this.pubkey}`, settings.blurOthersImages.toString());
                    }

                    // Restore proximity sorting preference
                    if (settings.sortByProximity !== undefined) {
                        this.settings.sortByProximity = settings.sortByProximity;
                        localStorage.setItem('nym_sort_proximity', settings.sortByProximity);

                        // If enabled, try to get location
                        if (settings.sortByProximity && !this.userLocation) {
                            navigator.geolocation.getCurrentPosition(
                                (position) => {
                                    this.userLocation = {
                                        lat: position.coords.latitude,
                                        lng: position.coords.longitude
                                    };
                                    this.sortChannelsByActivity();
                                    console.log('Location restored for proximity sorting');
                                },
                                (error) => {
                                    console.log('Location access denied during settings restore');
                                    this.settings.sortByProximity = false;
                                    localStorage.setItem('nym_sort_proximity', 'false');
                                }
                            );
                        }
                    }

                    // Apply theme
                    if (settings.theme) {
                        this.settings.theme = settings.theme;
                        this.applyTheme(settings.theme);
                        localStorage.setItem('nym_theme', settings.theme);
                    }

                    // Apply sound settings
                    if (settings.sound !== undefined) {
                        this.settings.sound = settings.sound;
                        localStorage.setItem('nym_sound', settings.sound);
                    }

                    // Apply autoscroll
                    if (settings.autoscroll !== undefined) {
                        this.settings.autoscroll = settings.autoscroll;
                        localStorage.setItem('nym_autoscroll', settings.autoscroll);
                    }

                    // Apply timestamp settings
                    if (settings.showTimestamps !== undefined) {
                        this.settings.showTimestamps = settings.showTimestamps;
                        localStorage.setItem('nym_timestamps', settings.showTimestamps);
                    }

                    // Apply time format settings
                    if (settings.timeFormat !== undefined) {
                        this.settings.timeFormat = settings.timeFormat;
                        localStorage.setItem('nym_time_format', settings.timeFormat);
                        if (document.querySelectorAll('.message-time').length > 0) {
                            this.refreshMessageTimestamps();
                        }
                    }

                    // Restore pinned channels
                    if (settings.pinnedChannels) {
                        this.pinnedChannels = new Set(settings.pinnedChannels);
                        localStorage.setItem('nym_pinned_channels', JSON.stringify(settings.pinnedChannels));
                        this.updateChannelPins();
                    }

                    // Restore blocked channels (keep this in custom settings)
                    if (settings.blockedChannels) {
                        this.blockedChannels = new Set(settings.blockedChannels);
                        localStorage.setItem('nym_blocked_channels', JSON.stringify(settings.blockedChannels));
                        this.updateBlockedChannelsList();
                    }

                    // Restore user joined channels
                    if (settings.userJoinedChannels) {
                        this.userJoinedChannels.clear();

                        settings.userJoinedChannels.forEach(key => {
                            this.userJoinedChannels.add(key);
                            if (!this.channels.has(key)) {
                                if (this.isValidGeohash(key)) {
                                    this.addChannel(key, key);
                                } else {
                                    this.addChannel(key, '');
                                }
                            }
                        });

                        localStorage.setItem('nym_user_joined_channels', JSON.stringify(settings.userJoinedChannels));
                        localStorage.setItem('nym_user_channels', JSON.stringify(
                            settings.userJoinedChannels.map(key => ({
                                key: key,
                                channel: this.isValidGeohash(key) ? key : key,
                                geohash: this.isValidGeohash(key) ? key : ''
                            }))
                        ));
                    }

                    // Restore lightning address
                    if (settings.lightningAddress) {
                        this.lightningAddress = settings.lightningAddress;
                        localStorage.setItem(`nym_lightning_address_${this.pubkey}`, settings.lightningAddress);
                        this.updateLightningAddressDisplay();

                        const lightningInput = document.getElementById('lightningAddressInput');
                        if (lightningInput) {
                            lightningInput.value = settings.lightningAddress;
                        }
                    }

                    // Update UI elements if settings modal is open
                    if (document.getElementById('settingsModal').classList.contains('active')) {
                        document.getElementById('themeSelect').value = this.settings.theme;
                        document.getElementById('soundSelect').value = this.settings.sound;
                        document.getElementById('autoscrollSelect').value = String(this.settings.autoscroll);
                        document.getElementById('timestampSelect').value = String(this.settings.showTimestamps);
                        document.getElementById('timeFormatSelect').value = this.settings.timeFormat;

                        const blurSelect = document.getElementById('blurImagesSelect');
                        if (blurSelect) {
                            blurSelect.value = String(this.blurOthersImages);
                        }

                        const timeFormatGroup = document.getElementById('timeFormatGroup');
                        if (timeFormatGroup) {
                            timeFormatGroup.style.display = this.settings.showTimestamps ? 'block' : 'none';
                        }
                    }
                    if (settings.dmForwardSecrecyEnabled !== undefined) {
                        this.settings.dmForwardSecrecyEnabled = !!settings.dmForwardSecrecyEnabled;
                        localStorage.setItem('nym_dm_fwdsec_enabled', String(this.settings.dmForwardSecrecyEnabled));
                    }
                    if (settings.dmTTLSeconds !== undefined) {
                        const ttl = parseInt(settings.dmTTLSeconds, 10);
                        this.settings.dmTTLSeconds = isFinite(ttl) && ttl > 0 ? ttl : 86400;
                        localStorage.setItem('nym_dm_ttl_seconds', String(this.settings.dmTTLSeconds));
                    }

                    // If modal open, reflect values
                    if (document.getElementById('settingsModal').classList.contains('active')) {
                        const dmEnabledSel = document.getElementById('dmForwardSecrecySelect');
                        const dmTtlSel = document.getElementById('dmTTLSelect');
                        const dmTtlGroup = document.getElementById('dmTTLGroup');
                        if (dmEnabledSel && dmTtlSel && dmTtlGroup) {
                            dmEnabledSel.value = this.settings.dmForwardSecrecyEnabled ? 'true' : 'false';
                            dmTtlSel.value = String(this.settings.dmTTLSeconds || 86400);
                            dmTtlGroup.style.display = this.settings.dmForwardSecrecyEnabled ? 'block' : 'none';
                        }
                    }
                } catch (error) {
                    console.error('Failed to parse synced settings:', error);
                }
            }

            handleMuteList(event) {
                if (event.pubkey !== this.pubkey || event.kind !== 10000) return;

                // Extract blocked users from 'p' tags
                const mutedPubkeys = event.tags
                    .filter(tag => tag[0] === 'p' && tag[1])
                    .map(tag => tag[1]);

                if (mutedPubkeys.length > 0) {
                    // Replace (not merge) with synced blocked users
                    this.blockedUsers = new Set(mutedPubkeys);
                    this.saveBlockedUsers();
                    this.updateBlockedList();
                    this.updateUserList();

                    // Hide messages from blocked users after mute list loads
                    mutedPubkeys.forEach(pubkey => {
                        this.hideMessagesFromBlockedUser(pubkey);
                    });
                }

                // Extract blocked keywords from 'word' tags
                const mutedWords = event.tags
                    .filter(tag => tag[0] === 'word' && tag[1])
                    .map(tag => tag[1]);

                if (mutedWords.length > 0) {
                    // Replace (not merge) with synced keywords
                    this.blockedKeywords = new Set(mutedWords);
                    this.saveBlockedKeywords();
                    this.updateKeywordList();

                    // Hide messages with blocked keywords after mute list loads
                    this.hideMessagesWithBlockedKeywords();
                }
            }

            handleReaction(event) {
                const reactionContent = event.content;
                const eTag = event.tags.find(t => t[0] === 'e');
                const kTag = event.tags.find(t => t[0] === 'k');

                if (!eTag) return;

                // Only process reactions for our supported kinds (include 1059 = NIP-17 gift wraps)
                if (kTag && !['20000', '23333', '1059', '4550'].includes(kTag[1])) {
                    return;
                }

                const messageId = eTag[1];
                const reactorNym = this.getNymFromPubkey(event.pubkey);

                // Store reaction with pubkey and nym
                if (!this.reactions.has(messageId)) {
                    this.reactions.set(messageId, new Map());
                }

                const messageReactions = this.reactions.get(messageId);
                if (!messageReactions.has(reactionContent)) {
                    messageReactions.set(reactionContent, new Map());
                }

                // Store pubkey with nym
                messageReactions.get(reactionContent).set(event.pubkey, reactorNym);

                // Update UI if message is visible
                this.updateMessageReactions(messageId);
            }

            updateMessageReactions(messageId) {
                const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
                if (!messageEl) return;

                const reactions = this.reactions.get(messageId);
                if (!reactions || reactions.size === 0) {
                    // Even if no reactions, update zaps display
                    this.updateMessageZaps(messageId);
                    return;
                }

                // Hide the hover reaction button since we have reactions
                const hoverReactionBtn = messageEl.querySelector('.reaction-btn');
                if (hoverReactionBtn) {
                    hoverReactionBtn.style.display = 'none';
                }

                // Remove existing reactions display but preserve zap badges
                let reactionsRow = messageEl.querySelector('.reactions-row');
                let zapBadge = null;
                let addZapBtn = null;

                if (reactionsRow) {
                    // Save zap badge and button if they exist
                    zapBadge = reactionsRow.querySelector('.zap-badge');
                    if (zapBadge) {
                        zapBadge = zapBadge.cloneNode(true);
                    }
                    addZapBtn = reactionsRow.querySelector('.add-zap-btn');
                    if (addZapBtn) {
                        addZapBtn = addZapBtn.cloneNode(true);
                    }
                }

                if (!reactionsRow) {
                    reactionsRow = document.createElement('div');
                    reactionsRow.className = 'reactions-row';
                    messageEl.appendChild(reactionsRow);
                }

                // Clear and rebuild reactions
                reactionsRow.innerHTML = '';

                // Re-add zap badge first if it exists
                if (zapBadge) {
                    reactionsRow.appendChild(zapBadge);
                }

                // Re-add quick zap button ONLY if it already existed (meaning there are zaps)
                if (addZapBtn) {
                    reactionsRow.appendChild(addZapBtn);
                    // Re-attach the click handler
                    const pubkey = messageEl.dataset.pubkey;
                    addZapBtn.onclick = async (e) => {
                        e.stopPropagation();
                        await this.handleQuickZap(messageId, pubkey, messageEl);
                    };
                }
                // DO NOT create a new quick zap button here - only in updateMessageZaps when zaps exist

                // Clear and rebuild reactions
                reactions.forEach((reactors, emoji) => {
                    const badge = document.createElement('span');

                    // Check if current user has already reacted with this emoji
                    const hasReacted = reactors.has(this.pubkey);

                    // Set class based on reaction state
                    badge.className = hasReacted ? 'reaction-badge user-reacted' : 'reaction-badge';
                    badge.dataset.emoji = emoji;
                    badge.dataset.messageId = messageId;

                    badge.innerHTML = `${emoji} ${reactors.size}`;

                    // Create tooltip with user names
                    if (hasReacted) {
                        const otherUsers = Array.from(reactors.entries())
                            .filter(([pk, nym]) => pk !== this.pubkey)
                            .map(([pk, nym]) => nym);
                        badge.title = otherUsers.length > 0 ?
                            `You and ${otherUsers.join(', ')}` :
                            'You reacted with this';
                    } else {
                        const users = Array.from(reactors.values()).join(', ');
                        badge.title = `Click to also react with ${emoji} | ${users}`;
                    }

                    // Add click handler that updates badge immediately
                    badge.onclick = async (e) => {
                        e.stopPropagation();
                        if (!hasReacted) {
                            // Immediately update the badge visual state
                            badge.className = 'reaction-badge user-reacted';
                            badge.style.background = 'rgba(0, 255, 0, 0.2)';
                            badge.style.borderColor = 'var(--primary)';
                            badge.style.boxShadow = '0 0 5px rgba(0, 255, 0, 0.3)';

                            // Update count
                            const newCount = reactors.size + 1;
                            badge.innerHTML = `${emoji} ${newCount}`;

                            // Send the reaction
                            await this.sendReaction(messageId, emoji);
                        } else {
                            this.displaySystemMessage(`You already reacted with ${emoji}`);
                        }
                    };

                    reactionsRow.appendChild(badge);
                });

                // Adds "add reaction" badge
                const addBtn = document.createElement('span');
                addBtn.className = 'add-reaction-btn';
                addBtn.innerHTML = `
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <circle cx="9" cy="9" r="1"></circle>
            <circle cx="15" cy="9" r="1"></circle>
            <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
            <circle cx="18" cy="6" r="5" fill="var(--text)" stroke="none"></circle>
            <line x1="18" y1="4" x2="18" y2="8" stroke="var(--bg)" stroke-width="1.5" stroke-linecap="round"></line>
            <line x1="16" y1="6" x2="20" y2="6" stroke="var(--bg)" stroke-width="1.5" stroke-linecap="round"></line>
        </svg>
    `;
                addBtn.title = 'Add reaction';
                addBtn.onclick = (e) => {
                    e.stopPropagation();
                    this.showEnhancedReactionPicker(messageId, addBtn);
                };
                reactionsRow.appendChild(addBtn);
            }

            showReactionPicker(messageId, button) {
                // Toggle if clicking same button
                if (this.enhancedEmojiModal && this.activeReactionPickerButton === button) {
                    this.closeEnhancedEmojiModal();
                    this.activeReactionPickerButton = null;
                    return;
                }

                // Remember which button opened this
                this.activeReactionPickerButton = button;

                // Use enhanced picker
                this.showEnhancedReactionPicker(messageId, button);
            }

            showEnhancedReactionPicker(messageId, button) {
                // Check if clicking the same button that opened the current modal
                if (this.enhancedEmojiModal && this.activeReactionPickerButton === button) {
                    this.closeEnhancedEmojiModal();
                    return;
                }

                // Close any existing picker
                this.closeEnhancedEmojiModal();

                // Remember which button opened this
                this.activeReactionPickerButton = button;

                const modal = document.createElement('div');
                modal.className = 'enhanced-emoji-modal active';

                // Create reverse lookup for emoji names
                const emojiToNames = {};
                Object.entries(this.emojiMap).forEach(([name, emoji]) => {
                    if (!emojiToNames[emoji]) {
                        emojiToNames[emoji] = [];
                    }
                    emojiToNames[emoji].push(name);
                });

                modal.innerHTML = `
        <div class="emoji-modal-header">
            <input type="text" class="emoji-search-input" placeholder="Search emoji by name..." id="emojiSearchInput">
        </div>
        ${this.recentEmojis.length > 0 ? `
            <div class="emoji-section">
                <div class="emoji-section-title">Recently Used</div>
                <div class="emoji-grid">
                    ${this.recentEmojis.map(emoji =>
                    `<button class="emoji-option" data-emoji="${emoji}" title="${emojiToNames[emoji] ? emojiToNames[emoji].join(', ') : ''}">${emoji}</button>`
                ).join('')}
                </div>
            </div>
        ` : ''}
        ${Object.entries(this.allEmojis).map(([category, emojis]) => `
            <div class="emoji-section" data-category="${category}">
                <div class="emoji-section-title">${category.charAt(0).toUpperCase() + category.slice(1)}</div>
                <div class="emoji-grid">
                    ${emojis.map(emoji => {
                    const names = emojiToNames[emoji] || [];
                    return `<button class="emoji-option" data-emoji="${emoji}" data-names="${names.join(' ')}" title="${names.join(', ')}">${emoji}</button>`;
                }).join('')}
                </div>
            </div>
        `).join('')}
    `;

                // Position modal
                const rect = button.getBoundingClientRect();
                modal.style.position = 'fixed';

                // Check if on mobile
                if (window.innerWidth <= 768) {
                    // Center on mobile
                    modal.style.top = '50%';
                    modal.style.left = '50%';
                    modal.style.transform = 'translate(-50%, -50%)';
                    modal.style.maxWidth = '90%';
                    modal.style.maxHeight = '80vh';
                    modal.style.zIndex = '10000';
                } else {
                    // Desktop positioning - check if near top of screen
                    const spaceBelow = window.innerHeight - rect.bottom;
                    const spaceAbove = rect.top;

                    if (spaceBelow > 450 || spaceBelow > spaceAbove) {
                        // Show below button
                        modal.style.top = (rect.bottom + 10) + 'px';
                        modal.style.bottom = 'auto';
                    } else {
                        // Show above button
                        modal.style.bottom = (window.innerHeight - rect.top + 10) + 'px';
                        modal.style.top = 'auto';
                    }

                    // Horizontal positioning
                    if (rect.left > window.innerWidth * 0.5) {
                        modal.style.right = Math.min(window.innerWidth - rect.right, 10) + 'px';
                        modal.style.left = 'auto';
                    } else {
                        modal.style.left = Math.max(rect.left, 10) + 'px';
                        modal.style.right = 'auto';
                    }

                    modal.style.maxHeight = '400px';
                }

                document.body.appendChild(modal);
                this.enhancedEmojiModal = modal;

                // Add search functionality
                const searchInput = modal.querySelector('#emojiSearchInput');
                searchInput.addEventListener('input', (e) => {
                    const search = e.target.value.toLowerCase();
                    modal.querySelectorAll('.emoji-option').forEach(btn => {
                        const emoji = btn.textContent;
                        const names = btn.dataset.names || '';
                        const shouldShow = !search ||
                            emoji.includes(search) ||
                            names.toLowerCase().includes(search);
                        btn.style.display = shouldShow ? '' : 'none';
                    });
                    // Hide empty sections
                    modal.querySelectorAll('.emoji-section').forEach(section => {
                        const hasVisible = Array.from(section.querySelectorAll('.emoji-option'))
                            .some(btn => btn.style.display !== 'none');
                        section.style.display = hasVisible ? '' : 'none';
                    });
                });

                // Add click handlers
                modal.querySelectorAll('.emoji-option').forEach(btn => {
                    btn.onclick = async (e) => {
                        e.stopPropagation();
                        const emoji = btn.dataset.emoji;
                        this.addToRecentEmojis(emoji);
                        await this.sendReaction(messageId, emoji);
                        this.closeEnhancedEmojiModal();
                    };
                });

                // Focus search
                searchInput.focus();
            }

            toggleEmojiPicker() {
                // Check if modal already exists
                if (this.enhancedEmojiModal) {
                    // Close existing modal
                    this.closeEnhancedEmojiModal();
                    return;
                }

                // Create modal for emoji picker
                const button = document.querySelector('.icon-btn.input-btn[title="Emoji"]');
                if (button) {
                    this.showEnhancedEmojiPickerForInput(button);
                }
            }

            showEnhancedEmojiPickerForInput(button) {
                // Close any existing picker
                this.closeEnhancedEmojiModal();

                const modal = document.createElement('div');
                modal.className = 'enhanced-emoji-modal active';

                // Create reverse lookup for emoji names
                const emojiToNames = {};
                Object.entries(this.emojiMap).forEach(([name, emoji]) => {
                    if (!emojiToNames[emoji]) {
                        emojiToNames[emoji] = [];
                    }
                    emojiToNames[emoji].push(name);
                });

                modal.innerHTML = `
        <div class="emoji-modal-header">
            <input type="text" class="emoji-search-input" placeholder="Search emoji by name..." id="emojiSearchInput">
        </div>
        ${this.recentEmojis.length > 0 ? `
            <div class="emoji-section">
                <div class="emoji-section-title">Recently Used</div>
                <div class="emoji-grid">
                    ${this.recentEmojis.map(emoji =>
                    `<button class="emoji-option" data-emoji="${emoji}" title="${emojiToNames[emoji] ? emojiToNames[emoji].join(', ') : ''}">${emoji}</button>`
                ).join('')}
                </div>
            </div>
        ` : ''}
        ${Object.entries(this.allEmojis).map(([category, emojis]) => `
            <div class="emoji-section" data-category="${category}">
                <div class="emoji-section-title">${category.charAt(0).toUpperCase() + category.slice(1)}</div>
                <div class="emoji-grid">
                    ${emojis.map(emoji => {
                    const names = emojiToNames[emoji] || [];
                    return `<button class="emoji-option" data-emoji="${emoji}" data-names="${names.join(' ')}" title="${names.join(', ')}">${emoji}</button>`;
                }).join('')}
                </div>
            </div>
        `).join('')}
    `;

                // Position near button
                const rect = button.getBoundingClientRect();
                modal.style.position = 'fixed';

                // Check if on mobile
                if (window.innerWidth <= 768) {
                    modal.style.bottom = '60px';
                    modal.style.left = '50%';
                    modal.style.transform = 'translateX(-50%)';
                    modal.style.right = 'auto';
                    modal.style.maxWidth = '90%';
                } else {
                    modal.style.bottom = (window.innerHeight - rect.top + 10) + 'px';
                    modal.style.right = Math.min(window.innerWidth - rect.right + 50, 10) + 'px';
                }

                document.body.appendChild(modal);
                this.enhancedEmojiModal = modal;

                // Add search functionality
                const searchInput = modal.querySelector('#emojiSearchInput');
                searchInput.addEventListener('input', (e) => {
                    const search = e.target.value.toLowerCase();
                    modal.querySelectorAll('.emoji-option').forEach(btn => {
                        const emoji = btn.textContent;
                        const names = btn.dataset.names || '';
                        const shouldShow = !search ||
                            emoji.includes(search) ||
                            names.toLowerCase().includes(search);
                        btn.style.display = shouldShow ? '' : 'none';
                    });
                    // Hide empty sections
                    modal.querySelectorAll('.emoji-section').forEach(section => {
                        const hasVisible = Array.from(section.querySelectorAll('.emoji-option'))
                            .some(btn => btn.style.display !== 'none');
                        section.style.display = hasVisible ? '' : 'none';
                    });
                });

                // Add click handlers for inserting emoji into input
                modal.querySelectorAll('.emoji-option').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        const emoji = btn.dataset.emoji;
                        this.insertEmoji(emoji);
                        this.closeEnhancedEmojiModal();
                    };
                });

                // Focus search
                searchInput.focus();
            }

            closeEnhancedEmojiModal() {
                if (this.enhancedEmojiModal) {
                    this.enhancedEmojiModal.remove();
                    this.enhancedEmojiModal = null;
                }
                // Clear the button reference
                this.activeReactionPickerButton = null;
            }

            async sendReaction(messageId, emoji) {
                try {
                    const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
                    if (!messageEl) return;

                    const targetPubkey = messageEl.dataset.pubkey;
                    if (!targetPubkey) return;

                    // Ensure local state contains this reaction so UI updates immediately
                    if (!this.reactions.has(messageId)) {
                        this.reactions.set(messageId, new Map());
                    }
                    const messageReactions = this.reactions.get(messageId);
                    if (!messageReactions.has(emoji)) {
                        messageReactions.set(emoji, new Map());
                    }
                    if (messageReactions.get(emoji).has(this.pubkey)) {
                        return; // Already reacted with this emoji
                    }
                    messageReactions.get(emoji).set(this.pubkey, this.nym);

                    // Infer original kind directly from the rendered message element/container context
                    const container = document.getElementById('messagesContainer');
                    let originalKind = '23333'; // default to standard
                    if (messageEl.classList.contains('pm')) {
                        originalKind = '1059'; // NIP-17 gift wrap
                    } else if (container && container.dataset && container.dataset.lastCommunity) {
                        originalKind = '4550';  // community post
                    } else if (container && container.dataset && container.dataset.lastChannel) {
                        const lc = container.dataset.lastChannel;
                        // lastChannel is "#geohash" or "channel"; treat geohash with leading "#" as kind 20000
                        if (lc.startsWith('#') && this.isValidGeohash(lc.substring(1))) {
                            originalKind = '20000';
                        } else {
                            originalKind = '23333';
                        }
                    } else if (this.currentCommunity) {
                        originalKind = '4550';
                    } else if (this.currentGeohash) {
                        originalKind = '20000';
                    }

                    const event = {
                        kind: 7,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['e', messageId],
                            ['p', targetPubkey],
                            ['k', originalKind]
                        ],
                        content: emoji,
                        pubkey: this.pubkey
                    };

                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        signedEvent = await window.nostr.signEvent(event);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                    }

                    if (signedEvent) {
                        this.sendToRelay(["EVENT", signedEvent]);
                        this.addToRecentEmojis(emoji);
                    } else {
                        messageReactions.get(emoji).delete(this.pubkey);
                        this.updateMessageReactions(messageId);
                        this.displaySystemMessage('Failed to sign reaction');
                    }
                } catch (error) {
                    console.error('Failed to send reaction:', error);
                    const messageReactions = this.reactions.get(messageId);
                    if (messageReactions && messageReactions.has(emoji)) {
                        messageReactions.get(emoji).delete(this.pubkey);
                        this.updateMessageReactions(messageId);
                    }
                }
            }

            trackMessage(pubkey, channel, isHistorical = false) {
                // Don't track historical messages from initial load
                if (isHistorical) {
                    return;
                }

                const now = Date.now();
                const channelKey = channel; // Use channel as key for per-channel tracking

                // Create channel-specific tracking
                if (!this.floodTracking.has(channelKey)) {
                    this.floodTracking.set(channelKey, new Map());
                }

                const channelTracking = this.floodTracking.get(channelKey);

                if (!channelTracking.has(pubkey)) {
                    channelTracking.set(pubkey, {
                        count: 1,
                        firstMessageTime: now,
                        blocked: false
                    });
                    return;
                }

                const tracking = channelTracking.get(pubkey);

                // Reset if more than 2 seconds have passed
                if (now - tracking.firstMessageTime > 2000) {
                    tracking.count = 1;
                    tracking.firstMessageTime = now;
                    tracking.blocked = false;
                } else {
                    tracking.count++;

                    // Block if more than 10 messages in 2 seconds IN THIS CHANNEL
                    if (tracking.count > 10 && !tracking.blocked) {
                        tracking.blocked = true;
                        tracking.blockedUntil = now + 900000; // 15 minutes

                        const nym = this.getNymFromPubkey(pubkey);
                    }
                }
            }

            isFlooding(pubkey, channel) {
                const channelTracking = this.floodTracking.get(channel);
                if (!channelTracking) return false;

                const tracking = channelTracking.get(pubkey);
                if (!tracking) return false;

                if (tracking.blocked) {
                    const now = Date.now();
                    if (now < tracking.blockedUntil) {
                        return true;
                    } else {
                        // Unblock after timeout
                        tracking.blocked = false;
                        tracking.blockedUntil = null;
                    }
                }

                return false;
            }

            // NIP-44 helpers (v2) using bundled nostr-tools API
            async encryptNIP44(plaintext, recipientPubkey) {
                // Try extension first (it does ECDH in the extension)
                if (window.nostr?.nip44?.encrypt) {
                    return await window.nostr.nip44.encrypt(recipientPubkey, plaintext);
                }
                // Local fallback derive conversation key and encrypt
                if (!this.privkey) throw new Error('No privkey available for NIP-44 encryption');
                const { nip44 } = window.NostrTools;
                const ck = nip44.getConversationKey(this.privkey, recipientPubkey);
                return nip44.encrypt(plaintext, ck);
            }

            async decryptNIP44(payload, senderPubkey) {
                // Try extension first
                if (window.nostr?.nip44?.decrypt) {
                    return await window.nostr.nip44.decrypt(senderPubkey, payload);
                }
                // Local fallback derive conversation key and decrypt
                if (!this.privkey) throw new Error('No privkey available for NIP-44 decryption');
                const { nip44 } = window.NostrTools;
                const ck = nip44.getConversationKey(this.privkey, senderPubkey);
                return nip44.decrypt(payload, ck);
            }

            randomNow() {
                const TWO_DAYS = 2 * 24 * 60 * 60;
                return Math.round(Date.now() / 1000 - Math.random() * TWO_DAYS);
            }

            nip59WrapEvent(event, senderPrivateKey, recipientPublicKey, expirationTs = null) {
                const NT = window.NostrTools;

                // Rumor (unsigned) with computed id
                const now = Math.floor(Date.now() / 1000);
                const rumor = {
                    created_at: now,
                    content: '',
                    tags: [],
                    ...event,
                    pubkey: NT.getPublicKey(senderPrivateKey)
                };
                rumor.id = NT.getEventHash(rumor);

                // Seal (kind 13)
                const ckSeal = NT.nip44.getConversationKey(senderPrivateKey, recipientPublicKey);
                const sealedContent = NT.nip44.encrypt(JSON.stringify(rumor), ckSeal);
                const sealUnsigned = {
                    kind: 13,
                    content: sealedContent,
                    created_at: this.randomNow(),
                    tags: []
                };
                const seal = NT.finalizeEvent(sealUnsigned, senderPrivateKey);

                // GiftWrap (kind 1059) with ephemeral keypair
                const ephSk = NT.generateSecretKey();
                const ephPk = NT.getPublicKey(ephSk);
                const ckWrap = NT.nip44.getConversationKey(ephSk, recipientPublicKey);
                const wrapContent = NT.nip44.encrypt(JSON.stringify(seal), ckWrap);
                const wrapUnsigned = {
                    kind: 1059,
                    content: wrapContent,
                    created_at: this.randomNow(),
                    tags: [['p', recipientPublicKey]],
                    pubkey: ephPk
                };

                // Add expiration only if enabled
                if (expirationTs) {
                    wrapUnsigned.tags.push(['expiration', String(expirationTs)]);
                }

                return NT.finalizeEvent(wrapUnsigned, ephSk);
            }

            nip59UnwrapEvent(wrap, recipientPrivateKey) {
                const NT = window.NostrTools;

                // Unwrap GiftWrap (ECDH with wrap.pubkey = ephemeral sender)
                const ckWrap = NT.nip44.getConversationKey(recipientPrivateKey, wrap.pubkey);
                const sealJson = NT.nip44.decrypt(wrap.content, ckWrap);
                const seal = JSON.parse(sealJson);

                // Unwrap Seal (ECDH with seal.pubkey = sender identity)
                const ckSeal = NT.nip44.getConversationKey(recipientPrivateKey, seal.pubkey);
                const rumorJson = NT.nip44.decrypt(seal.content, ckSeal);
                return JSON.parse(rumorJson); // rumor
            }

            // Send PM using NIP-17 (GiftWrap 1059) and optional forward secrecy
            async sendNIP17PM(content, recipientPubkey) {
                const now = Math.floor(Date.now() / 1000);

                const rumor = {
                    kind: 14,
                    created_at: now,
                    tags: [
                        ['p', recipientPubkey]
                    ],
                    content,
                    pubkey: this.pubkey
                };

                // Optional expiration (NIP-40) on gift wrap level
                const expirationTs = (this.settings?.dmForwardSecrecyEnabled && this.settings?.dmTTLSeconds > 0)
                    ? Math.floor(Date.now() / 1000) + this.settings.dmTTLSeconds
                    : null;

                // Local key available (ephemeral/nsec)
                if (this.privkey) {
                    const NT = window.NostrTools;
                    const wrapped = this.nip59WrapEvent(rumor, this.privkey, recipientPubkey, expirationTs);

                    this.sendToRelay(['EVENT', wrapped]);

                    // Show locally
                    const conversationKey = this.getPMConversationKey(recipientPubkey);
                    if (!this.pmMessages.has(conversationKey)) this.pmMessages.set(conversationKey, []);
                    this.pmMessages.get(conversationKey).push({
                        id: wrapped.id,
                        author: this.nym,
                        pubkey: this.pubkey,
                        content,
                        timestamp: new Date(),
                        isOwn: true,
                        isPM: true,
                        conversationKey,
                        conversationPubkey: recipientPubkey,
                        eventKind: 1059
                    });

                    this.addPMConversation(this.getNymFromPubkey(recipientPubkey), recipientPubkey, Date.now());
                    this.movePMToTop(recipientPubkey);

                    if (this.inPMMode && this.currentPM === recipientPubkey) {
                        this.displayMessage(this.pmMessages.get(conversationKey).slice(-1)[0]);
                    }
                    return true;
                }

                // Extension-only path (seal via extension, wrap locally)
                if (window.nostr?.nip44?.encrypt && window.nostr?.signEvent) {
                    const NT = window.NostrTools;

                    rumor.id = NT.getEventHash(rumor);

                    // Seal (kind 13) signed by identity in extension
                    const sealContent = await window.nostr.nip44.encrypt(recipientPubkey, JSON.stringify(rumor));
                    const sealUnsigned = {
                        kind: 13, content: sealContent, created_at: this.randomNow(), tags: []
                    };
                    const seal = await window.nostr.signEvent(sealUnsigned);

                    // GiftWrap (kind 1059) with local ephemeral
                    const ephSk = NT.generateSecretKey();
                    const ckWrap = NT.nip44.getConversationKey(ephSk, recipientPubkey);
                    const wrapContent = NT.nip44.encrypt(JSON.stringify(seal), ckWrap);
                    const wrapUnsigned = {
                        kind: 1059,
                        content: wrapContent,
                        created_at: this.randomNow(),
                        tags: [['p', recipientPubkey]]
                    };

                    // Add expiration only if enabled
                    if (expirationTs) {
                        wrapUnsigned.tags.push(['expiration', String(expirationTs)]);
                    }

                    const wrapped = NT.finalizeEvent(wrapUnsigned, ephSk);

                    this.sendToRelay(['EVENT', wrapped]);

                    // Show locally
                    const conversationKey = this.getPMConversationKey(recipientPubkey);
                    if (!this.pmMessages.has(conversationKey)) this.pmMessages.set(conversationKey, []);
                    this.pmMessages.get(conversationKey).push({
                        id: wrapped.id,
                        author: this.nym,
                        pubkey: this.pubkey,
                        content,
                        timestamp: new Date(),
                        isOwn: true,
                        isPM: true,
                        conversationKey,
                        conversationPubkey: recipientPubkey,
                        eventKind: 1059
                    });

                    this.addPMConversation(this.getNymFromPubkey(recipientPubkey), recipientPubkey, Date.now());
                    this.movePMToTop(recipientPubkey);

                    if (this.inPMMode && this.currentPM === recipientPubkey) {
                        this.displayMessage(this.pmMessages.get(conversationKey).slice(-1)[0]);
                    }
                    return true;
                }

                throw new Error('No signing/encryption available for NIP-17 (need local privkey or extension)');
            }

            // Receive NIP-17 (GiftWrap 1059): unwrap, verify, store
            async handleGiftWrapDM(event) {
                try {
                    const NT = window.NostrTools;

                    // Process only gift wraps addressed to me
                    if (this.pubkey) {
                        const wrapRecipients = [];
                        for (const t of event.tags || []) {
                            if (Array.isArray(t) && t[0] === 'p' && typeof t[1] === 'string') {
                                wrapRecipients.push(t[1]);
                            }
                        }
                        if (wrapRecipients.length > 0 && !wrapRecipients.includes(this.pubkey)) {
                            return; // not for me
                        }
                    }

                    // Unwrap local privkey path
                    const unwrapWithLocal = () => {
                        const ckWrap = NT.nip44.getConversationKey(this.privkey, event.pubkey);
                        const sealJson = NT.nip44.decrypt(event.content, ckWrap);
                        const seal = JSON.parse(sealJson);

                        const ckSeal = NT.nip44.getConversationKey(this.privkey, seal.pubkey);
                        const rumorJson = NT.nip44.decrypt(seal.content, ckSeal);
                        const rumor = JSON.parse(rumorJson);

                        return { seal, rumor };
                    };

                    // Unwrap extension-only path
                    const unwrapWithExtension = async () => {
                        const sealJson = await window.nostr.nip44.decrypt(event.pubkey, event.content);
                        const seal = JSON.parse(sealJson);

                        const rumorJson = await window.nostr.nip44.decrypt(seal.pubkey, seal.content);
                        const rumor = JSON.parse(rumorJson);

                        return { seal, rumor };
                    };

                    let seal, rumor;
                    if (this.privkey) {
                        ({ seal, rumor } = unwrapWithLocal());
                    } else if (window.nostr?.nip44?.decrypt) {
                        ({ seal, rumor } = await unwrapWithExtension());
                    } else {
                        return; // no way to decrypt
                    }

                    // Validate rumor and identity
                    if (!rumor || (rumor.kind !== 14 && rumor.kind !== 15)) return;
                    if (typeof rumor.content !== 'string') return;
                    if (!seal?.pubkey || !rumor.pubkey || rumor.pubkey !== seal.pubkey) return; // drop impersonations

                    const senderPubkey = rumor.pubkey;
                    const isOwn = !!this.pubkey && senderPubkey === this.pubkey;

                    // Determine the peer for the conversation
                    const rumorPTags = (rumor.tags || []).filter(t => Array.isArray(t) && t[0] === 'p' && typeof t[1] === 'string').map(t => t[1]);
                    let peerPubkey = null;
                    if (isOwn) {
                        peerPubkey = rumorPTags.find(pk => pk !== this.pubkey) || rumorPTags[0] || null;
                    } else {
                        peerPubkey = senderPubkey;
                    }
                    if (!peerPubkey) return; // can't place the message without a peer

                    const conversationKey = this.getPMConversationKey(peerPubkey);
                    if (!this.pmMessages.has(conversationKey)) this.pmMessages.set(conversationKey, []);

                    // Deduplicate within the correct conversation
                    const list = this.pmMessages.get(conversationKey);
                    if (list.some(m => m.id === event.id)) return;

                    const tsSec = rumor.created_at || Math.floor(Date.now() / 1000);
                    const msg = {
                        id: event.id,                                  // keep outer id for reactions/zaps
                        author: isOwn ? this.nym : this.getNymFromPubkey(senderPubkey),
                        pubkey: senderPubkey,
                        content: rumor.content,
                        timestamp: new Date(tsSec * 1000),
                        isOwn,
                        isPM: true,
                        conversationKey,
                        conversationPubkey: peerPubkey,
                        eventKind: 1059,
                        isHistorical: (Date.now() / 1000 - tsSec) > 10
                    };

                    list.push(msg);
                    list.sort((a, b) => a.timestamp - b.timestamp);
                    this.pmMessages.set(conversationKey, list);

                    this.addPMConversation(this.getNymFromPubkey(peerPubkey), peerPubkey, tsSec * 1000);
                    this.movePMToTop(peerPubkey);

                    if (this.inPMMode && this.currentPM === peerPubkey) {
                        this.displayMessage(msg);
                    } else if (!msg.isHistorical && !isOwn) {
                        // Only notify for messages from others
                        this.updateUnreadCount(conversationKey);
                        this.showNotification(`PM from ${msg.author}`, rumor.content, {
                            type: 'pm',
                            nym: msg.author,
                            pubkey: peerPubkey,   // open the correct thread
                            id: conversationKey
                        });
                    }
                } catch (_) {
                    // ignore undecipherable wraps
                }
            }

            getPMConversationKey(otherPubkey) {
                // Create a unique key for this PM conversation between two users
                const keys = [this.pubkey, otherPubkey].sort();
                return `pm-${keys.join('-')}`;
            }

            async sendPM(content, recipientPubkey) {
                try {
                    if (!this.connected) throw new Error('Not connected to relay');

                    const wrapped = await this.sendNIP17PM(content, recipientPubkey);
                    return !!wrapped;
                } catch (error) {
                    console.error('Failed to send PM:', error);
                    this.displaySystemMessage('Failed to send PM: ' + error.message);
                    return false;
                }
            }

            movePMToTop(pubkey) {
                const pmList = document.getElementById('pmList');
                const pmItem = pmList.querySelector(`[data-pubkey="${pubkey}"]`);

                if (pmItem) {
                    // Update the timestamp
                    const now = Date.now();
                    pmItem.dataset.lastMessageTime = now;

                    // Update in memory
                    const conversation = this.pmConversations.get(pubkey);
                    if (conversation) {
                        conversation.lastMessageTime = now;
                    }

                    // Remove and re-insert in correct order
                    pmItem.remove();
                    this.insertPMInOrder(pmItem, pmList);
                }
            }

            reorderPMs() {
                const pmList = document.getElementById('pmList');
                const items = Array.from(pmList.querySelectorAll('.pm-item'));

                // Sort by timestamp (most recent first)
                items.sort((a, b) => {
                    const timeA = parseInt(a.dataset.lastMessageTime || '0');
                    const timeB = parseInt(b.dataset.lastMessageTime || '0');
                    return timeB - timeA;
                });

                // Clear and re-append in order
                pmList.innerHTML = '';
                items.forEach(item => pmList.appendChild(item));

                // Re-add/update view more button
                this.updateViewMoreButton('pmList');
            }

            requestUserProfile(pubkey) {
                try {
                    // Use the batched profile fetching system
                    this.fetchProfileFromRelay(pubkey);
                } catch (_) { }
            }

            updatePMNicknameFromProfile(pubkey, profileName) {
                if (!profileName) return;
                const clean = this.parseNymFromDisplay(profileName).substring(0, 20);

                // Update memory
                if (this.pmConversations.has(pubkey)) {
                    this.pmConversations.get(pubkey).nym = clean;
                }

                // Update sidebar DOM item if present
                const item = document.querySelector(`.pm-item[data-pubkey="${pubkey}"]`);
                if (item) {
                    const suffix = this.getPubkeySuffix(pubkey);
                    const verifiedBadge = this.isVerifiedDeveloper(pubkey)
                        ? `<span class="verified-badge" title="${this.verifiedDeveloper.title}">✓</span>`
                        : '';
                    const pmNameEl = item.querySelector('.pm-name');
                    if (pmNameEl) {
                        pmNameEl.innerHTML = `@${this.escapeHtml(clean)}<span class="nym-suffix">#${suffix}</span> ${verifiedBadge}`;
                    }
                }
            }

            addPMConversation(nym, pubkey, timestamp = Date.now()) {
                // Prefer known profile name if available
                let baseNym = this.users.has(pubkey)
                    ? this.parseNymFromDisplay(this.users.get(pubkey).nym)
                    : this.parseNymFromDisplay(nym);

                if (!this.pmConversations.has(pubkey)) {
                    this.pmConversations.set(pubkey, {
                        nym: baseNym,
                        lastMessageTime: timestamp
                    });

                    const pmList = document.getElementById('pmList');
                    const item = document.createElement('div');
                    item.className = 'pm-item list-item';
                    item.dataset.pubkey = pubkey;
                    item.dataset.lastMessageTime = timestamp;

                    const suffix = this.getPubkeySuffix(pubkey);
                    const verifiedBadge = this.isVerifiedDeveloper(pubkey)
                        ? `<span class="verified-badge" title="${this.verifiedDeveloper.title}">✓</span>`
                        : '';

                    item.innerHTML = `
            <span class="pm-name">@${this.escapeHtml(baseNym)}<span class="nym-suffix">#${suffix}</span> ${verifiedBadge}</span>
            <div class="channel-badges">
                <span class="pm-badge">PM</span>
                <span class="delete-pm" onclick="event.stopPropagation(); nym.deletePM('${pubkey}')">✕</span>
                <span class="unread-badge" style="display:none">0</span>
            </div>
        `;
                    item.onclick = () => this.openPM(baseNym, pubkey);

                    this.insertPMInOrder(item, pmList);
                    this.updateViewMoreButton('pmList');

                    // Proactively request their profile
                    if (!this.users.has(pubkey) || /^anon$/i.test(baseNym)) {
                        this.requestUserProfile(pubkey);
                    }
                }
            }

            insertPMInOrder(newItem, pmList) {
                const newTime = parseInt(newItem.dataset.lastMessageTime);
                const existingItems = Array.from(pmList.querySelectorAll('.pm-item'));
                const viewMoreBtn = pmList.querySelector('.view-more-btn');

                // Find the correct position to insert (most recent first)
                let insertBefore = null;
                for (const item of existingItems) {
                    const itemTime = parseInt(item.dataset.lastMessageTime || '0');
                    if (newTime > itemTime) {
                        insertBefore = item;
                        break;
                    }
                }

                // If we found a position, insert there
                if (insertBefore) {
                    pmList.insertBefore(newItem, insertBefore);
                } else if (viewMoreBtn) {
                    // If no position found but there's a view more button, insert before it
                    pmList.insertBefore(newItem, viewMoreBtn);
                } else {
                    // Otherwise append to the end
                    pmList.appendChild(newItem);
                }
            }

            deletePM(pubkey) {
                if (confirm('Delete this PM conversation?')) {
                    // Remove from conversations
                    this.pmConversations.delete(pubkey);

                    // Remove messages
                    const conversationKey = this.getPMConversationKey(pubkey);
                    this.pmMessages.delete(conversationKey);

                    // Remove from UI
                    const item = document.querySelector(`[data-pubkey="${pubkey}"]`);
                    if (item) item.remove();

                    // If currently viewing this PM, switch to bar
                    if (this.inPMMode && this.currentPM === pubkey) {
                        this.switchChannel('bar', '');
                    }

                    this.displaySystemMessage('PM conversation deleted');
                }
            }

            openPM(nym, pubkey) {
                this.inPMMode = true;
                this.currentPM = pubkey;
                this.currentChannel = null;
                this.currentGeohash = null;

                // Format the nym with pubkey suffix for display
                const known = this.users.get(pubkey);
                const baseNym = known ? this.parseNymFromDisplay(known.nym) : this.parseNymFromDisplay(nym);
                const suffix = this.getPubkeySuffix(pubkey);
                const displayNym = `${this.escapeHtml(baseNym)}<span class="nym-suffix">#${suffix}</span>`;
                document.getElementById('currentChannel').innerHTML = `@${displayNym} <span style="font-size: 12px; color: var(--text-dim);">(PM)</span>`;

                // Update UI with formatted nym
                document.getElementById('currentChannel').innerHTML = `@${displayNym} <span style="font-size: 12px; color: var(--text-dim);">(PM)</span>`;
                document.getElementById('channelMeta').textContent = 'Private message';

                // Hide share button in PM mode
                const shareBtn = document.getElementById('shareChannelBtn');
                if (shareBtn) {
                    shareBtn.style.display = 'none';
                }

                // Update active states
                document.querySelectorAll('.channel-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelectorAll('.pm-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.pubkey === pubkey);
                });

                // Clear unread count
                const conversationKey = this.getPMConversationKey(pubkey);
                this.clearUnreadCount(conversationKey);

                // Load PM messages
                this.loadPMMessages(conversationKey);

                // Close mobile sidebar on mobile
                if (window.innerWidth <= 768) {
                    this.closeSidebar();
                }
            }

            loadPMMessages(conversationKey) {
                const container = document.getElementById('messagesContainer');
                container.innerHTML = '';

                let pmMessages = this.pmMessages.get(conversationKey) || [];

                // Limit PM messages to prevent memory issues
                const maxPMMessages = 500;
                const originalCount = pmMessages.length;

                // If we have too many messages, prune the stored array
                if (pmMessages.length > maxPMMessages) {
                    // Keep only the most recent messages
                    pmMessages = pmMessages.slice(-maxPMMessages);
                    // Update the stored messages
                    this.pmMessages.set(conversationKey, pmMessages);
                    console.log(`Pruned PM conversation from ${originalCount} to ${maxPMMessages} messages`);
                }

                // Filter messages that are part of this specific conversation
                const filteredMessages = pmMessages.filter(msg => {
                    // Check if message is from blocked user
                    if (this.blockedUsers.has(msg.author) || msg.blocked) {
                        return false;
                    }

                    // Check if message content is spam
                    if (this.isSpamMessage(msg.content)) {
                        return false;
                    }

                    // Ensure the message is between the current user and the PM recipient only
                    return msg.conversationKey === conversationKey &&
                        (msg.pubkey === this.pubkey || msg.pubkey === this.currentPM);
                });

                // Sort messages by timestamp
                filteredMessages.sort((a, b) => a.timestamp - b.timestamp);

                // If we pruned messages, show a notice
                if (originalCount > maxPMMessages) {
                    const loadMoreDiv = document.createElement('div');
                    loadMoreDiv.className = 'system-message';
                    loadMoreDiv.style.cssText = 'cursor: pointer; color: var(--text-dim); font-size: 12px;';
                    loadMoreDiv.textContent = `Showing most recent ${maxPMMessages} messages (${originalCount - maxPMMessages} older messages hidden for performance)`;
                    container.appendChild(loadMoreDiv);
                }

                // Display only these filtered messages
                filteredMessages.forEach(msg => {
                    // Double-check this is a PM before displaying
                    if (msg.isPM && msg.conversationKey === conversationKey) {
                        // Use displayMessage to properly handle reactions
                        this.displayMessage(msg);
                    }
                });

                if (filteredMessages.length === 0) {
                    this.displaySystemMessage('Start of private message');
                }

                // Scroll to bottom
                if (this.settings.autoscroll) {
                    // Use setTimeout to ensure DOM has updated
                    setTimeout(() => {
                        container.scrollTop = container.scrollHeight;
                    }, 0);
                }
            }

            openUserPM(nym, pubkey) {
                // Don't open PM with yourself
                if (pubkey === this.pubkey) {
                    this.displaySystemMessage("You can't send private messages to yourself");
                    return;
                }

                // Extract base nym if it has a suffix
                const baseNym = nym.split('#')[0] || nym;

                // Add to PM conversations if not exists
                this.addPMConversation(baseNym, pubkey);
                // Open the PM
                this.openPM(baseNym, pubkey);
            }

            isMentioned(content) {
                const lowerContent = content.toLowerCase();
                const lowerNym = this.nym.toLowerCase();
                return lowerContent.includes(`@${lowerNym}`) || lowerContent.includes(lowerNym);
            }

            async generateKeypair() {
                try {
                    // Generate ephemeral keys using nostr-tools bundle functions
                    const sk = window.NostrTools.generateSecretKey();
                    const pk = window.NostrTools.getPublicKey(sk);

                    this.privkey = sk;
                    this.pubkey = pk;

                    console.log('Generated ephemeral keypair');

                    return { privkey: sk, pubkey: pk };
                } catch (error) {
                    console.error('Failed to generate keypair:', error);
                    throw error;
                }
            }

            async useExtension() {
                if (!window.nostr) {
                    throw new Error('No Nostr extension detected. Please install Alby or nos2x.');
                }

                try {
                    const pk = await window.nostr.getPublicKey();
                    this.pubkey = pk;
                    this.usingExtension = true;

                    // Fetch profile from kind 0 event
                    await this.fetchProfileFromRelay(pk);

                    return { pubkey: pk };
                } catch (error) {
                    throw new Error('Failed to connect to Nostr extension');
                }
            }

            async fetchProfileFromRelay(pubkey) {
                return new Promise((resolve) => {
                    // Add to queue
                    this.profileFetchQueue.push({ pubkey, resolve });

                    // Clear existing timer
                    if (this.profileFetchTimer) {
                        clearTimeout(this.profileFetchTimer);
                    }

                    // Set timer to process batch
                    this.profileFetchTimer = setTimeout(() => {
                        this.processBatchedProfileFetch();
                    }, this.profileFetchBatchDelay);
                });
            }

            processBatchedProfileFetch() {
                if (this.profileFetchQueue.length === 0) return;

                // Get unique pubkeys and their resolvers
                const batch = this.profileFetchQueue;
                this.profileFetchQueue = [];
                this.profileFetchTimer = null;

                const pubkeyMap = new Map();
                batch.forEach(({ pubkey, resolve }) => {
                    if (!pubkeyMap.has(pubkey)) {
                        pubkeyMap.set(pubkey, []);
                    }
                    pubkeyMap.get(pubkey).push(resolve);
                });

                const pubkeys = Array.from(pubkeyMap.keys());
                const resolvers = pubkeyMap;

                console.log(`Batching profile fetch for ${pubkeys.length} pubkeys`);

                const timeout = setTimeout(() => {
                    console.log('Profile batch fetch timeout');
                    resolvers.forEach(resolveList => {
                        resolveList.forEach(resolve => resolve());
                    });
                }, 3000);

                const subId = "profile-batch-" + Math.random().toString(36).substring(7);
                const originalHandler = this.handleRelayMessage.bind(this);
                const foundPubkeys = new Set();

                this.handleRelayMessage = (msg) => {
                    if (!Array.isArray(msg)) return;

                    const [type, ...data] = msg;

                    if (type === 'EVENT' && data[0] === subId) {
                        const event = data[1];
                        if (event && event.kind === 0 && resolvers.has(event.pubkey)) {
                            foundPubkeys.add(event.pubkey);

                            try {
                                const profile = JSON.parse(event.content);

                                // Store complete original profile for non-ephemeral connections
                                if (event.pubkey === this.pubkey && this.connectionMode !== 'ephemeral') {
                                    this.originalProfile = profile;
                                    console.log('Stored complete profile with fields:', Object.keys(profile));
                                }

                                // Get name
                                if (event.pubkey === this.pubkey && (profile.name || profile.username || profile.display_name)) {
                                    const profileName = profile.name || profile.username || profile.display_name;
                                    this.nym = profileName.substring(0, 20);
                                    document.getElementById('currentNym').textContent = this.nym;
                                    console.log('Profile loaded:', this.nym);
                                }

                                // Get lightning address
                                if (event.pubkey === this.pubkey && (profile.lud16 || profile.lud06)) {
                                    const lnAddress = profile.lud16 || profile.lud06;
                                    this.lightningAddress = lnAddress;
                                    localStorage.setItem(`nym_lightning_address_${this.pubkey}`, lnAddress);
                                    this.updateLightningAddressDisplay();
                                }
                            } catch (e) {
                                console.error('Failed to parse profile:', e);
                            }

                            // Resolve all promises for this pubkey
                            const resolveList = resolvers.get(event.pubkey);
                            resolveList.forEach(resolve => resolve());
                            resolvers.delete(event.pubkey);
                        }
                    } else if (type === 'EOSE' && data[0] === subId) {
                        clearTimeout(timeout);
                        this.handleRelayMessage = originalHandler;

                        // Resolve any remaining unfound profiles
                        resolvers.forEach(resolveList => {
                            resolveList.forEach(resolve => resolve());
                        });
                    }

                    originalHandler(msg);
                };

                const subscription = [
                    "REQ",
                    subId,
                    {
                        kinds: [0],
                        authors: pubkeys, // Array of all pubkeys
                        limit: pubkeys.length
                    }
                ];

                if (this.connected) {
                    this.sendToRelay(subscription);
                    setTimeout(() => {
                        this.sendToRelay(["CLOSE", subId]);
                    }, 3500);
                } else {
                    this.messageQueue.push(JSON.stringify(subscription));
                }
            }

            async publishMessage(content, channel = this.currentChannel, geohash = this.currentGeohash) {
                try {
                    if (!this.connected) {
                        throw new Error('Not connected to relay');
                    }

                    const tags = [
                        ['n', this.nym]
                    ];

                    let kind;

                    // Use appropriate kind and tags based on channel type
                    if (geohash) {
                        kind = 20000; // Geohash channels use kind 20000
                        tags.push(['g', geohash]);
                    } else {
                        kind = 23333; // Standard channels use kind 23333
                        tags.push(['d', channel]);
                    }

                    const event = {
                        kind: kind,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: tags,
                        content: content,
                        pubkey: this.pubkey
                    };

                    // Sign event
                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        // Use extension
                        signedEvent = await window.nostr.signEvent(event);
                    } else if (this.privkey) {
                        // Use finalizeEvent with ephemeral key
                        signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                    } else {
                        throw new Error('No signing method available');
                    }

                    // Send to relay
                    this.sendToRelay(["EVENT", signedEvent]);

                    return true;
                } catch (error) {
                    console.error('Failed to publish message:', error);
                    this.displaySystemMessage('Failed to send message: ' + error.message);
                    return false;
                }
            }

            async publishCommunityMessage(content, communityId) {
                try {
                    console.log('Publishing community message:', { communityId, content });

                    if (!this.connected) {
                        throw new Error('Not connected to relay');
                    }

                    const community = this.communityChannels.get(communityId);
                    if (!community) {
                        console.error('Community not found:', communityId);
                        console.log('Available communities:', Array.from(this.communityChannels.keys()));
                        throw new Error('Community not found');
                    }

                    console.log('Community found:', community);

                    // CHECK IF USER IS BANNED
                    if (this.communityBans.has(communityId) &&
                        this.communityBans.get(communityId).has(this.pubkey)) {
                        throw new Error('You are banned from this community');
                    }

                    // CHECK IF USER IS TEMPORARILY KICKED
                    if (this.communityTemporaryKicks && this.communityTemporaryKicks.has(communityId)) {
                        const kicks = this.communityTemporaryKicks.get(communityId);
                        if (kicks.has(this.pubkey)) {
                            const kickExpiry = kicks.get(this.pubkey);
                            if (Date.now() < kickExpiry) {
                                const minutesLeft = Math.ceil((kickExpiry - Date.now()) / 60000);
                                throw new Error(`You are temporarily kicked from this community. Try again in ${minutesLeft} minute${minutesLeft !== 1 ? 's' : ''}.`);
                            } else {
                                // Kick expired, remove it
                                kicks.delete(this.pubkey);
                            }
                        }
                    }

                    // Check if message contains blocked keywords
                    if (this.hasCommunityBlockedKeyword(content, communityId)) {
                        throw new Error('Message contains blocked keywords');
                    }

                    const event = {
                        kind: 4550,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['a', `34550:${community.admin}:${communityId}`],
                            ['n', this.nym]
                        ],
                        content: content,
                        pubkey: this.pubkey
                    };

                    console.log('Community event to publish:', event);

                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        signedEvent = await window.nostr.signEvent(event);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                    } else {
                        throw new Error('No signing method available');
                    }

                    console.log('Signed community event:', signedEvent);

                    this.sendToRelay(["EVENT", signedEvent]);

                    console.log('Community message sent successfully');

                    return true;
                } catch (error) {
                    console.error('Failed to publish community message:', error);
                    this.displaySystemMessage('Failed to send message: ' + error.message);
                    return false;
                }
            }

            async createChannel(channelName) {
                try {
                    if (!this.connected) {
                        throw new Error('Not connected to relay');
                    }

                    const event = {
                        kind: 23333, // Channel creation/joining
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['d', channelName],
                            ['relay', this.relayUrl], // Add relay tag
                            ['about', `Channel #${channelName} created via NYM`]
                        ],
                        content: JSON.stringify({
                            name: channelName,
                            about: `Channel #${channelName}`,
                            picture: ''
                        }),
                        pubkey: this.pubkey
                    };

                    // Sign event
                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        signedEvent = await window.nostr.signEvent(event);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                    } else {
                        throw new Error('No signing method available');
                    }

                    // Send to relay
                    this.sendToRelay(["EVENT", signedEvent]);

                    return true;
                } catch (error) {
                    console.error('Failed to create channel:', error);
                    return false;
                }
            }

            async createCommunityChannel(name, description, isPrivate = false, imageUrl = '') {
                try {
                    if (!this.connected) {
                        throw new Error('Not connected to relay');
                    }

                    if (this.connectionMode === 'ephemeral') {
                        throw new Error('Community channels require a persistent identity (extension or nsec login)');
                    }

                    // Validate name - no spaces allowed
                    if (name.includes(' ')) {
                        throw new Error('Community names cannot contain spaces. Use hyphens instead (e.g., "my-community")');
                    }

                    // Generate unique community identifier with pubkey suffix
                    const suffix = this.getPubkeySuffix(this.pubkey);
                    const sanitizedName = this.sanitizeCommunityName(name);
                    const communityId = `${sanitizedName}-${suffix}`;

                    const event = {
                        kind: 34550, // NIP-72 community definition
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['d', communityId], // Unique identifier
                            ['name', name],
                            ['description', description || `Community ${name}`],
                            ['image', imageUrl || ''], // Community image
                            ['p', this.pubkey, '', 'admin']
                        ],
                        content: description || '',
                        pubkey: this.pubkey
                    };

                    // Add privacy tag
                    if (isPrivate) {
                        event.tags.push(['private']);
                    } else {
                        event.tags.push(['public']);
                    }

                    // Sign event
                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        signedEvent = await window.nostr.signEvent(event);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                    } else {
                        throw new Error('No signing method available');
                    }

                    // Send to relay
                    this.sendToRelay(["EVENT", signedEvent]);

                    // Store locally
                    this.communityChannels.set(communityId, {
                        name: name,
                        description: description,
                        imageUrl: imageUrl,
                        isPrivate: isPrivate,
                        admin: this.pubkey,
                        createdAt: Date.now()
                    });

                    // Initialize collections
                    if (!this.communityMembers.has(communityId)) {
                        this.communityMembers.set(communityId, new Set([this.pubkey]));
                    }
                    if (!this.communityModerators.has(communityId)) {
                        this.communityModerators.set(communityId, new Set());
                    }

                    this.ownedCommunities.add(communityId);

                    // Add to UI as a COMMUNITY channel (not standard)
                    this.addCommunityChannel(name, communityId, isPrivate);

                    this.displaySystemMessage(`Created ${isPrivate ? 'private' : 'public'} community: ${name}`);
                    this.displaySystemMessage(`Community ID: ${communityId}`);
                    this.displaySystemMessage(`Use /communityinfo to see community details`);
                    this.displaySystemMessage(`Use /addmod to add moderators`);

                    return communityId;
                } catch (error) {
                    console.error('Failed to create community channel:', error);
                    this.displaySystemMessage('Failed to create community: ' + error.message);
                    return null;
                }
            }

            sanitizeCommunityName(name) {
                // Replace spaces with hyphens for URL/ID compatibility
                return name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
            }

            addCommunityChannel(name, communityId, isPrivate) {
                const list = document.getElementById('channelList');

                // Filter out communities with spaces in the name
                if (name.includes(' ')) {
                    console.log(`Community "${name}" has spaces in name, not adding to sidebar`);
                    // Still store it in communityChannels map but don't display
                    if (!this.communityChannels.has(communityId)) {
                        this.communityChannels.set(communityId, {
                            name: name,
                            isPrivate: isPrivate
                        });
                    }
                    return;
                }

                // Check if already exists
                if (document.querySelector(`[data-community="${communityId}"]`)) {
                    console.log('Community channel already exists:', communityId);
                    return;
                }

                const item = document.createElement('div');
                item.className = 'channel-item list-item';
                item.dataset.community = communityId;
                item.dataset.channel = name; // Just the display name
                item.dataset.geohash = ''; // Not a geohash
                item.dataset.isCommunity = 'true'; // Mark as community

                const badge = isPrivate ?
                    '<span class="std-badge" style="border-color: var(--purple); color: var(--purple);">PRI</span>' :
                    '<span class="std-badge" style="border-color: var(--primary); color: var(--primary);">PUB</span>';

                const isPinned = this.pinnedChannels.has(communityId);
                if (isPinned) {
                    item.classList.add('pinned');
                }

                const pinButton = `
        <span class="pin-btn ${isPinned ? 'pinned' : ''}" data-community="${communityId}">
            <svg viewBox="0 0 24 24">
                <path d="M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z"/>
            </svg>
        </span>
    `;

                item.innerHTML = `
        <span class="channel-name">#${this.escapeHtml(name)}</span>
        <div class="channel-badges">
            ${pinButton}
            ${badge}
            <span class="unread-badge" style="display:none">0</span>
        </div>
    `;

                // Add click handler for the entire item
                item.addEventListener('click', (e) => {
                    // Don't trigger if clicking on pin button
                    if (!e.target.closest('.pin-btn')) {
                        this.switchToCommunity(communityId);
                    }
                });

                // Add pin handler
                const pinBtn = item.querySelector('.pin-btn');
                if (pinBtn) {
                    pinBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        this.togglePin(communityId, '', true); // community flag
                    });
                }

                // Get all existing items (excluding view more button)
                const existingItems = Array.from(list.querySelectorAll('.channel-item'));
                const viewMoreBtn = list.querySelector('.view-more-btn');

                // Find a random position among existing items
                // Exclude #bar (first item) and NYM community if it exists
                let insertableItems = existingItems.filter(existingItem => {
                    const isBar = existingItem.dataset.channel === 'bar' && !existingItem.dataset.geohash && !existingItem.dataset.isCommunity;
                    const isNYM = existingItem.dataset.community &&
                        this.communityChannels.get(existingItem.dataset.community)?.name?.toLowerCase() === 'nym' &&
                        this.communityChannels.get(existingItem.dataset.community)?.admin === this.verifiedDeveloper.pubkey;
                    return !isBar && !isNYM;
                });

                if (insertableItems.length > 0) {
                    // Insert at random position
                    const randomIndex = Math.floor(Math.random() * (insertableItems.length + 1));
                    if (randomIndex === insertableItems.length) {
                        // Insert at the end (before view more button)
                        if (viewMoreBtn) {
                            list.insertBefore(item, viewMoreBtn);
                        } else {
                            list.appendChild(item);
                        }
                    } else {
                        // Insert before the randomly selected item
                        list.insertBefore(item, insertableItems[randomIndex]);
                    }
                } else {
                    // No insertable items, just add before view more or at end
                    if (viewMoreBtn) {
                        list.insertBefore(item, viewMoreBtn);
                    } else {
                        list.appendChild(item);
                    }
                }

                // Store in channels map with community flag
                this.channels.set(communityId, {
                    channel: name,
                    community: communityId,
                    isCommunity: true,
                    isPrivate: isPrivate
                });

                this.userJoinedChannels.add(communityId);
                this.updateChannelPins();
                this.updateViewMoreButton('channelList');
            }

            async uploadImage(file) {
                const progress = document.getElementById('uploadProgress');
                const progressFill = document.getElementById('progressFill');

                try {
                    progress.classList.add('active');
                    progressFill.style.width = '20%';

                    // Compute SHA-256 hash
                    const arrayBuffer = await file.arrayBuffer();
                    const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                    const hashArray = Array.from(new Uint8Array(hashBuffer));
                    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                    progressFill.style.width = '40%';

                    // Create and sign Nostr event
                    const uploadEvent = {
                        kind: 24242,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['t', 'upload'],
                            ['x', hashHex]
                        ],
                        content: 'Uploading blob with SHA-256 hash',
                        pubkey: this.pubkey
                    };

                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        signedEvent = await window.nostr.signEvent(uploadEvent);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(uploadEvent, this.privkey);
                    } else {
                        throw new Error('No signing method available');
                    }

                    progressFill.style.width = '60%';

                    // Prepare form data
                    const formData = new FormData();
                    formData.append('file', file);

                    // Convert signed event to base64
                    const eventString = JSON.stringify(signedEvent);
                    const eventBase64 = btoa(eventString);

                    progressFill.style.width = '80%';

                    // Upload to nostrmedia.com
                    const response = await fetch('https://nostrmedia.com/upload', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Nostr ${eventBase64}`
                        },
                        body: formData
                    });

                    progressFill.style.width = '100%';

                    if (response.ok) {
                        const data = await response.json();
                        if (data.url) {
                            const imageUrl = data.url;
                            const input = document.getElementById('messageInput');
                            input.value += imageUrl + ' ';
                            input.focus();
                        } else {
                            throw new Error('No URL in response');
                        }
                    } else {
                        throw new Error(`Upload failed: ${response.status}`);
                    }
                } catch (error) {
                    console.error('Image upload failed:', error);
                    this.displaySystemMessage('Failed to upload image: ' + error.message);
                } finally {
                    setTimeout(() => {
                        progress.classList.remove('active');
                    }, 500);
                }
            }

            isDuplicateMessage(message) {
                const displayChannel = message.geohash ? `#${message.geohash}` : message.channel;
                const channelMessages = this.messages.get(displayChannel) || [];
                return channelMessages.some(m =>
                    m.id === message.id ||
                    (m.content === message.content &&
                        m.author === message.author &&
                        Math.abs(m.timestamp - message.timestamp) < 2000)
                );
            }

            getNymFromPubkey(pubkey) {
                const user = this.users.get(pubkey);
                if (user) {
                    return this.formatNymWithPubkey(user.nym, pubkey);
                }

                // Check PM conversations for saved nyms
                if (this.pmConversations.has(pubkey)) {
                    const nym = this.pmConversations.get(pubkey).nym;
                    return this.formatNymWithPubkey(nym, pubkey);
                }

                // Return shortened pubkey as fallback with anon prefix
                return `anon#${pubkey.slice(-4)}`;
            }

            displayMessage(message) {
                // Check if message is from a blocked user (from stored state OR by pubkey)
                if (message.blocked || this.blockedUsers.has(message.pubkey) || this.isNymBlocked(message.author)) {
                    return; // Don't display blocked messages
                }

                // For community messages, also check if user is banned from that community
                if (message.isCommunity && message.communityId) {
                    if (this.communityBans.has(message.communityId) &&
                        this.communityBans.get(message.communityId).has(message.pubkey)) {
                        console.log(`Filtering banned user message in community ${message.communityId}`);
                        return;
                    }
                }

                // Handle PM messages differently
                if (message.isPM) {
                    // Check if we should display this PM now
                    if (!this.inPMMode || this.currentPM !== message.conversationPubkey) {
                        // Not viewing this PM conversation right now, but message is already stored
                        return;
                    }

                    // Don't display if it's not part of the current conversation
                    const currentConversationKey = this.getPMConversationKey(this.currentPM);
                    if (message.conversationKey !== currentConversationKey) {
                        return;
                    }
                } else if (message.isCommunity) {
                    // Handle COMMUNITY messages
                    if (this.inPMMode) {
                        // In PM mode, don't display community messages
                        return;
                    }

                    // Only display if we're viewing this community
                    if (this.currentCommunity !== message.communityId) {
                        return;
                    }

                    const storageKey = message.communityId;

                    // Store message if not already exists
                    if (!this.messages.has(storageKey)) {
                        this.messages.set(storageKey, []);
                    }

                    // Check if message already exists
                    const exists = this.messages.get(storageKey).some(m => m.id === message.id);
                    if (!exists) {
                        // Add message and sort by timestamp with millisecond precision
                        this.messages.get(storageKey).push(message);
                        this.messages.get(storageKey).sort((a, b) => {
                            return a.timestamp.getTime() - b.timestamp.getTime();
                        });
                    }
                } else {
                    // Regular channel message
                    if (this.inPMMode) {
                        // In PM mode, don't display channel messages
                        return;
                    }

                    // Don't display if we're in a community
                    if (this.currentCommunity) {
                        return;
                    }

                    const storageKey = message.geohash ? `#${message.geohash}` : message.channel;

                    // Store message if not already exists
                    if (!this.messages.has(storageKey)) {
                        this.messages.set(storageKey, []);
                    }

                    // Check if message already exists
                    const exists = this.messages.get(storageKey).some(m => m.id === message.id);
                    if (!exists) {
                        // Add message and sort by timestamp with millisecond precision
                        this.messages.get(storageKey).push(message);
                        this.messages.get(storageKey).sort((a, b) => {
                            return a.timestamp.getTime() - b.timestamp.getTime();
                        });

                        // Prune messages if exceeding limit (500 max)
                        const messages = this.messages.get(storageKey);
                        if (messages && messages.length > 500) {
                            // Keep only the most recent 500 messages
                            const prunedMessages = messages.slice(-500);
                            this.messages.set(storageKey, prunedMessages);

                            // Also prune DOM if currently viewing this channel
                            const currentKey = this.currentGeohash ? `#${this.currentGeohash}` : this.currentChannel;
                            if (currentKey === storageKey) {
                                const container = document.getElementById('messagesContainer');
                                const messageDOMs = container.querySelectorAll('.message[data-message-id]');

                                // Remove old DOM elements beyond 500
                                const toRemove = messageDOMs.length - 500;
                                if (toRemove > 0) {
                                    for (let i = 0; i < toRemove; i++) {
                                        messageDOMs[i].remove();
                                    }
                                }
                            }
                        }
                    }

                    // Check if this is for current channel
                    const currentKey = this.currentGeohash ? `#${this.currentGeohash}` : this.currentChannel;
                    if (storageKey !== currentKey) {
                        // Message is for different channel, update unread count but don't display
                        if (!message.isOwn && !exists && !message.isHistorical) {
                            this.updateUnreadCount(storageKey);
                        }
                        return;
                    }
                }

                // Don't re-add if already displayed in DOM
                if (document.querySelector(`[data-message-id="${message.id}"]`)) {
                    return;
                }

                // Now actually display the message in the DOM
                const container = document.getElementById('messagesContainer');
                const shouldScroll = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;

                const time = this.settings.showTimestamps ?
                    message.timestamp.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: this.settings.timeFormat === '12hr'
                    }) : '';

                const messageEl = document.createElement('div');

                // Check if nym is blocked or message contains blocked keywords or is spam
                if (this.blockedUsers.has(message.author) ||
                    this.hasBlockedKeyword(message.content) ||
                    this.isSpamMessage(message.content)) {
                    // Don't create the element at all for blocked/spam content
                    return;
                }

                // Check if nym is flooding in THIS CHANNEL (but not for PMs and not for historical messages)
                const channelToCheck = message.communityId || message.geohash || message.channel;
                if (!message.isPM && !message.isHistorical && this.isFlooding(message.pubkey, channelToCheck)) {
                    messageEl.className = 'message flooded';
                }

                // Check if message mentions the user
                const isMentioned = !message.isOwn && this.isMentioned(message.content);

                // Check for action messages
                if (message.content.startsWith('/me ')) {
                    messageEl.className = 'action-message';
                    messageEl.innerHTML = `* ${this.escapeHtml(message.author)} ${this.formatMessage(message.content.substring(4))}`;
                } else {
                    const classes = ['message'];

                    if (message.isOwn) {
                        classes.push('self');
                    } else if (message.isPM) {
                        classes.push('pm');
                    } else if (isMentioned) {
                        classes.push('mentioned');
                    }

                    messageEl.className = classes.join(' ');
                    messageEl.dataset.messageId = message.id;
                    messageEl.dataset.author = message.author;
                    messageEl.dataset.pubkey = message.pubkey;
                    messageEl.dataset.timestamp = message.timestamp.getTime();

                    const authorClass = message.isOwn ? 'self' : '';
                    const userColorClass = this.getUserColorClass(message.pubkey);

                    // Add verified badge if this is the developer
                    const verifiedBadge = this.isVerifiedDeveloper(message.pubkey) ?
                        `<span class="verified-badge" title="${this.verifiedDeveloper.title}">✓</span>` : '';

                    // Check if this is a valid event ID (not temporary PM ID)
                    const isValidEventId = message.id && /^[0-9a-f]{64}$/i.test(message.id);
                    const isMobile = window.innerWidth <= 768;

                    // Show reaction button for all messages with valid IDs (including PMs and community posts)
                    const reactionButton = isValidEventId && !isMobile ? `
            <button class="reaction-btn" onclick="nym.showReactionPicker('${message.id}', this)">
                <svg viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                    <circle cx="9" cy="9" r="1"></circle>
                    <circle cx="15" cy="9" r="1"></circle>
                </svg>
            </button>
        ` : '';

                    // Build the initial HTML with quote detection
                    const formattedContent = this.formatMessageWithQuotes(message.content);

                    const baseNym = this.parseNymFromDisplay(message.author);
                    const displayAuthor = `${this.escapeHtml(baseNym)}<span class="nym-suffix">#${this.getPubkeySuffix(message.pubkey)}</span>`;
                    const escapedAuthorBase = this.escapeHtml(message.author).split('#')[0] || this.escapeHtml(message.author);
                    const authorWithHtml = `${escapedAuthorBase}<span class="nym-suffix">#${this.getPubkeySuffix(message.pubkey)}</span>`;

                    // Prepare full timestamp for tooltip
                    const fullTimestamp = message.timestamp.toLocaleString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: this.settings.timeFormat === '12hr'
                    });

                    messageEl.innerHTML = `
    ${time ? `<span class="message-time ${this.settings.timeFormat === '12hr' ? 'time-12hr' : ''}" data-full-time="${fullTimestamp}" title="${fullTimestamp}">${time}</span>` : ''}
    <span class="message-author ${authorClass} ${userColorClass}">
        ${displayAuthor}${verifiedBadge}:
    </span>
    <span class="message-content ${userColorClass}">${formattedContent}</span>
    ${reactionButton}
`;

                    const authorSpan = messageEl.querySelector('.message-author');
                    if (authorSpan) {
                        authorSpan.style.cursor = 'pointer';
                        authorSpan.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.showContextMenu(e, displayAuthor, message.pubkey, message.content, message.id);
                            return false;
                        });
                    }
                }

                // Apply blur to images if settings enabled and not own message
                if (!message.isOwn && this.blurOthersImages) {
                    const images = messageEl.querySelectorAll('img');
                    images.forEach(img => {
                        img.classList.add('blurred');
                    });
                }

                // Only sort by timestamp if we're scrolled to the bottom or if this is historical
                const isScrolledToBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 100;
                const shouldSort = isScrolledToBottom || message.isHistorical;

                if (shouldSort) {
                    // Find the correct position to insert the message based on timestamp
                    const existingMessages = Array.from(container.querySelectorAll('.message[data-timestamp]'));
                    const messageTimestamp = message.timestamp.getTime();

                    let insertBefore = null;
                    for (const existing of existingMessages) {
                        const existingTimestamp = parseInt(existing.dataset.timestamp);
                        if (messageTimestamp < existingTimestamp) {
                            insertBefore = existing;
                            break;
                        }
                    }

                    if (insertBefore) {
                        container.insertBefore(messageEl, insertBefore);
                    } else {
                        const typingIndicator = container.querySelector('.typing-indicator');
                        if (typingIndicator) {
                            container.insertBefore(messageEl, typingIndicator);
                        } else {
                            container.appendChild(messageEl);
                        }
                    }
                } else {
                    // Just append at the end for new messages when not at bottom
                    const typingIndicator = container.querySelector('.typing-indicator');
                    if (typingIndicator) {
                        container.insertBefore(messageEl, typingIndicator);
                    } else {
                        container.appendChild(messageEl);
                    }
                }

                // Add existing reactions if any (for both channel messages, PMs, and community posts)
                if (message.id && this.reactions.has(message.id)) {
                    this.updateMessageReactions(message.id);
                }

                // Add zaps display - check if this message has any zaps
                if (message.id && this.zaps.has(message.id)) {
                    this.updateMessageZaps(message.id);
                }

                // Track scroll position before adding images
                const scrollBeforeImages = container.scrollTop;
                const heightBeforeImages = container.scrollHeight;
                const isAtBottom = shouldScroll;

                // Wait for any images in the message to load
                const images = messageEl.querySelectorAll('img');
                if (images.length > 0) {
                    let loadedImages = 0;
                    const totalImages = images.length;

                    const handleImageLoad = () => {
                        loadedImages++;
                        if (loadedImages === totalImages) {
                            // All images loaded
                            if (this.settings.autoscroll && isAtBottom) {
                                // Scroll to bottom if we were at bottom before
                                container.scrollTop = container.scrollHeight;
                            } else if (!isAtBottom) {
                                // Maintain scroll position for older messages
                                const heightAfterImages = container.scrollHeight;
                                const heightDiff = heightAfterImages - heightBeforeImages;
                                container.scrollTop = scrollBeforeImages + heightDiff;
                            }
                        }
                    };

                    images.forEach(img => {
                        if (img.complete) {
                            // Image already loaded
                            handleImageLoad();
                        } else {
                            // Wait for image to load
                            img.addEventListener('load', handleImageLoad, { once: true });
                            img.addEventListener('error', handleImageLoad, { once: true });
                        }
                    });
                } else {
                    // No images, apply autoscroll immediately
                    if (this.settings.autoscroll) {
                        if (isAtBottom || message.isHistorical) {
                            setTimeout(() => {
                                container.scrollTop = container.scrollHeight;
                            }, 0);
                        }
                    }
                }
            }

            pruneChannelMessages(channelKey, maxMessages = 500) {
                const messages = this.messages.get(channelKey);
                if (!messages || messages.length <= maxMessages) return;

                // Keep only the most recent messages
                const prunedMessages = messages.slice(-maxMessages);
                this.messages.set(channelKey, prunedMessages);

                // If currently viewing this channel, refresh the display
                const currentKey = this.currentGeohash ? `#${this.currentGeohash}` : this.currentChannel;
                if (currentKey === channelKey) {
                    this.loadChannelMessages(channelKey);
                }
            }

            formatMessageWithQuotes(content) {
                // Check if message starts with a quote (> @username: text)
                const quoteMatch = content.match(/^>\s*@(\w+):\s*(.+?)(?:\n|$)/);

                if (quoteMatch) {
                    const quotedUser = quoteMatch[1];
                    const quotedText = quoteMatch[2];
                    const remainingContent = content.substring(quoteMatch[0].length).trim();

                    // Check if the quoted text might be ASCII art
                    const quotedLines = quotedText.split('\n');
                    const isAsciiArt = quotedLines.some(line => {
                        const specialCharCount = (line.match(/[^\w\s]/g) || []).length;
                        return specialCharCount > 5 && line.length > 10;
                    });

                    if (isAsciiArt) {
                        // Preserve ASCII art in quotes
                        let html = `<div class="message-quote">@${this.escapeHtml(quotedUser)}: <pre style="margin: 5px 0; font-family: var(--font-mono);">${this.escapeHtml(quotedText)}</pre></div>`;
                        if (remainingContent) {
                            html += this.formatMessage(remainingContent);
                        }
                        return html;
                    } else {
                        let html = `<div class="message-quote">@${this.escapeHtml(quotedUser)}: ${this.escapeHtml(quotedText)}</div>`;
                        if (remainingContent) {
                            html += this.formatMessage(remainingContent);
                        }
                        return html;
                    }
                }

                return this.formatMessage(content);
            }

            closeReactionPickerHandler(e) {
                if (this.activeReactionPicker && !this.activeReactionPicker.contains(e.target)) {
                    this.closeReactionPicker();
                }
            }

            closeReactionPicker() {
                if (this.activeReactionPicker) {
                    this.activeReactionPicker.remove();
                    this.activeReactionPicker = null;
                    this.activeReactionPickerButton = null;
                }
            }

            currentDisplayChannel() {
                // Return consistent key format for message storage
                return this.currentGeohash ? `#${this.currentGeohash}` : this.currentChannel;
            }

            formatMessage(content) {
                let formatted = content;

                // First, escape HTML entities
                formatted = formatted.replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;');

                // Code blocks with proper line break handling
                formatted = formatted.replace(/```([\s\S]*?)```/g, (match, code) => {
                    const formattedCode = code.trim().replace(/\n/g, '<br/>');
                    return `<pre><code>${formattedCode}</code></pre>`;
                });

                // Bold **text** or __text__
                formatted = formatted.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                formatted = formatted.replace(/__(.+?)__/g, '<strong>$1</strong>');

                // Italic *text* or _text_
                formatted = formatted.replace(/(?<![:/])(\*|_)([^*_\s][^*_]*)\1/g, '<em>$2</em>');

                // Strikethrough ~~text~~
                formatted = formatted.replace(/~~(.+?)~~/g, '<del>$1</del>');

                // Blockquotes > text
                formatted = formatted.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');

                // Headers
                formatted = formatted.replace(/^### (.+)$/gm, '<h3>$1</h3>');
                formatted = formatted.replace(/^## (.+)$/gm, '<h2>$1</h2>');
                formatted = formatted.replace(/^# (.+)$/gm, '<h1>$1</h1>');

                // Convert image URLs to images
                formatted = formatted.replace(
                    /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp)(\?[^\s]*)?)/gi,
                    (match, url) => {
                        return `<img src="${url}" alt="Image" onclick="nym.expandImage('${url}')" />`;
                    }
                );

                // Convert NYM app channel links BEFORE general URLs (IMPORTANT!)
                formatted = formatted.replace(
                    /https?:\/\/app\.nym\.bar\/#([egc]):([^\s<>"]+)/gi,
                    (match, prefix, channelId) => {
                        return `<span class="channel-link" onclick="event.preventDefault(); event.stopPropagation(); nym.handleChannelLink('${prefix}:${this.escapeHtml(channelId)}', event); return false;">${match}</span>`;
                    }
                );

                // Convert other URLs to links (but not placeholders)
                formatted = formatted.replace(
                    /(https?:\/\/[^\s]+)(?![^<]*>)(?!__)/g,
                    '<a href="$1" target="_blank" rel="noopener">$1</a>'
                );

                // Process mentions and channels together in one pass
                formatted = formatted.replace(
                    /(@[^@#\n]*?#[0-9a-f]{4}\b)|(@[^@\s][^@\s]*)|(?:^|\s)(#[\w\s-]+?)(?=\s|$|[.,!?])/gi,
                    (match, mentionWithSuffix, simpleMention, channel, offset) => {
                        if (mentionWithSuffix) {
                            // This is a mention with a pubkey suffix
                            return `<span style="color: var(--secondary)">${mentionWithSuffix}</span>`;
                        } else if (simpleMention) {
                            // This is a simple mention without spaces or suffix
                            return `<span style="color: var(--secondary)">${simpleMention}</span>`;
                        } else if (channel) {
                            // This is a channel reference - check all types
                            const channelName = channel.substring(1).trim(); // Remove the # and trim

                            // Sanitize channel name (remove spaces and invalid chars)
                            const sanitized = channelName.toLowerCase().replace(/[^a-z0-9-]/g, '');

                            if (!sanitized) {
                                // Invalid channel name, just return as text
                                return match;
                            }

                            // Check for community channels that user has access to
                            let communityMatches = [];
                            this.communityChannels.forEach((community, id) => {
                                if (community.name.toLowerCase() === sanitized) {
                                    // Filter out communities with spaces
                                    if (community.name.includes(' ')) {
                                        return;
                                    }

                                    // Filter out private communities user doesn't have access to
                                    if (community.isPrivate) {
                                        const hasAccess = this.ownedCommunities.has(id) ||
                                            (this.communityModerators.has(id) &&
                                                this.communityModerators.get(id).has(this.pubkey)) ||
                                            (this.communityMembers.has(id) &&
                                                this.communityMembers.get(id).has(this.pubkey)) ||
                                            (this.communityInvites.has(id) &&
                                                this.communityInvites.get(id).has(this.pubkey));

                                        if (hasAccess) {
                                            communityMatches.push({ id, community });
                                        }
                                    } else {
                                        // Public community - always include
                                        communityMatches.push({ id, community });
                                    }
                                }
                            });

                            // Convert channel links to clickable elements
                            formatted = formatted.replace(
                                /https?:\/\/app\.nym\.bar\/#([egc]):([^\s<>"]+)/gi,
                                (match, prefix, channelId) => {
                                    const typeMap = {
                                        'e': 'ephemeral',
                                        'g': 'geohash',
                                        'c': 'community'
                                    };
                                    const type = typeMap[prefix] || 'ephemeral';
                                    return `<span class="channel-link" onclick="nym.handleChannelLink('${prefix}:${this.escapeHtml(channelId)}', event)">${match}</span>`;
                                }
                            );

                            // Check if it's a valid geohash
                            const isGeohash = this.isValidGeohash(sanitized);

                            // Check if it exists as a standard channel
                            const isStandard = true; // Standard channels can always be created

                            // Count how many types exist
                            const typesCount = communityMatches.length + (isGeohash ? 1 : 0) + (isStandard ? 1 : 0);

                            const space = match.startsWith(' ') ? ' ' : '';

                            // If multiple types exist, show disambiguation
                            if (typesCount > 1 || communityMatches.length > 1) {
                                return `${space}<span class="channel-link" onclick="nym.showChannelOptions('${this.escapeHtml(sanitized)}')">#${sanitized} [MULTIPLE]</span>`;
                            }

                            // If only community exists
                            if (communityMatches.length === 1 && !isGeohash) {
                                const communityId = communityMatches[0].id;
                                const community = communityMatches[0].community;
                                const badge = community.isPrivate ? ' [PRI]' : ' [PUB]';
                                return `${space}<span class="channel-link" onclick="nym.quickJoinCommunity('${communityId}')">#${sanitized}${badge}</span>`;
                            }

                            // If only geohash exists (and no community with same name)
                            if (isGeohash && communityMatches.length === 0) {
                                const badge = ' [GEO]';
                                return `${space}<span class="channel-link" onclick="nym.joinChannelOption('geohash', '${this.escapeHtml(sanitized)}')">#${sanitized}${badge}</span>`;
                            }

                            // Default to standard channel
                            const badge = ' [EPH]';
                            return `${space}<span class="channel-link" onclick="nym.joinChannelOption('standard', '${this.escapeHtml(sanitized)}')">#${sanitized}${badge}</span>`;
                        }
                        return match;
                    }
                );

                return formatted;
            }

            expandImage(src) {
                document.getElementById('modalImage').src = src;
                document.getElementById('imageModal').classList.add('active');
            }

            quickJoinChannel(channel) {
                // Sanitize channel name
                const sanitized = channel.toLowerCase().replace(/[^a-z0-9-]/g, '');

                if (!sanitized) {
                    this.displaySystemMessage('Invalid channel name. Use only letters, numbers, and hyphens.');
                    return;
                }

                const type = this.getChannelType(sanitized);

                if (type === 'geo') {
                    this.addChannel(sanitized, sanitized);
                    this.switchChannel(sanitized, sanitized);
                    this.userJoinedChannels.add(sanitized);
                } else {
                    this.addChannel(sanitized, '');
                    this.switchChannel(sanitized, '');
                    // Also create the channel with kind 23333
                    this.createChannel(sanitized);
                    this.userJoinedChannels.add(sanitized);
                }

                // Save after quick join
                this.saveUserChannels();
            }

            quickJoinCommunity(communityId) {
                const community = this.communityChannels.get(communityId);
                if (!community) {
                    this.displaySystemMessage('Community not found');
                    return;
                }

                // Check if community has spaces (shouldn't happen, but safety check)
                if (community.name.includes(' ')) {
                    this.displaySystemMessage('This community has an invalid name (contains spaces)');
                    return;
                }

                if (this.connectionMode === 'ephemeral') {
                    this.displaySystemMessage('Community channels require a persistent identity (extension or nsec)');
                    return;
                }

                // Check if it's a private community and user has access
                if (community.isPrivate) {
                    const hasAccess = this.ownedCommunities.has(communityId) ||
                        (this.communityModerators.has(communityId) &&
                            this.communityModerators.get(communityId).has(this.pubkey)) ||
                        (this.communityMembers.has(communityId) &&
                            this.communityMembers.get(communityId).has(this.pubkey)) ||
                        (this.communityInvites.has(communityId) &&
                            this.communityInvites.get(communityId).has(this.pubkey));

                    if (!hasAccess) {
                        this.displaySystemMessage('This is a private community. You need an invitation.');
                        return;
                    }
                }

                // Add to UI if not present
                if (!document.querySelector(`[data-community="${communityId}"]`)) {
                    this.addCommunityChannel(community.name, communityId, community.isPrivate);
                }

                this.switchToCommunity(communityId);
                this.userJoinedChannels.add(communityId);
                this.saveUserChannels();
            }

            showChannelOptions(channelName) {
                // Sanitize the channel name
                const sanitized = channelName.toLowerCase().replace(/[^a-z0-9-]/g, '');

                if (!sanitized) {
                    this.displaySystemMessage('Invalid channel name');
                    return;
                }

                // Close any existing channel options modal
                const existingModal = document.getElementById('channelOptionsModal');
                if (existingModal) {
                    existingModal.remove();
                }

                // Create modal
                const modal = document.createElement('div');
                modal.id = 'channelOptionsModal';
                modal.className = 'modal active';

                let optionsHtml = '';
                let optionCount = 0;

                // Check for community channels that user has access to
                const communityMatches = [];
                this.communityChannels.forEach((community, id) => {
                    if (community.name.toLowerCase() === sanitized) {
                        // Filter out communities with spaces
                        if (community.name.includes(' ')) {
                            return;
                        }

                        // Filter out private communities user doesn't have access to
                        if (community.isPrivate) {
                            const hasAccess = this.ownedCommunities.has(id) ||
                                (this.communityModerators.has(id) &&
                                    this.communityModerators.get(id).has(this.pubkey)) ||
                                (this.communityMembers.has(id) &&
                                    this.communityMembers.get(id).has(this.pubkey)) ||
                                (this.communityInvites.has(id) &&
                                    this.communityInvites.get(id).has(this.pubkey));

                            if (hasAccess) {
                                communityMatches.push({ id, community });
                            }
                        } else {
                            // Public community - always include
                            communityMatches.push({ id, community });
                        }
                    }
                });

                // Add community options
                communityMatches.forEach(({ id, community }) => {
                    optionCount++;
                    const privacyBadge = community.isPrivate ? 'PRI' : 'PUB';
                    const privacyColor = community.isPrivate ? 'var(--purple)' : 'var(--primary)';

                    // Different access info based on user's role
                    let accessInfo = '';
                    if (community.isPrivate) {
                        if (this.ownedCommunities.has(id)) {
                            accessInfo = ' (Private - You are Admin)';
                        } else if (this.communityModerators.has(id) && this.communityModerators.get(id).has(this.pubkey)) {
                            accessInfo = ' (Private - You are Moderator)';
                        } else if (this.communityMembers.has(id) && this.communityMembers.get(id).has(this.pubkey)) {
                            accessInfo = ' (Private - You are Member)';
                        } else if (this.communityInvites.has(id) && this.communityInvites.get(id).has(this.pubkey)) {
                            accessInfo = ' (Private - You are Invited)';
                        } else {
                            accessInfo = ' (Private)';
                        }
                    } else {
                        accessInfo = ' (Public)';
                    }

                    optionsHtml += `
            <button class="icon-btn channel-option-btn" onclick="nym.joinChannelOption('community', '${id}'); nym.closeChannelOptions();" style="width: 100%; margin-bottom: 10px; text-align: left; display: flex; justify-content: space-between; align-items: center;">
                <span>#${this.escapeHtml(community.name)}${accessInfo}</span>
                <span style="color: ${privacyColor}; border: 1px solid ${privacyColor}; padding: 2px 8px; border-radius: 3px; font-size: 10px;">${privacyBadge}</span>
            </button>
        `;
                });

                // Check if it's a valid geohash
                const isGeohash = this.isValidGeohash(sanitized);
                if (isGeohash) {
                    optionCount++;
                    const location = this.getGeohashLocation(sanitized) || 'Unknown location';
                    optionsHtml += `
            <button class="icon-btn channel-option-btn" onclick="nym.joinChannelOption('geohash', '${this.escapeHtml(sanitized)}'); nym.closeChannelOptions();" style="width: 100%; margin-bottom: 10px; text-align: left; display: flex; justify-content: space-between; align-items: center;">
                <span>#${this.escapeHtml(sanitized)} (${location})</span>
                <span style="color: var(--warning); border: 1px solid var(--warning); padding: 2px 8px; border-radius: 3px; font-size: 10px;">GEO</span>
            </button>
        `;
                }

                // Always show standard channel option
                optionCount++;
                optionsHtml += `
        <button class="icon-btn channel-option-btn" onclick="nym.joinChannelOption('standard', '${this.escapeHtml(sanitized)}'); nym.closeChannelOptions();" style="width: 100%; margin-bottom: 10px; text-align: left; display: flex; justify-content: space-between; align-items: center;">
            <span>#${this.escapeHtml(sanitized)} (Ephemeral)</span>
            <span style="color: var(--blue); border: 1px solid var(--blue); padding: 2px 8px; border-radius: 3px; font-size: 10px;">EPH</span>
        </button>
    `;

                // Only show modal if there are multiple options
                if (optionCount > 1) {
                    modal.innerHTML = `
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header">Choose Channel Type for #${this.escapeHtml(sanitized)}</div>
                <div class="modal-body">
                    <div style="margin-bottom: 15px; color: var(--text-dim); font-size: 12px;">
                        Multiple channels with this name exist. Select which one to join:
                    </div>
                    ${optionsHtml}
                </div>
                <div class="modal-actions">
                    <button class="icon-btn" onclick="nym.closeChannelOptions()">Cancel</button>
                </div>
            </div>
        `;

                    document.body.appendChild(modal);

                    // Close on click outside
                    setTimeout(() => {
                        modal.addEventListener('click', (e) => {
                            if (e.target === modal) {
                                this.closeChannelOptions();
                            }
                        });
                    }, 100);
                } else {
                    // Only one option, join directly
                    if (communityMatches.length > 0) {
                        this.joinChannelOption('community', communityMatches[0].id);
                    } else if (isGeohash) {
                        this.joinChannelOption('geohash', sanitized);
                    } else {
                        this.joinChannelOption('standard', sanitized);
                    }
                }
            }

            closeChannelOptions() {
                const modal = document.getElementById('channelOptionsModal');
                if (modal) {
                    modal.remove();
                }
            }

            async joinChannelOption(type, identifier) {
                if (type === 'community') {
                    // Community IDs are already validated, use as-is
                    this.quickJoinCommunity(identifier);
                } else if (type === 'geohash') {
                    // Sanitize geohash identifier
                    const sanitized = identifier.toLowerCase().replace(/[^0-9bcdefghjkmnpqrstuvwxyz]/g, '');

                    if (!sanitized || !this.isValidGeohash(sanitized)) {
                        this.displaySystemMessage('Invalid geohash');
                        return;
                    }

                    // Join as geohash channel
                    this.addChannel(sanitized, sanitized);
                    this.switchChannel(sanitized, sanitized);
                    this.userJoinedChannels.add(sanitized);
                    this.saveUserChannels();
                } else if (type === 'standard') {
                    // Sanitize standard channel name
                    const sanitized = identifier.toLowerCase().replace(/[^a-z0-9-]/g, '');

                    if (!sanitized) {
                        this.displaySystemMessage('Invalid channel name');
                        return;
                    }

                    // Join as standard ephemeral channel
                    this.addChannel(sanitized, '');
                    this.switchChannel(sanitized, '');
                    await this.createChannel(sanitized);
                    this.userJoinedChannels.add(sanitized);
                    this.saveUserChannels();
                }
            }

            insertMention(nym) {
                const input = document.getElementById('messageInput');
                const currentValue = input.value;
                const mention = `@${nym} `;

                // Insert at cursor position or append
                const start = input.selectionStart;
                const end = input.selectionEnd;

                if (start !== undefined) {
                    input.value = currentValue.substring(0, start) + mention + currentValue.substring(end);
                    input.selectionStart = input.selectionEnd = start + mention.length;
                } else {
                    input.value = currentValue + mention;
                }

                input.focus();
            }

            displaySystemMessage(content, type = 'system') {
                const container = document.getElementById('messagesContainer');
                const messageEl = document.createElement('div');
                messageEl.className = type === 'action' ? 'action-message' : 'system-message';
                messageEl.innerHTML = content;
                container.appendChild(messageEl);

                if (this.settings.autoscroll) {
                    container.scrollTop = container.scrollHeight;
                }
            }

            updateUserPresence(nym, pubkey, channel, geohash) {
                const channelKey = geohash || channel;

                // Update or create user with deduplication by pubkey
                if (!this.users.has(pubkey)) {
                    this.users.set(pubkey, {
                        nym: nym,
                        pubkey: pubkey,
                        lastSeen: Date.now(),
                        status: this.awayMessages.has(pubkey) ? 'away' : 'online',
                        channels: new Set([channelKey])
                    });
                } else {
                    const user = this.users.get(pubkey);
                    user.lastSeen = Date.now();
                    user.nym = nym; // Update nym in case it changed
                    user.channels.add(channelKey);
                    user.status = this.awayMessages.has(pubkey) ? 'away' : 'online';
                }

                // Track users per channel
                if (!this.channelUsers.has(channelKey)) {
                    this.channelUsers.set(channelKey, new Set());
                }
                this.channelUsers.get(channelKey).add(pubkey);

                this.updateUserList();
            }

            updateUserList() {
                const userListContent = document.getElementById('userListContent');
                const currentChannelKey = this.currentCommunity || this.currentGeohash || this.currentChannel;

                // Get deduplicated active users (one entry per pubkey)
                const uniqueUsers = new Map();
                this.users.forEach((user, pubkey) => {
                    if (Date.now() - user.lastSeen < 300000 && !this.blockedUsers.has(user.nym)) {
                        if (!uniqueUsers.has(pubkey)) {
                            uniqueUsers.set(pubkey, user);
                        }
                    }
                });

                const allUsers = Array.from(uniqueUsers.values())
                    .filter(user => user && user.nym)
                    .sort((a, b) => {
                        const nymA = String(a.nym || '');
                        const nymB = String(b.nym || '');
                        return nymA.localeCompare(nymB);
                    });

                // Filter users based on search term
                let displayUsers = allUsers;
                if (this.userSearchTerm) {
                    const term = this.userSearchTerm.toLowerCase();
                    displayUsers = allUsers.filter(user =>
                        this.parseNymFromDisplay(user.nym).toLowerCase().includes(term)
                    );
                }

                // Get users in current channel for the count
                let channelUserCount = 0;
                this.users.forEach((user, pubkey) => {
                    if (Date.now() - user.lastSeen < 300000 &&
                        !this.blockedUsers.has(user.nym) &&
                        user.channels.has(currentChannelKey)) {
                        channelUserCount++;
                    }
                });

                // Build HTML
                userListContent.innerHTML = displayUsers.map((user) => {
                    const baseNym = this.parseNymFromDisplay(user.nym);
                    const suffix = this.getPubkeySuffix(user.pubkey);
                    const displayNym = `${this.escapeHtml(baseNym)}<span class="nym-suffix">#${suffix}</span>`;
                    const verifiedBadge = this.isVerifiedDeveloper(user.pubkey)
                        ? `<span class="verified-badge" title="${this.verifiedDeveloper.title}" style="margin-left: 3px;">✓</span>`
                        : '';

                    const userColorClass = this.settings.theme === 'bitchat' ? this.getUserColorClass(user.pubkey) : '';

                    return `
            <div class="user-item list-item ${userColorClass}" 
                 onclick="nym.openUserPM('${this.escapeHtml(baseNym)}', '${user.pubkey}')" 
                 oncontextmenu="nym.showContextMenu(event, '${this.escapeHtml(displayNym)}', '${user.pubkey}')"
                 data-nym="${this.escapeHtml(baseNym)}">
                <span class="user-status ${user.status}"></span>
                <span class="${userColorClass}">${displayNym} ${verifiedBadge}</span>
            </div>
        `;
                }).join('');

                this.updateViewMoreButton('userListContent');

                const userListTitle = document.querySelector('#userList .nav-title-text');
                if (userListTitle) {
                    userListTitle.textContent = `Active Nyms (${allUsers.length})`;
                }

                if (!this.inPMMode) {
                    const meta = document.getElementById('channelMeta');
                    if (meta) meta.textContent = `${channelUserCount} active nyms`;
                }
            }

            filterChannels(searchTerm) {
                const items = document.querySelectorAll('.channel-item');
                const term = searchTerm.toLowerCase();
                const list = document.getElementById('channelList');

                items.forEach(item => {
                    const channelName = item.querySelector('.channel-name').textContent.toLowerCase();
                    if (term.length === 0 || channelName.includes(term)) {
                        item.style.display = 'flex';
                        item.classList.remove('search-hidden');
                    } else {
                        item.style.display = 'none';
                        item.classList.add('search-hidden');
                    }
                });

                // Hide view more button during search
                const viewMoreBtn = list.querySelector('.view-more-btn');
                if (viewMoreBtn) {
                    viewMoreBtn.style.display = term ? 'none' : 'block';
                }
            }

            filterPMs(searchTerm) {
                const items = document.querySelectorAll('.pm-item');
                const term = searchTerm.toLowerCase();
                const list = document.getElementById('pmList');

                items.forEach(item => {
                    const pmName = item.querySelector('.pm-name').textContent.toLowerCase();
                    if (term.length === 0 || pmName.includes(term)) {
                        item.style.display = 'flex';
                        item.classList.remove('search-hidden');
                    } else {
                        item.style.display = 'none';
                        item.classList.add('search-hidden');
                    }
                });

                // Hide view more button during search
                const viewMoreBtn = list.querySelector('.view-more-btn');
                if (viewMoreBtn) {
                    viewMoreBtn.style.display = term ? 'none' : 'block';
                }
            }

            filterUsers(searchTerm) {
                this.userSearchTerm = searchTerm;
                this.updateUserList();

                const list = document.getElementById('userListContent');

                // Hide view more button during search
                const viewMoreBtn = list.querySelector('.view-more-btn');
                if (viewMoreBtn) {
                    viewMoreBtn.style.display = searchTerm ? 'none' : 'block';
                }
            }

            togglePin(channel, geohash, isCommunity = false) {
                // Don't allow pinning/unpinning #bar since it's always at top
                if (channel === 'bar' && !geohash && !isCommunity) {
                    this.displaySystemMessage('#bar is always at the top');
                    return;
                }

                // Check if this is the NYM community
                const key = isCommunity ? channel : (geohash || channel);

                if (isCommunity && this.communityChannels.has(key)) {
                    const community = this.communityChannels.get(key);
                    const isNYMCommunity = community.admin === this.verifiedDeveloper.pubkey &&
                        community.name.toLowerCase() === 'nym';

                    if (isNYMCommunity) {
                        this.displaySystemMessage('#NYM community is always pinned');
                        return;
                    }
                }

                // For other channels, toggle pin status
                if (this.pinnedChannels.has(key)) {
                    this.pinnedChannels.delete(key);
                } else {
                    this.pinnedChannels.add(key);
                }

                this.savePinnedChannels();
                this.updateChannelPins();

                if (this.connectionMode !== 'ephemeral') {
                    this.saveSyncedSettings();
                }
            }

            updateChannelPins() {
                document.querySelectorAll('.channel-item').forEach(item => {
                    let key;

                    // Check if this is a community channel
                    if (item.dataset.isCommunity === 'true') {
                        key = item.dataset.community;
                    } else {
                        const channel = item.dataset.channel;
                        const geohash = item.dataset.geohash;
                        key = geohash || channel;
                    }

                    const pinBtn = item.querySelector('.pin-btn');

                    if (this.pinnedChannels.has(key)) {
                        item.classList.add('pinned');
                        if (pinBtn) pinBtn.classList.add('pinned');
                    } else {
                        item.classList.remove('pinned');
                        if (pinBtn) pinBtn.classList.remove('pinned');
                    }
                });
            }

            savePinnedChannels() {
                localStorage.setItem('nym_pinned_channels', JSON.stringify(Array.from(this.pinnedChannels)));
            }

            loadPinnedChannels() {
                const saved = localStorage.getItem('nym_pinned_channels');
                if (saved) {
                    this.pinnedChannels = new Set(JSON.parse(saved));
                    this.updateChannelPins();
                }
            }

            setupEventListeners() {
                const input = document.getElementById('messageInput');

                input.addEventListener('keydown', (e) => {
                    const autocomplete = document.getElementById('autocompleteDropdown');
                    const emojiAutocomplete = document.getElementById('emojiAutocomplete');
                    const commandPalette = document.getElementById('commandPalette');

                    if (autocomplete.classList.contains('active')) {
                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            this.navigateAutocomplete(1);
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            this.navigateAutocomplete(-1);
                        } else if (e.key === 'Enter' || e.key === 'Tab') {
                            e.preventDefault();
                            this.selectAutocomplete();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            this.hideAutocomplete();
                        }
                    } else if (emojiAutocomplete.classList.contains('active')) {
                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            this.navigateEmojiAutocomplete(1);
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            this.navigateEmojiAutocomplete(-1);
                        } else if (e.key === 'Enter' || e.key === 'Tab') {
                            e.preventDefault();
                            this.selectEmojiAutocomplete();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            this.hideEmojiAutocomplete();
                        }
                    } else if (commandPalette.classList.contains('active')) {
                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            this.navigateCommandPalette(1);
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            this.navigateCommandPalette(-1);
                        } else if (e.key === 'Enter' || e.key === 'Tab') {
                            e.preventDefault();
                            this.selectCommand();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            this.hideCommandPalette();
                        }
                    } else {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            this.sendMessage();
                        } else if (e.key === 'ArrowUp' && input.value === '') {
                            e.preventDefault();
                            this.navigateHistory(-1);
                        } else if (e.key === 'ArrowDown' && input.value === '') {
                            e.preventDefault();
                            this.navigateHistory(1);
                        }
                    }
                });

                input.addEventListener('input', (e) => {
                    this.handleInputChange(e.target.value);
                    this.autoResizeTextarea(e.target);
                });

                // Use event delegation for channel clicks
                document.getElementById('channelList').addEventListener('click', (e) => {
                    // Handle channel item clicks
                    const channelItem = e.target.closest('.channel-item');
                    if (channelItem && !e.target.closest('.pin-btn')) {
                        e.preventDefault();
                        e.stopPropagation();

                        // Check if it's a community channel FIRST
                        if (channelItem.dataset.isCommunity === 'true' && channelItem.dataset.community) {
                            // It's a community channel - switch to community
                            const communityId = channelItem.dataset.community;

                            // Don't reload if already in this community
                            if (!nym.inPMMode && nym.currentCommunity === communityId) {
                                return;
                            }

                            // Add debounce to prevent double-clicks
                            if (channelItem.dataset.clicking === 'true') return;
                            channelItem.dataset.clicking = 'true';

                            nym.switchToCommunity(communityId);

                            // Reset click flag after a short delay
                            setTimeout(() => {
                                delete channelItem.dataset.clicking;
                            }, 1000);
                        } else {
                            // Regular channel handling
                            const channel = channelItem.dataset.channel;
                            const geohash = channelItem.dataset.geohash || '';

                            // Don't reload if already in channel
                            if (!nym.inPMMode &&
                                !nym.currentCommunity &&
                                channel === nym.currentChannel &&
                                geohash === nym.currentGeohash) {
                                return;
                            }

                            // Add debounce to prevent double-clicks
                            if (channelItem.dataset.clicking === 'true') return;
                            channelItem.dataset.clicking = 'true';

                            nym.switchChannel(channel, geohash);

                            // Reset click flag after a short delay
                            setTimeout(() => {
                                delete channelItem.dataset.clicking;
                            }, 1000);
                        }
                    }
                });

                // Global click handler for closing dropdowns and modals
                document.addEventListener('click', (e) => {
                    // Close command palette if clicking outside
                    if (!e.target.closest('#commandPalette') && !e.target.closest('#messageInput')) {
                        this.hideCommandPalette();
                    }

                    // Close emoji autocomplete if clicking outside
                    if (!e.target.closest('#emojiAutocomplete') && !e.target.closest('#messageInput')) {
                        this.hideEmojiAutocomplete();
                    }

                    // Close @ mention autocomplete if clicking outside
                    if (!e.target.closest('#autocompleteDropdown') && !e.target.closest('#messageInput')) {
                        this.hideAutocomplete();
                    }

                    // Close enhanced emoji modal if clicking outside
                    if (!e.target.closest('.enhanced-emoji-modal') &&
                        !e.target.closest('.reaction-btn') &&
                        !e.target.closest('.add-reaction-btn') &&
                        !e.target.closest('.icon-btn.input-btn[title="Emoji"]') &&
                        !e.target.closest('#ctxReact')) {
                        this.closeEnhancedEmojiModal();
                    }

                    // Handle command palette item click
                    if (e.target.closest('.command-item')) {
                        this.selectCommand(e.target.closest('.command-item'));
                    }
                });

                // File input
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    if (e.target.files && e.target.files[0]) {
                        this.uploadImage(e.target.files[0]);
                    }
                });

                // Modal controls
                document.getElementById('channelTypeSelect').addEventListener('change', (e) => {
                    const type = e.target.value;
                    document.getElementById('standardChannelGroup').style.display =
                        type === 'standard' ? 'block' : 'none';
                    document.getElementById('geohashGroup').style.display =
                        type === 'geohash' ? 'block' : 'none';
                    document.getElementById('communityChannelGroup').style.display =
                        type === 'community' ? 'block' : 'none';
                });
            }

            setupCommands() {
                this.commands = {
                    '/help': { desc: 'Show available commands', fn: () => this.showHelp() },
                    '/join': { desc: 'Join a channel', fn: (args) => this.cmdJoin(args) },
                    '/j': { desc: 'Shortcut for /join', fn: (args) => this.cmdJoin(args) },
                    '/pm': { desc: 'Send private message', fn: (args) => this.cmdPM(args) },
                    '/nick': { desc: 'Change your nym', fn: (args) => this.cmdNick(args) },
                    '/who': { desc: 'List active nyms', fn: () => this.cmdWho() },
                    '/w': { desc: 'Shortcut for /who', fn: () => this.cmdWho() },
                    '/clear': { desc: 'Clear chat messages', fn: () => this.cmdClear() },
                    '/block': { desc: 'Block a user or #channel', fn: (args) => this.cmdBlock(args) },
                    '/unblock': { desc: 'Unblock a user', fn: (args) => this.cmdUnblock(args) },
                    '/slap': { desc: 'Slap someone with a trout', fn: (args) => this.cmdSlap(args) },
                    '/me': { desc: 'Action message', fn: (args) => this.cmdMe(args) },
                    '/shrug': { desc: 'Send a shrug', fn: () => this.cmdShrug() },
                    '/bold': { desc: 'Send bold text (**text**)', fn: (args) => this.cmdBold(args) },
                    '/b': { desc: 'Shortcut for /bold', fn: (args) => this.cmdBold(args) },
                    '/italic': { desc: 'Send italic text (*text*)', fn: (args) => this.cmdItalic(args) },
                    '/i': { desc: 'Shortcut for /italic', fn: (args) => this.cmdItalic(args) },
                    '/strike': { desc: 'Send strikethrough text (~~text~~)', fn: (args) => this.cmdStrike(args) },
                    '/s': { desc: 'Shortcut for /strike', fn: (args) => this.cmdStrike(args) },
                    '/code': { desc: 'Send code block', fn: (args) => this.cmdCode(args) },
                    '/c': { desc: 'Shortcut for /code', fn: (args) => this.cmdCode(args) },
                    '/quote': { desc: 'Send quoted text', fn: (args) => this.cmdQuote(args) },
                    '/q': { desc: 'Shortcut for /quote', fn: (args) => this.cmdQuote(args) },
                    '/brb': { desc: 'Set away message', fn: (args) => this.cmdBRB(args) },
                    '/back': { desc: 'Clear away message', fn: () => this.cmdBack() },
                    '/zap': { desc: 'Zap a user profile', fn: (args) => this.cmdZap(args) },
                    '/invite': { desc: 'Invite a user to current channel', fn: (args) => this.cmdInvite(args) },
                    '/share': { desc: 'Share current channel URL', fn: () => this.cmdShare() },
                    '/leave': { desc: 'Leave current channel', fn: () => this.cmdLeave() },
                    '/quit': { desc: 'Disconnect from NYM', fn: () => this.cmdQuit() },

                    // Community channel commands
                    '/createcommunity': { desc: 'Create a community channel', fn: (args) => this.cmdCreateCommunity(args) },
                    '/cc': { desc: 'Shortcut for /createcommunity', fn: (args) => this.cmdCreateCommunity(args) },
                    '/addmod': { desc: 'Add moderator to community', fn: (args) => this.cmdAddMod(args) },
                    '/removemod': { desc: 'Remove moderator', fn: (args) => this.cmdRemoveMod(args) },
                    '/kick': { desc: 'Kick user from community', fn: (args) => this.cmdKick(args) },
                    '/ban': { desc: 'Ban user from community', fn: (args) => this.cmdBan(args) },
                    '/unban': { desc: 'Unban user from community', fn: (args) => this.cmdUnban(args) },
                    '/invitetocommunity': { desc: 'Invite user to private community', fn: (args) => this.cmdInviteToCommunity(args) },
                    '/communityinfo': { desc: 'Show community info', fn: () => this.cmdCommunityInfo() },
                    '/ci': { desc: 'Shortcut for /communityinfo', fn: () => this.cmdCommunityInfo() },
                    '/members': { desc: 'List community members', fn: () => this.cmdListMembers() },
                    '/mods': { desc: 'List community moderators', fn: () => this.cmdListMods() },
                    '/communitysettings': { desc: 'Manage community settings', fn: () => this.cmdCommunitySettings() },
                    '/cs': { desc: 'Shortcut for /communitysettings', fn: () => this.cmdCommunitySettings() }
                };
            }

            handleInputChange(value) {
                // Check for emoji autocomplete with :
                const colonIndex = value.lastIndexOf(':');
                if (colonIndex !== -1 && colonIndex === value.length - 1 ||
                    (colonIndex !== -1 && value.substring(colonIndex).match(/^:[a-z]*$/))) {
                    const search = value.substring(colonIndex + 1);
                    this.showEmojiAutocomplete(search);
                } else {
                    this.hideEmojiAutocomplete();
                }

                // Check for @ mentions
                const lastAtIndex = value.lastIndexOf('@');
                if (lastAtIndex !== -1 && lastAtIndex === value.length - 1 ||
                    (lastAtIndex !== -1 && value.substring(lastAtIndex).match(/^@\w*$/))) {
                    const search = value.substring(lastAtIndex + 1);
                    this.showAutocomplete(search);
                } else {
                    this.hideAutocomplete();
                }

                // Check for commands
                if (value.startsWith('/')) {
                    this.showCommandPalette(value);
                } else {
                    this.hideCommandPalette();
                }
            }

            showEmojiAutocomplete(search) {
                const dropdown = document.getElementById('emojiAutocomplete');

                // Build complete emoji list from all categories
                const allEmojiEntries = [];

                // Add emoji shortcodes
                Object.entries(this.emojiMap).forEach(([name, emoji]) => {
                    allEmojiEntries.push({ name, emoji, priority: 1 });
                });

                // Add all categorized emojis with searchable names
                Object.entries(this.allEmojis).forEach(([category, emojis]) => {
                    emojis.forEach(emoji => {
                        // Try to find a name for this emoji in emojiMap
                        const existingEntry = allEmojiEntries.find(e => e.emoji === emoji);
                        if (!existingEntry) {
                            // Generate a searchable name from the emoji itself
                            allEmojiEntries.push({
                                name: emoji,
                                emoji,
                                priority: 2
                            });
                        }
                    });
                });

                // Filter based on search
                let matches = [];
                if (search === '') {
                    // Show recent emojis first, then common ones
                    const recentSet = new Set(this.recentEmojis);
                    matches = [
                        ...this.recentEmojis.map(emoji => ({
                            name: Object.entries(this.emojiMap).find(([n, e]) => e === emoji)?.[0] || emoji,
                            emoji
                        })),
                        ...allEmojiEntries.filter(e => !recentSet.has(e.emoji)).slice(0, 10)
                    ].slice(0, 8);
                } else {
                    matches = allEmojiEntries
                        .filter(entry =>
                            entry.name.toLowerCase().includes(search.toLowerCase()) ||
                            entry.emoji.includes(search)
                        )
                        .sort((a, b) => a.priority - b.priority)
                        .slice(0, 8);
                }

                if (matches.length > 0) {
                    dropdown.innerHTML = matches.map(({ name, emoji }, index) => `
                        <div class="emoji-item ${index === 0 ? 'selected' : ''}" data-name="${name}" data-emoji="${emoji}">
                            <span class="emoji-item-emoji">${emoji}</span>
                            <span class="emoji-item-name">:${name}:</span>
                        </div>
                    `).join('');
                    dropdown.classList.add('active');
                    this.emojiAutocompleteIndex = 0;

                    // Add click handlers for each emoji item
                    dropdown.querySelectorAll('.emoji-item').forEach((item, index) => {
                        item.onclick = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.emojiAutocompleteIndex = index;
                            // Remove selected from all, add to clicked
                            dropdown.querySelectorAll('.emoji-item').forEach(i => i.classList.remove('selected'));
                            item.classList.add('selected');
                            this.selectEmojiAutocomplete();
                        };
                    });
                } else {
                    this.hideEmojiAutocomplete();
                }
            }

            hideEmojiAutocomplete() {
                document.getElementById('emojiAutocomplete').classList.remove('active');
                this.emojiAutocompleteIndex = -1;
            }

            navigateEmojiAutocomplete(direction) {
                const items = document.querySelectorAll('.emoji-item');
                if (items.length === 0) return;

                items[this.emojiAutocompleteIndex]?.classList.remove('selected');

                this.emojiAutocompleteIndex += direction;
                if (this.emojiAutocompleteIndex < 0) this.emojiAutocompleteIndex = items.length - 1;
                if (this.emojiAutocompleteIndex >= items.length) this.emojiAutocompleteIndex = 0;

                items[this.emojiAutocompleteIndex].classList.add('selected');
                items[this.emojiAutocompleteIndex].scrollIntoView({ block: 'nearest' });
            }

            selectEmojiAutocomplete() {
                const selected = document.querySelector('.emoji-item.selected');
                if (selected) {
                    const emoji = selected.dataset.emoji;
                    const input = document.getElementById('messageInput');
                    const value = input.value;
                    const colonIndex = value.lastIndexOf(':');

                    input.value = value.substring(0, colonIndex) + emoji + ' ';
                    input.focus();
                    this.hideEmojiAutocomplete();
                    this.addToRecentEmojis(emoji);
                }
            }

            showAutocomplete(search) {
                const dropdown = document.getElementById('autocompleteDropdown');

                // Get current time for activity check
                const now = Date.now();
                const activeThreshold = 300000; // 5 minutes

                // Collect and categorize users
                const onlineUsers = [];
                const offlineUsers = [];

                this.users.forEach((user, pubkey) => {
                    // Create formatted nym for matching
                    const baseNym = user.nym.split('#')[0] || user.nym;
                    const suffix = this.getPubkeySuffix(pubkey);
                    const searchableNym = `${baseNym}#${suffix}`;

                    if (!this.blockedUsers.has(user.nym) &&
                        searchableNym.toLowerCase().includes(search.toLowerCase())) {

                        // Create HTML version for display
                        const displayNym = `${this.escapeHtml(baseNym)}<span class="nym-suffix">#${suffix}</span>`;

                        const userEntry = {
                            nym: user.nym,
                            pubkey: pubkey,
                            displayNym: displayNym,
                            searchableNym: searchableNym,
                            lastSeen: user.lastSeen
                        };

                        if (now - user.lastSeen < activeThreshold) {
                            onlineUsers.push(userEntry);
                        } else {
                            offlineUsers.push(userEntry);
                        }
                    }
                });

                // Sort each group alphabetically by searchable name
                onlineUsers.sort((a, b) => a.searchableNym.localeCompare(b.searchableNym));
                offlineUsers.sort((a, b) => a.searchableNym.localeCompare(b.searchableNym));

                // Combine with online users first
                const allUsers = [...onlineUsers, ...offlineUsers].slice(0, 8);

                if (allUsers.length > 0) {
                    dropdown.innerHTML = allUsers.map((user, index) => {
                        const isOnline = now - user.lastSeen < activeThreshold;
                        const statusIndicator = isOnline ?
                            '<span style="color: var(--primary); margin-right: 5px;">●</span>' :
                            '<span style="color: var(--text-dim); margin-right: 5px;">○</span>';

                        return `
                <div class="autocomplete-item ${index === 0 ? 'selected' : ''}" 
                     data-nym="${user.nym}"
                     data-pubkey="${user.pubkey}"
                     onclick="nym.selectSpecificAutocomplete('${user.nym}', '${user.pubkey}')">
                    ${statusIndicator}<strong>@${user.displayNym}</strong>
                </div>
            `;
                    }).join('');
                    dropdown.classList.add('active');
                    this.autocompleteIndex = 0;

                    // Add click handlers
                    dropdown.querySelectorAll('.autocomplete-item').forEach((item, index) => {
                        item.onclick = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.autocompleteIndex = index;
                            dropdown.querySelectorAll('.autocomplete-item').forEach(i => i.classList.remove('selected'));
                            item.classList.add('selected');
                            this.selectAutocomplete();
                        };
                    });
                } else {
                    this.hideAutocomplete();
                }
            }

            selectSpecificAutocomplete(nym, pubkey) {
                const input = document.getElementById('messageInput');
                const value = input.value;
                const lastAtIndex = value.lastIndexOf('@');

                // Use just the base nym without suffix in the message
                input.value = value.substring(0, lastAtIndex) + '@' + nym + ' ';
                input.focus();
                this.hideAutocomplete();
            }

            hideAutocomplete() {
                document.getElementById('autocompleteDropdown').classList.remove('active');
                this.autocompleteIndex = -1;
            }

            navigateAutocomplete(direction) {
                const items = document.querySelectorAll('.autocomplete-item');
                if (items.length === 0) return;

                items[this.autocompleteIndex]?.classList.remove('selected');

                this.autocompleteIndex += direction;
                if (this.autocompleteIndex < 0) this.autocompleteIndex = items.length - 1;
                if (this.autocompleteIndex >= items.length) this.autocompleteIndex = 0;

                items[this.autocompleteIndex].classList.add('selected');
                items[this.autocompleteIndex].scrollIntoView({ block: 'nearest' });
            }

            selectAutocomplete() {
                const selected = document.querySelector('.autocomplete-item.selected');
                if (selected) {
                    const nym = selected.dataset.nym;
                    const pubkey = selected.dataset.pubkey;
                    const input = document.getElementById('messageInput');
                    const value = input.value;
                    const lastAtIndex = value.lastIndexOf('@');

                    // Use base nym with suffix
                    const baseNym = nym.split('#')[0] || nym;
                    const suffix = this.getPubkeySuffix(pubkey);
                    input.value = value.substring(0, lastAtIndex) + '@' + baseNym + '#' + suffix + ' ';
                    input.focus();
                    this.hideAutocomplete();
                }
            }

            showCommandPalette(input) {
                const palette = document.getElementById('commandPalette');
                const matchingCommands = Object.entries(this.commands)
                    .filter(([cmd]) => cmd.startsWith(input.toLowerCase()));

                if (matchingCommands.length > 0) {
                    palette.innerHTML = matchingCommands.map(([cmd, info], index) => `
                        <div class="command-item ${index === 0 ? 'selected' : ''}" data-command="${cmd}">
                            <span class="command-name">${cmd}</span>
                            <span class="command-desc">${info.desc}</span>
                        </div>
                    `).join('');
                    palette.classList.add('active');
                    this.commandPaletteIndex = 0;
                } else {
                    this.hideCommandPalette();
                }
            }

            hideCommandPalette() {
                document.getElementById('commandPalette').classList.remove('active');
                this.commandPaletteIndex = -1;
            }

            navigateCommandPalette(direction) {
                const items = document.querySelectorAll('.command-item');
                if (items.length === 0) return;

                items[this.commandPaletteIndex]?.classList.remove('selected');

                this.commandPaletteIndex += direction;
                if (this.commandPaletteIndex < 0) this.commandPaletteIndex = items.length - 1;
                if (this.commandPaletteIndex >= items.length) this.commandPaletteIndex = 0;

                items[this.commandPaletteIndex].classList.add('selected');
                items[this.commandPaletteIndex].scrollIntoView({ block: 'nearest' });
            }

            selectCommand(element = null) {
                const selected = element || document.querySelector('.command-item.selected');
                if (selected) {
                    const cmd = selected.dataset.command;
                    const input = document.getElementById('messageInput');
                    input.value = cmd + ' ';
                    input.focus();
                    this.hideCommandPalette();
                }
            }

            async sendMessage() {
                const input = document.getElementById('messageInput');
                const content = input.value.trim();

                if (!content) return;

                if (!this.connected) {
                    this.displaySystemMessage('Not connected to relay. Please wait...');
                    return;
                }

                // Add to history
                this.commandHistory.push(content);
                this.historyIndex = this.commandHistory.length;

                if (content.startsWith('/')) {
                    this.handleCommand(content);
                } else {
                    if (this.inPMMode && this.currentPM) {
                        // Send PM
                        await this.sendPM(content, this.currentPM);
                    } else if (this.currentCommunity) {
                        // Send to community (kind 4550)
                        console.log('Sending to community:', this.currentCommunity);
                        await this.publishCommunityMessage(content, this.currentCommunity);
                    } else if (this.currentGeohash) {
                        // Send to geohash channel (kind 20000)
                        await this.publishMessage(content, this.currentGeohash, this.currentGeohash);
                    } else {
                        // Send to standard channel (kind 23333)
                        await this.publishMessage(content, this.currentChannel, '');
                    }
                }

                input.value = '';
                this.autoResizeTextarea(input);
                this.hideCommandPalette();
                this.hideAutocomplete();
                this.hideEmojiAutocomplete();
            }

            handleCommand(command) {
                const parts = command.split(' ');
                const cmd = parts[0].toLowerCase();
                const args = parts.slice(1).join(' ');

                const commandInfo = this.commands[cmd];
                if (commandInfo) {
                    commandInfo.fn(args);
                } else {
                    this.displaySystemMessage(`Unknown command: ${cmd}`);
                }
            }

            // Command implementations
            showHelp() {
                const helpText = Object.entries(this.commands)
                    .map(([cmd, info]) => `${cmd} - ${info.desc}  \n`)
                    .join('');

                this.displaySystemMessage(
                    `Available commands:  \n${helpText}\n\nMarkdown supported: **bold**, *italic*, ~~strikethrough~~, \`code\`, > quote\n\nType : to quickly pick an emoji\n\nNyms are shown as name#xxxx where xxxx is the last 4 characters of their pubkey\n\nClick on users for more options`
                );
            }

            async cmdJoin(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /join channel, /join #geohash, or /join communityname');
                    return;
                }

                let channel = args.trim().toLowerCase();

                // Check if it's a geohash (starts with #)
                if (channel.startsWith('#')) {
                    const geohash = channel.substring(1);

                    // Validate geohash
                    if (!this.isValidGeohash(geohash)) {
                        this.displaySystemMessage('Invalid geohash format');
                        return;
                    }

                    this.addChannel(geohash, geohash);
                    this.switchChannel(geohash, geohash);
                    this.userJoinedChannels.add(geohash);
                    this.saveUserChannels();
                    return;
                }

                // Check if this might be a community channel
                let matchedCommunity = null;
                let matchedCommunityId = null;

                // Search through known communities
                this.communityChannels.forEach((community, id) => {
                    if (community.name.toLowerCase() === channel ||
                        id.toLowerCase() === channel ||
                        id.toLowerCase().startsWith(channel + '-')) {
                        matchedCommunity = community;
                        matchedCommunityId = id;
                    }
                });

                if (matchedCommunity) {
                    // This is a community channel
                    if (this.connectionMode === 'ephemeral') {
                        this.displaySystemMessage('═══ ERROR: Cannot Join Community ═══');
                        this.displaySystemMessage('Community channels require a persistent identity.');
                        this.displaySystemMessage('Please reconnect using a Nostr extension or NSEC to join communities.');
                        this.displaySystemMessage('Ephemeral users can only join standard (EPH) and geohash (GEO) channels.');
                        return;
                    }

                    // CHECK IF TEMPORARILY KICKED
                    if (this.communityTemporaryKicks && this.communityTemporaryKicks.has(matchedCommunityId)) {
                        const kicks = this.communityTemporaryKicks.get(matchedCommunityId);
                        if (kicks.has(this.pubkey)) {
                            const kickExpiry = kicks.get(this.pubkey);
                            if (Date.now() < kickExpiry) {
                                const minutesLeft = Math.ceil((kickExpiry - Date.now()) / 60000);
                                this.displaySystemMessage(`You are temporarily kicked from this community. Try again in ${minutesLeft} minute${minutesLeft !== 1 ? 's' : ''}.`);
                                return;
                            } else {
                                // Kick expired, remove it
                                kicks.delete(this.pubkey);
                            }
                        }
                    }

                    // CHECK IF BANNED
                    if (this.communityBans.has(matchedCommunityId) &&
                        this.communityBans.get(matchedCommunityId).has(this.pubkey)) {
                        this.displaySystemMessage(`You are banned from the community "${matchedCommunity.name}".`);
                        return;
                    }

                    // Check if it's a private community and user has access
                    if (matchedCommunity.isPrivate) {
                        const isAdmin = matchedCommunity.admin === this.pubkey;
                        const isMod = this.communityModerators.has(matchedCommunityId) &&
                            this.communityModerators.get(matchedCommunityId).has(this.pubkey);
                        const isMember = this.communityMembers.has(matchedCommunityId) &&
                            this.communityMembers.get(matchedCommunityId).has(this.pubkey);
                        const isInvited = this.communityInvites.has(matchedCommunityId) &&
                            this.communityInvites.get(matchedCommunityId).has(this.pubkey);

                        if (!isAdmin && !isMod && !isMember && !isInvited) {
                            this.displaySystemMessage('This is a private community. You need an invitation to join.');
                            return;
                        }

                        // If invited, add to members
                        if (isInvited) {
                            if (!this.communityMembers.has(matchedCommunityId)) {
                                this.communityMembers.set(matchedCommunityId, new Set());
                            }
                            this.communityMembers.get(matchedCommunityId).add(this.pubkey);

                            // Remove from invites
                            this.communityInvites.get(matchedCommunityId).delete(this.pubkey);
                        }
                    } else {
                        // Public community - add user as member
                        if (!this.communityMembers.has(matchedCommunityId)) {
                            this.communityMembers.set(matchedCommunityId, new Set());
                        }
                        this.communityMembers.get(matchedCommunityId).add(this.pubkey);
                    }

                    // Add to UI if not already present
                    if (!document.querySelector(`[data-community="${matchedCommunityId}"]`)) {
                        this.addCommunityChannel(matchedCommunity.name, matchedCommunityId, matchedCommunity.isPrivate);
                    }

                    // Switch to the community
                    this.switchToCommunity(matchedCommunityId);
                    this.userJoinedChannels.add(matchedCommunityId);
                    this.saveUserChannels();

                    this.displaySystemMessage(`Joined ${matchedCommunity.isPrivate ? 'private' : 'public'} community: ${matchedCommunity.name}`);
                    return;
                }

                // Validate standard channel name - no spaces allowed
                if (channel.includes(' ')) {
                    this.displaySystemMessage('Channel names cannot contain spaces. Use hyphens instead (e.g., "my-channel")');
                    return;
                }

                // Sanitize channel name
                channel = channel.toLowerCase().replace(/[^a-z0-9-]/g, '');

                if (!channel) {
                    this.displaySystemMessage('Invalid channel name. Use only letters, numbers, and hyphens.');
                    return;
                }

                // Standard channel
                this.addChannel(channel, '');
                this.switchChannel(channel, '');

                // Create channel with kind 23333
                await this.createChannel(channel);
                this.userJoinedChannels.add(channel);
                this.saveUserChannels();
            }

            async cmdLeave() {
                if (this.inPMMode) {
                    this.displaySystemMessage('Use /pm to switch channels or close PMs from the sidebar');
                    return;
                }

                if (this.currentChannel === 'bar' && !this.currentGeohash && !this.currentCommunity) {
                    this.displaySystemMessage('Cannot leave the default #bar channel');
                    return;
                }

                if (this.currentCommunity) {
                    const community = this.communityChannels.get(this.currentCommunity);

                    // Check if this is a public community (just discovered, not owned/moderated/member)
                    const isOwned = this.ownedCommunities.has(this.currentCommunity);
                    const isModerated = this.moderatedCommunities.has(this.currentCommunity);
                    const isMember = this.communityMembers.has(this.currentCommunity) &&
                        this.communityMembers.get(this.currentCommunity).has(this.pubkey);

                    if (community && !community.isPrivate && !isOwned && !isModerated && !isMember) {
                        // Public community - just remove from sidebar (will be re-discovered)
                        const element = document.querySelector(`[data-community="${this.currentCommunity}"]`);
                        if (element) {
                            element.remove();
                        }
                        this.channels.delete(this.currentCommunity);
                        this.userJoinedChannels.delete(this.currentCommunity);
                        this.displaySystemMessage(`Left public community: ${community.name}`);
                        this.switchChannel('bar', '');
                        return;
                    }

                    // For owned/moderated/member communities, can't leave
                    if (isOwned) {
                        this.displaySystemMessage('You cannot leave a community you created. Use /communitysettings to delete it.');
                        return;
                    }

                    if (isModerated || isMember) {
                        this.displaySystemMessage('Use community settings or contact admin to leave this community');
                        return;
                    }
                }

                this.removeChannel(this.currentChannel, this.currentGeohash);
            }


            async cmdPM(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /pm nym, /pm nym#xxxx, or /pm [pubkey]');
                    return;
                }

                const targetInput = args.trim();

                // Check if input is a pubkey (64 hex characters)
                if (/^[0-9a-f]{64}$/i.test(targetInput)) {
                    const targetPubkey = targetInput.toLowerCase();

                    if (targetPubkey === this.pubkey) {
                        this.displaySystemMessage("You can't send private messages to yourself");
                        return;
                    }

                    // Get nym from pubkey
                    const targetNym = this.getNymFromPubkey(targetPubkey);
                    this.openUserPM(targetNym, targetPubkey);
                    return;
                }

                // Handle both nym and nym#xxxx formats
                let searchNym = targetInput;
                let searchSuffix = null;

                const hashIndex = targetInput.indexOf('#');
                if (hashIndex !== -1) {
                    searchNym = targetInput.substring(0, hashIndex);
                    searchSuffix = targetInput.substring(hashIndex + 1);
                }

                // Find user by nym, considering suffix if provided
                const matches = [];
                this.users.forEach((user, pubkey) => {
                    const baseNym = user.nym.split('#')[0] || user.nym;
                    if (baseNym === searchNym || baseNym.toLowerCase() === searchNym.toLowerCase()) {
                        if (searchSuffix) {
                            // If suffix provided, only match exact pubkey suffix
                            if (pubkey.endsWith(searchSuffix)) {
                                matches.push({ nym: user.nym, pubkey: pubkey });
                            }
                        } else {
                            // No suffix provided, collect all matches
                            matches.push({ nym: user.nym, pubkey: pubkey });
                        }
                    }
                });

                if (matches.length === 0) {
                    this.displaySystemMessage(`User ${targetInput} not found`);
                    return;
                }

                if (matches.length > 1 && !searchSuffix) {
                    // Multiple users with same nym, show them
                    const matchList = matches.map(m =>
                        `${this.formatNymWithPubkey(m.nym, m.pubkey)}`
                    ).join(', ');
                    this.displaySystemMessage(`Multiple users found with nym "${searchNym}": ${matchList}`);
                    this.displaySystemMessage('Please specify using the #xxxx suffix or full pubkey');
                    return;
                }

                // Single match or exact suffix match
                const targetPubkey = matches[0].pubkey;
                const targetNym = matches[0].nym;

                if (targetPubkey === this.pubkey) {
                    this.displaySystemMessage("You can't send private messages to yourself");
                    return;
                }

                this.openUserPM(targetNym, targetPubkey);
            }

            async cmdNick(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /nick newnym');
                    return;
                }

                const oldNym = this.nym;
                const newNym = args.trim().substring(0, 20);

                if (oldNym === newNym) {
                    this.displaySystemMessage('That is already your current nym');
                    return;
                }

                this.nym = newNym;
                document.getElementById('currentNym').textContent = this.nym;

                // Save profile for persistent connections
                if (this.connectionMode !== 'ephemeral') {
                    await this.saveToNostrProfile();
                }

                const changeMessage = `Your nym's new nick is now ${this.nym}`;
                this.displaySystemMessage(changeMessage);
            }

            async cmdWho() {
                const currentChannelKey = this.currentGeohash || this.currentChannel;
                const channelUserSet = this.channelUsers.get(currentChannelKey) || new Set();

                const users = Array.from(channelUserSet)
                    .map(pubkey => this.users.get(pubkey))
                    .filter(u => u && Date.now() - u.lastSeen < 300000)
                    .filter(u => !this.blockedUsers.has(u.nym))
                    .map(u => {
                        const baseNym = u.nym.split('#')[0] || u.nym;
                        const suffix = this.getPubkeySuffix(u.pubkey);
                        return `${this.escapeHtml(baseNym)}<span class="nym-suffix">#${suffix}</span>`;
                    })
                    .join(', ');

                this.displaySystemMessage(`Online nyms in this channel: ${users || 'none'}`);
            }

            async cmdClear() {
                document.getElementById('messagesContainer').innerHTML = '';
                this.displaySystemMessage('Chat cleared');
            }

            async cmdInvite(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /invite nym, /invite nym#xxxx, or /invite [pubkey]');
                    return;
                }

                if (this.inPMMode) {
                    this.displaySystemMessage('Cannot invite users while in PM mode');
                    return;
                }

                const targetInput = args.trim();
                let targetPubkey = null;
                let matchedNym = null;

                // Check if input is a pubkey (64 hex characters)
                if (/^[0-9a-f]{64}$/i.test(targetInput)) {
                    targetPubkey = targetInput.toLowerCase();

                    if (targetPubkey === this.pubkey) {
                        this.displaySystemMessage("You can't invite yourself");
                        return;
                    }

                    matchedNym = this.getNymFromPubkey(targetPubkey);
                } else {
                    // Check if input has #xxxx suffix
                    const hashIndex = targetInput.indexOf('#');
                    let searchNym = targetInput;
                    let searchSuffix = null;

                    if (hashIndex !== -1) {
                        searchNym = targetInput.substring(0, hashIndex);
                        searchSuffix = targetInput.substring(hashIndex + 1);
                    }

                    // Find user by nym, considering suffix if provided
                    const matches = [];
                    this.users.forEach((user, pubkey) => {
                        const baseNym = user.nym.split('#')[0] || user.nym;
                        if (baseNym === searchNym || baseNym.toLowerCase() === searchNym.toLowerCase()) {
                            if (searchSuffix) {
                                // If suffix provided, only match exact pubkey suffix
                                if (pubkey.endsWith(searchSuffix)) {
                                    matches.push({ nym: user.nym, pubkey: pubkey });
                                }
                            } else {
                                // No suffix provided, collect all matches
                                matches.push({ nym: user.nym, pubkey: pubkey });
                            }
                        }
                    });

                    if (matches.length === 0) {
                        this.displaySystemMessage(`User ${targetInput} not found`);
                        return;
                    }

                    if (matches.length > 1 && !searchSuffix) {
                        // Multiple users with same nym, show them
                        const matchList = matches.map(m =>
                            `${this.formatNymWithPubkey(m.nym, m.pubkey)}`
                        ).join(', ');
                        this.displaySystemMessage(`Multiple users found with nym "${searchNym}": ${matchList}`);
                        this.displaySystemMessage('Please specify using the #xxxx suffix or full pubkey');
                        return;
                    }

                    // Single match or exact suffix match
                    targetPubkey = matches[0].pubkey;
                    matchedNym = matches[0].nym;

                    if (targetPubkey === this.pubkey) {
                        this.displaySystemMessage("You can't invite yourself");
                        return;
                    }
                }

                // Determine if target is ephemeral (check if they have a persistent identity)
                const targetIsEphemeral = await this.isUserEphemeral(targetPubkey);

                // Create channel info with proper type detection
                let channelInfo;
                let joinCommand;
                let canJoin = true;

                if (this.currentCommunity) {
                    // Community channel
                    const community = this.communityChannels.get(this.currentCommunity);
                    const privacyType = community?.isPrivate ? 'private' : 'public';
                    channelInfo = `#${community?.name || this.currentCommunity} [${privacyType.toUpperCase()} COMMUNITY]`;
                    joinCommand = `/join ${community?.name || this.currentCommunity}`;

                    // Check if target is ephemeral - they can't join communities
                    if (targetIsEphemeral) {
                        canJoin = false;
                    }
                } else if (this.currentGeohash) {
                    // Geohash channel
                    channelInfo = `#${this.currentGeohash} [GEO]`;
                    joinCommand = `/join #${this.currentGeohash}`;
                } else {
                    // Standard channel
                    channelInfo = `#${this.currentChannel} [EPH]`;
                    joinCommand = `/join ${this.currentChannel}`;
                }

                // Send an invitation as a PM
                let inviteMessage;
                if (canJoin) {
                    inviteMessage = `📨 Channel Invitation: You've been invited to join ${channelInfo}. Use ${joinCommand} to join!`;
                } else {
                    inviteMessage = `📨 Channel Invitation: You've been invited to join ${channelInfo}. However, community channels require a persistent identity (extension or nsec login). Ephemeral users cannot join communities.`;
                }

                // Send as PM
                const sent = await this.sendPM(inviteMessage, targetPubkey);

                if (sent) {
                    const displayNym = this.formatNymWithPubkey(matchedNym, targetPubkey);
                    if (canJoin) {
                        this.displaySystemMessage(`Invitation sent to ${displayNym} for ${channelInfo}`);
                    } else {
                        this.displaySystemMessage(`Invitation sent to ${displayNym} for ${channelInfo} (Note: They cannot join as an ephemeral user)`);
                    }

                    // Also send a mention in the current channel (only if they can join)
                    if (canJoin) {
                        const publicNotice = `@${matchedNym} you've been invited to this channel! Check your PMs for details.`;

                        if (this.currentCommunity) {
                            await this.publishCommunityMessage(publicNotice, this.currentCommunity);
                        } else {
                            await this.publishMessage(publicNotice, this.currentChannel, this.currentGeohash);
                        }
                    }
                } else {
                    this.displaySystemMessage(`Failed to send invitation to ${this.formatNymWithPubkey(matchedNym, targetPubkey)}`);
                }
            }

            // Helper function to check if user is ephemeral
            async isUserEphemeral(pubkey) {
                // A user is ephemeral if they don't have a profile (kind 0 event)
                // We can check if we have their profile data
                return new Promise((resolve) => {
                    const subId = "check-ephemeral-" + Math.random().toString(36).substring(7);
                    let found = false;

                    const timeout = setTimeout(() => {
                        this.sendToRelay(["CLOSE", subId]);
                        resolve(true); // No profile found, likely ephemeral
                    }, 2000);

                    // Temporary handler for this check
                    const originalHandler = this.handleRelayMessage.bind(this);
                    this.handleRelayMessage = (msg, relayUrl) => {
                        if (Array.isArray(msg) && msg[0] === 'EVENT' && msg[1] === subId) {
                            const event = msg[2];
                            if (event && event.kind === 0 && event.pubkey === pubkey) {
                                found = true;
                                clearTimeout(timeout);
                                this.handleRelayMessage = originalHandler;
                                this.sendToRelay(["CLOSE", subId]);
                                resolve(false); // Has profile, not ephemeral
                            }
                        } else if (Array.isArray(msg) && msg[0] === 'EOSE' && msg[1] === subId) {
                            clearTimeout(timeout);
                            this.handleRelayMessage = originalHandler;
                            this.sendToRelay(["CLOSE", subId]);
                            resolve(!found); // If no profile found, they're ephemeral
                        }
                        originalHandler(msg, relayUrl);
                    };

                    // Request user's profile
                    const subscription = [
                        "REQ",
                        subId,
                        {
                            kinds: [0],
                            authors: [pubkey],
                            limit: 1
                        }
                    ];

                    this.sendToRelay(subscription);
                });
            }

            async cmdCreateCommunity(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /createcommunity name [description] [--private]');
                    this.displaySystemMessage('Example: /createcommunity bitcoin "Bitcoin discussion" --private');
                    this.displaySystemMessage('Note: Community names cannot contain spaces. Use hyphens instead.');
                    return;
                }

                if (this.connectionMode === 'ephemeral') {
                    this.displaySystemMessage('Community channels require a persistent identity. Please use extension or nsec login.');
                    return;
                }

                const parts = args.split('"');
                const name = parts[0].trim().replace('--private', '').trim();
                const description = parts[1] || '';
                const isPrivate = args.includes('--private');

                if (!name) {
                    this.displaySystemMessage('Please provide a community name');
                    return;
                }

                // Validate name - no spaces allowed
                if (name.includes(' ')) {
                    this.displaySystemMessage('Community names cannot contain spaces. Use hyphens instead (e.g., "my-community")');
                    return;
                }

                const communityId = await this.createCommunityChannel(name, description, isPrivate);

                if (communityId) {
                    this.switchToCommunity(communityId);
                }
            }

            async cmdAddMod(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /addmod nym, /addmod nym#xxxx, or /addmod [pubkey]');
                    return;
                }

                if (!this.currentCommunity) {
                    this.displaySystemMessage('You must be in a community channel to use /addmod');
                    return;
                }

                const community = this.communityChannels.get(this.currentCommunity);
                if (!community) {
                    this.displaySystemMessage('Current community not found');
                    return;
                }

                // Only admin can add moderators
                if (!this.ownedCommunities.has(this.currentCommunity)) {
                    this.displaySystemMessage('Only the community admin can add moderators');
                    return;
                }

                const targetPubkey = await this.findUserPubkey(args.trim());
                if (!targetPubkey) return;

                const matchedNym = this.getNymFromPubkey(targetPubkey);

                if (targetPubkey === this.pubkey) {
                    this.displaySystemMessage("You're already the admin (and a moderator)");
                    return;
                }

                // Check if already a moderator
                if (this.communityModerators.has(this.currentCommunity) &&
                    this.communityModerators.get(this.currentCommunity).has(targetPubkey)) {
                    this.displaySystemMessage(`${this.formatNymWithPubkey(matchedNym, targetPubkey)} is already a moderator`);
                    return;
                }

                // Add as moderator
                if (!this.communityModerators.has(this.currentCommunity)) {
                    this.communityModerators.set(this.currentCommunity, new Set());
                }
                this.communityModerators.get(this.currentCommunity).add(targetPubkey);

                // Update community definition
                await this.updateCommunityDefinitionWithBans(this.currentCommunity);

                // Parse base nym from display format - this removes HTML tags
                const parsedNym = this.parseNymFromDisplay(matchedNym);
                // Get just the base nym without any suffix
                const baseNym = parsedNym.split('#')[0] || parsedNym;
                const suffix = this.getPubkeySuffix(targetPubkey);
                const fullNym = `${baseNym}#${suffix}`;

                const displayNym = this.formatNymWithPubkey(matchedNym, targetPubkey);
                this.displaySystemMessage(`Added ${displayNym} as a moderator`);

                // Announce in channel with full nym#suffix
                await this.publishCommunityMessage(`⭐ ${fullNym} is now a moderator of this community`, this.currentCommunity);
            }

            async cmdRemoveMod(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /removemod nym, /removemod nym#xxxx, or /removemod [pubkey]');
                    return;
                }

                if (!this.currentCommunity) {
                    this.displaySystemMessage('You must be in a community channel to use /removemod');
                    return;
                }

                const community = this.communityChannels.get(this.currentCommunity);
                if (!community) {
                    this.displaySystemMessage('Current community not found');
                    return;
                }

                // Only admin can remove moderators
                if (!this.ownedCommunities.has(this.currentCommunity)) {
                    this.displaySystemMessage('Only the community admin can remove moderators');
                    return;
                }

                const targetPubkey = await this.findUserPubkey(args.trim());
                if (!targetPubkey) return;

                const matchedNym = this.getNymFromPubkey(targetPubkey);

                if (targetPubkey === this.pubkey) {
                    this.displaySystemMessage("You can't remove yourself as admin");
                    return;
                }

                // Check if actually a moderator
                if (!this.communityModerators.has(this.currentCommunity) ||
                    !this.communityModerators.get(this.currentCommunity).has(targetPubkey)) {
                    this.displaySystemMessage(`${this.formatNymWithPubkey(matchedNym, targetPubkey)} is not a moderator`);
                    return;
                }

                // Remove from moderators
                this.communityModerators.get(this.currentCommunity).delete(targetPubkey);

                // Update community definition
                await this.updateCommunityDefinitionWithBans(this.currentCommunity);

                // Parse base nym from display format - this removes HTML tags
                const parsedNym = this.parseNymFromDisplay(matchedNym);
                // Get just the base nym without any suffix
                const baseNym = parsedNym.split('#')[0] || parsedNym;
                const suffix = this.getPubkeySuffix(targetPubkey);
                const fullNym = `${baseNym}#${suffix}`;

                const displayNym = this.formatNymWithPubkey(matchedNym, targetPubkey);
                this.displaySystemMessage(`Removed ${displayNym} as a moderator`);

                // Announce in channel with full nym#suffix
                await this.publishCommunityMessage(`📋 ${fullNym} is no longer a moderator of this community`, this.currentCommunity);
            }

            async cmdKick(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /kick nym, /kick nym#xxxx, or /kick [pubkey]');
                    return;
                }

                if (!this.currentCommunity) {
                    this.displaySystemMessage('You must be in a community channel to use /kick');
                    return;
                }

                const community = this.communityChannels.get(this.currentCommunity);
                if (!community) {
                    this.displaySystemMessage('Current community not found');
                    return;
                }

                // Check if user is admin or moderator
                const isAdmin = this.ownedCommunities.has(this.currentCommunity);
                const isMod = this.communityModerators.has(this.currentCommunity) &&
                    this.communityModerators.get(this.currentCommunity).has(this.pubkey);

                if (!isAdmin && !isMod) {
                    this.displaySystemMessage('Only admins and moderators can kick users');
                    return;
                }

                const targetPubkey = await this.findUserPubkey(args.trim());
                if (!targetPubkey) return;

                const targetNym = this.getNymFromPubkey(targetPubkey);

                // Parse base nym from display format
                const parsedNym = this.parseNymFromDisplay(targetNym);
                const baseNym = parsedNym.split('#')[0] || parsedNym;
                const suffix = this.getPubkeySuffix(targetPubkey);
                const fullNym = `${baseNym}#${suffix}`;

                // Don't allow kicking admin
                if (targetPubkey === community.admin) {
                    this.displaySystemMessage("You can't kick the community admin");
                    return;
                }

                // Mods can't kick other mods
                if (isMod && !isAdmin) {
                    const targetIsMod = this.communityModerators.has(this.currentCommunity) &&
                        this.communityModerators.get(this.currentCommunity).has(targetPubkey);
                    if (targetIsMod) {
                        this.displaySystemMessage("Moderators can't kick other moderators");
                        return;
                    }
                }

                // Initialize temporary kicks map if needed
                if (!this.communityTemporaryKicks) {
                    this.communityTemporaryKicks = new Map();
                }
                if (!this.communityTemporaryKicks.has(this.currentCommunity)) {
                    this.communityTemporaryKicks.set(this.currentCommunity, new Map());
                }

                // Add temporary kick (15 minutes)
                const kickExpiry = Date.now() + (15 * 60 * 1000); // 15 minutes
                this.communityTemporaryKicks.get(this.currentCommunity).set(targetPubkey, kickExpiry);

                // Publish kick event as NIP-56 moderation event (kind 1984)
                const kickEvent = {
                    kind: 1984,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ['a', `34550:${community.admin}:${this.currentCommunity}`],
                        ['p', targetPubkey],
                        ['action', 'kick'],
                        ['expiry', kickExpiry.toString()]
                    ],
                    content: `Kicked from community for 15 minutes`,
                    pubkey: this.pubkey
                };

                // Sign the event
                let signedEvent;
                if (window.nostr && !this.privkey) {
                    signedEvent = await window.nostr.signEvent(kickEvent);
                } else if (this.privkey) {
                    signedEvent = window.NostrTools.finalizeEvent(kickEvent, this.privkey);
                } else {
                    this.displaySystemMessage('No signing method available');
                    return;
                }

                // Send the signed event
                this.sendToRelay(["EVENT", signedEvent]);

                const displayNym = this.formatNymWithPubkey(targetNym, targetPubkey);
                this.displaySystemMessage(`Kicked ${displayNym} from this community (15 min cooldown)`);

                // Also announce in the community channel
                await this.publishCommunityMessage(`👢 ${fullNym} has been kicked from this community (15 min cooldown)`, this.currentCommunity);

                // Set up auto-cleanup after 15 minutes
                setTimeout(() => {
                    if (this.communityTemporaryKicks.has(this.currentCommunity)) {
                        const kicks = this.communityTemporaryKicks.get(this.currentCommunity);
                        if (kicks.has(targetPubkey)) {
                            kicks.delete(targetPubkey);
                            console.log(`Kick expired for ${fullNym} in ${community.name}`);
                        }
                    }
                }, 15 * 60 * 1000);
            }

            async cmdBan(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /ban nym, /ban nym#xxxx, or /ban [pubkey]');
                    return;
                }

                if (!this.currentCommunity) {
                    this.displaySystemMessage('You must be in a community channel to use /ban');
                    return;
                }

                const community = this.communityChannels.get(this.currentCommunity);
                if (!community) {
                    this.displaySystemMessage('Current community not found');
                    return;
                }

                // Check if user is admin or moderator
                const isAdmin = this.ownedCommunities.has(this.currentCommunity);
                const isMod = this.communityModerators.has(this.currentCommunity) &&
                    this.communityModerators.get(this.currentCommunity).has(this.pubkey);

                if (!isAdmin && !isMod) {
                    this.displaySystemMessage('Only admins and moderators can ban users');
                    return;
                }

                const targetPubkey = await this.findUserPubkey(args.trim());
                if (!targetPubkey) return;

                const targetNym = this.getNymFromPubkey(targetPubkey);

                if (targetPubkey === this.pubkey) {
                    this.displaySystemMessage("You can't ban yourself");
                    return;
                }

                // Check if already banned
                if (this.communityBans.has(this.currentCommunity) &&
                    this.communityBans.get(this.currentCommunity).has(targetPubkey)) {
                    this.displaySystemMessage(`${this.formatNymWithPubkey(targetNym, targetPubkey)} is already banned`);
                    return;
                }

                // Add to bans
                if (!this.communityBans.has(this.currentCommunity)) {
                    this.communityBans.set(this.currentCommunity, new Set());
                }
                this.communityBans.get(this.currentCommunity).add(targetPubkey);

                // Remove from moderators if they were one
                if (this.communityModerators.has(this.currentCommunity)) {
                    this.communityModerators.get(this.currentCommunity).delete(targetPubkey);
                }

                // Clean up messages from banned user immediately
                if (this.messages.has(this.currentCommunity)) {
                    this.messages.get(this.currentCommunity).forEach(msg => {
                        if (msg.pubkey === targetPubkey) {
                            msg.blocked = true;
                        }
                    });
                }

                // Remove from DOM immediately
                document.querySelectorAll(`.message[data-pubkey="${targetPubkey}"]`).forEach(msg => {
                    if (msg.closest('.messages-container')?.dataset.lastCommunity === this.currentCommunity) {
                        msg.remove();
                    }
                });

                // Update community definition
                await this.updateCommunityDefinitionWithBans(this.currentCommunity);

                // Parse base nym from display format - this removes HTML tags
                const parsedNym = this.parseNymFromDisplay(targetNym);
                // Get just the base nym without any suffix
                const baseNym = parsedNym.split('#')[0] || parsedNym;
                const suffix = this.getPubkeySuffix(targetPubkey);
                const fullNym = `${baseNym}#${suffix}`;

                const displayNym = this.formatNymWithPubkey(targetNym, targetPubkey);
                this.displaySystemMessage(`Banned ${displayNym} from this community`);

                // Announce in channel with full nym#suffix
                await this.publishCommunityMessage(`🚫 ${fullNym} has been banned from this community`, this.currentCommunity);
            }

            async cmdUnban(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /unban nym, /unban nym#xxxx, or /unban [pubkey]');
                    return;
                }

                if (!this.currentCommunity) {
                    this.displaySystemMessage('You must be in a community channel to use /unban');
                    return;
                }

                const community = this.communityChannels.get(this.currentCommunity);
                if (!community) {
                    this.displaySystemMessage('Current community not found');
                    return;
                }

                // Check if user is admin or moderator
                const isAdmin = this.ownedCommunities.has(this.currentCommunity);
                const isMod = this.communityModerators.has(this.currentCommunity) &&
                    this.communityModerators.get(this.currentCommunity).has(this.pubkey);

                if (!isAdmin && !isMod) {
                    this.displaySystemMessage('Only admins and moderators can unban users');
                    return;
                }

                const targetPubkey = await this.findUserPubkey(args.trim());
                if (!targetPubkey) return;

                const targetNym = this.getNymFromPubkey(targetPubkey);

                // Parse base nym from display format
                const parsedNym = this.parseNymFromDisplay(targetNym);
                const baseNym = parsedNym.split('#')[0] || parsedNym;
                const suffix = this.getPubkeySuffix(targetPubkey);
                const fullNym = `${baseNym}#${suffix}`;

                // Check if actually banned
                if (!this.communityBans.has(this.currentCommunity) ||
                    !this.communityBans.get(this.currentCommunity).has(targetPubkey)) {
                    this.displaySystemMessage(`${this.formatNymWithPubkey(targetNym, targetPubkey)} is not banned`);
                    return;
                }

                // Remove from bans
                this.communityBans.get(this.currentCommunity).delete(targetPubkey);

                // Update community definition
                await this.updateCommunityDefinitionWithBans(this.currentCommunity);

                // Re-subscribe to the unbanned user's messages for this community
                if (this.connected && this.relay) {
                    const filter = {
                        kinds: [1],
                        authors: [targetPubkey],
                        '#q': [this.currentCommunity],
                        since: Math.floor(Date.now() / 1000)
                    };

                    this.relay.subscribe([filter], {
                        onevent: (event) => {
                            this.handleNostrEvent(event);
                        },
                        oneose: () => {
                            console.log(`Re-subscribed to messages from unbanned user ${fullNym}`);
                        }
                    });
                }

                const displayNym = this.formatNymWithPubkey(targetNym, targetPubkey);
                this.displaySystemMessage(`Unbanned ${displayNym} from this community`);
                await this.publishCommunityMessage(`✅ ${fullNym} has been unbanned from this community`, this.currentCommunity);
            }

            async cmdInviteToCommunity(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /invitetocommunity nym, /invitetocommunity nym#xxxx, or /invitetocommunity [pubkey]');
                    return;
                }

                if (!this.currentCommunity) {
                    this.displaySystemMessage('You must be in a community channel to use /invitetocommunity');
                    return;
                }

                const community = this.communityChannels.get(this.currentCommunity);
                if (!community) {
                    this.displaySystemMessage('Current community not found');
                    return;
                }

                // Check if user is a moderator or admin
                const isAdmin = this.ownedCommunities.has(this.currentCommunity);
                const isMod = this.communityModerators.has(this.currentCommunity) &&
                    this.communityModerators.get(this.currentCommunity).has(this.pubkey);

                if (!isAdmin && !isMod) {
                    this.displaySystemMessage('You must be an admin or moderator to invite users to private communities');
                    return;
                }

                const targetInput = args.trim();
                let targetPubkey = null;
                let matchedNym = null;

                // Check if input is a pubkey (64 hex characters)
                if (/^[0-9a-f]{64}$/i.test(targetInput)) {
                    targetPubkey = targetInput.toLowerCase();

                    if (targetPubkey === this.pubkey) {
                        this.displaySystemMessage("You can't invite yourself");
                        return;
                    }

                    matchedNym = this.getNymFromPubkey(targetPubkey);
                } else {
                    // Handle nym with optional suffix
                    const hashIndex = targetInput.indexOf('#');
                    let searchNym = targetInput;
                    let searchSuffix = null;

                    if (hashIndex !== -1) {
                        searchNym = targetInput.substring(0, hashIndex);
                        searchSuffix = targetInput.substring(hashIndex + 1);
                    }

                    // Find matching users
                    const matches = [];
                    this.users.forEach((user, pubkey) => {
                        const baseNym = user.nym.split('#')[0] || user.nym;
                        if (baseNym === searchNym || baseNym.toLowerCase() === searchNym.toLowerCase()) {
                            if (searchSuffix) {
                                if (pubkey.endsWith(searchSuffix)) {
                                    matches.push({ nym: user.nym, pubkey: pubkey });
                                }
                            } else {
                                matches.push({ nym: user.nym, pubkey: pubkey });
                            }
                        }
                    });

                    if (matches.length === 0) {
                        this.displaySystemMessage(`User ${targetInput} not found`);
                        return;
                    }

                    if (matches.length > 1 && !searchSuffix) {
                        const matchList = matches.map(m =>
                            `${this.formatNymWithPubkey(m.nym, m.pubkey)}`
                        ).join(', ');
                        this.displaySystemMessage(`Multiple users found with nym "${searchNym}": ${matchList}`);
                        this.displaySystemMessage('Please specify using the #xxxx suffix or full pubkey');
                        return;
                    }

                    targetPubkey = matches[0].pubkey;
                    matchedNym = matches[0].nym;

                    if (targetPubkey === this.pubkey) {
                        this.displaySystemMessage("You can't invite yourself");
                        return;
                    }
                }

                // Check if target is banned
                const bannedUsers = this.communityBans.get(this.currentCommunity) || new Set();
                if (bannedUsers.has(targetPubkey)) {
                    this.displaySystemMessage(`Cannot invite ${this.formatNymWithPubkey(matchedNym, targetPubkey)} - they are banned from this community`);
                    return;
                }

                // Check if target is ephemeral
                const targetIsEphemeral = await this.isUserEphemeral(targetPubkey);
                if (targetIsEphemeral) {
                    this.displaySystemMessage(`Cannot invite ${this.formatNymWithPubkey(matchedNym, targetPubkey)} - ephemeral users cannot join communities`);
                    return;
                }

                // Check if already invited or member
                if (!this.communityInvites) {
                    this.communityInvites = new Map();
                }
                if (!this.communityInvites.has(this.currentCommunity)) {
                    this.communityInvites.set(this.currentCommunity, new Set());
                }

                const invitedUsers = this.communityInvites.get(this.currentCommunity);
                if (invitedUsers.has(targetPubkey)) {
                    this.displaySystemMessage(`${this.formatNymWithPubkey(matchedNym, targetPubkey)} has already been invited`);
                    return;
                }

                // Add to invited users
                invitedUsers.add(targetPubkey);

                // Send PM with invitation details
                const privacyType = community.isPrivate ? 'PRIVATE' : 'PUBLIC';
                const inviteMessage = `📨 Community Invitation: You've been invited to join #${community.name} [${privacyType} COMMUNITY]. Use /join ${community.name} to join!`;

                const sent = await this.sendPM(inviteMessage, targetPubkey);

                const displayNym = this.formatNymWithPubkey(matchedNym, targetPubkey);
                if (sent) {
                    this.displaySystemMessage(`Invitation sent to ${displayNym} for community #${community.name}`);

                    // Announce in community channel
                    await this.publishCommunityMessage(`📨 ${matchedNym} has been invited to this community`, this.currentCommunity);
                } else {
                    this.displaySystemMessage(`Failed to send invitation to ${displayNym}`);
                }
            }

            async cmdCommunityInfo() {
                if (!this.isCurrentChannelCommunity()) {
                    this.displaySystemMessage('This is not a community channel');
                    return;
                }

                const communityId = this.getCurrentCommunityId();
                const community = this.communityChannels.get(communityId);

                if (!community) {
                    this.displaySystemMessage('Community info not available');
                    return;
                }

                const isAdmin = this.ownedCommunities.has(communityId);
                const isMod = this.communityModerators.has(communityId) &&
                    this.communityModerators.get(communityId).has(this.pubkey);
                const type = community.isPrivate ? 'Private' : 'Public';

                const mods = this.communityModerators.get(communityId) || new Set();
                const members = this.communityMembers.get(communityId) || new Set();
                const banned = this.communityBans.get(communityId) || new Set();

                // Deduplicate member count
                const allMembers = new Set();
                allMembers.add(this.pubkey); // Admin
                mods.forEach(modPubkey => allMembers.add(modPubkey));
                members.forEach(memberPubkey => allMembers.add(memberPubkey));

                let info = `
═══ Community Info ═══<br/>
Name: ${community.name}<br/>
Type: ${type}<br/>
Description: ${community.description || 'None'}<br/>
Your Role: ${isAdmin ? 'Admin' : isMod ? 'Moderator' : 'Member'}<br/>
Moderators: ${mods.size}<br/>
Members: ${allMembers.size}<br/>
Banned: ${banned.size}<br/>
Created: ${new Date(community.createdAt).toLocaleDateString()}
    `;

                this.displaySystemMessage(info);

                if (isAdmin || isMod) {
                    this.displaySystemMessage('Use /members to see all members');
                    this.displaySystemMessage('Use /mods to see all moderators');
                    this.displaySystemMessage('Use /communitysettings for more options');
                }
            }

            async cmdListMembers() {
                if (!this.isCurrentChannelCommunity()) {
                    this.displaySystemMessage('This is not a community channel');
                    return;
                }

                const communityId = this.getCurrentCommunityId();

                if (!this.canModerate(communityId)) {
                    this.displaySystemMessage('Only admins and moderators can view member list');
                    return;
                }

                const members = this.communityMembers.get(communityId) || new Set();
                const community = this.communityChannels.get(communityId);

                if (members.size === 0) {
                    this.displaySystemMessage('No members found');
                    return;
                }

                let memberList = `═══ Community Members (${members.size}) ═══\n`;

                members.forEach(pubkey => {
                    const nym = this.getNymFromPubkey(pubkey);
                    const isAdmin = community.admin === pubkey;
                    const isMod = this.communityModerators.has(communityId) &&
                        this.communityModerators.get(communityId).has(pubkey);

                    let role = '';
                    if (isAdmin) role = ' [ADMIN]';
                    else if (isMod) role = ' [MOD]';

                    memberList += `${nym}${role}\n`;
                });

                this.displaySystemMessage(memberList);
            }

            async cmdListMods() {
                if (!this.isCurrentChannelCommunity()) {
                    this.displaySystemMessage('This is not a community channel');
                    return;
                }

                const communityId = this.getCurrentCommunityId();
                const mods = this.communityModerators.get(communityId) || new Set();
                const community = this.communityChannels.get(communityId);

                let modList = `═══ Community Moderators ═══\n`;
                modList += `Admin: ${this.getNymFromPubkey(community.admin)}\n`;

                if (mods.size > 0) {
                    modList += `\nModerators (${mods.size}):\n`;
                    mods.forEach(pubkey => {
                        const nym = this.getNymFromPubkey(pubkey);
                        modList += `${nym}\n`;
                    });
                } else {
                    modList += '\nNo additional moderators';
                }

                this.displaySystemMessage(modList);
            }

            async cmdCommunitySettings() {
                if (!this.isCurrentChannelCommunity()) {
                    this.displaySystemMessage('This is not a community channel');
                    return;
                }

                const communityId = this.getCurrentCommunityId();

                if (!this.ownedCommunities.has(communityId)) {
                    this.displaySystemMessage('Only community admins can access settings');
                    return;
                }

                // Show community settings modal
                this.showCommunitySettingsModal(communityId);
            }

            async cmdBlock(args) {
                if (!args) {
                    // If no args, check if in a channel that can be blocked
                    if (this.inPMMode) {
                        this.displaySystemMessage('Usage: /block nym, /block nym#xxxx, /block [pubkey], or /block #channel');
                        return;
                    }

                    // Check current channel
                    const currentChannelName = this.currentGeohash || this.currentChannel;
                    if (currentChannelName === 'bar' && !this.currentGeohash) {
                        this.displaySystemMessage('Cannot block the default #bar channel');
                        return;
                    }

                    // Block current channel
                    if (confirm(`Block channel #${currentChannelName}?`)) {
                        if (this.currentGeohash) {
                            this.blockChannel(this.currentGeohash, this.currentGeohash);
                            this.displaySystemMessage(`Blocked geohash channel #${this.currentGeohash}`);
                        } else {
                            this.blockChannel(this.currentChannel, '');
                            this.displaySystemMessage(`Blocked channel #${this.currentChannel}`);
                        }

                        // Switch to #bar
                        this.switchChannel('bar', '');

                        this.updateBlockedChannelsList();

                        // Sync to Nostr
                        if (this.connectionMode !== 'ephemeral') {
                            await this.saveSyncedSettings();
                        }
                    }
                    return;
                }

                const target = args.trim();

                // Check if it's a channel block
                if (target.startsWith('#') && !target.includes('@')) {
                    const channelName = target.substring(1);

                    // Check if it's current channel
                    if ((this.currentChannel === channelName && !this.currentGeohash) ||
                        (this.currentGeohash === channelName)) {
                        // Block current channel and switch to bar
                        if (confirm(`Block and leave channel #${channelName}?`)) {
                            if (this.isValidGeohash(channelName)) {
                                this.blockChannel(channelName, channelName);
                                this.displaySystemMessage(`Blocked geohash channel #${channelName}`);
                            } else {
                                this.blockChannel(channelName, '');
                                this.displaySystemMessage(`Blocked channel #${channelName}`);
                            }

                            // Switch to #bar
                            this.switchChannel('bar', '');

                            this.updateBlockedChannelsList();

                            // Sync to Nostr
                            if (this.connectionMode !== 'ephemeral') {
                                await this.saveSyncedSettings();
                            }
                        }
                        return;
                    }

                    // Don't allow blocking #bar
                    if (channelName === 'bar') {
                        this.displaySystemMessage("Cannot block the default #bar channel");
                        return;
                    }

                    // Determine if it's a geohash or standard channel
                    if (this.isValidGeohash(channelName)) {
                        this.blockChannel(channelName, channelName);
                        this.displaySystemMessage(`Blocked geohash channel #${channelName}`);
                    } else {
                        this.blockChannel(channelName, '');
                        this.displaySystemMessage(`Blocked channel #${channelName}`);
                    }

                    this.updateBlockedChannelsList();

                    // Sync to Nostr
                    if (this.connectionMode !== 'ephemeral') {
                        await this.saveSyncedSettings();
                    }

                    return;
                }

                // Check if input is already a pubkey (64 hex characters)
                let targetPubkey;
                if (/^[0-9a-f]{64}$/i.test(target)) {
                    targetPubkey = target.toLowerCase();
                } else {
                    // User blocking - use findUserPubkey for nym lookup
                    targetPubkey = await this.findUserPubkey(target);
                    if (!targetPubkey) return;
                }

                const targetNym = this.getNymFromPubkey(targetPubkey);
                const cleanNym = this.getCleanNym ? this.getCleanNym(targetNym) : targetNym.replace(/<[^>]*>/g, '');

                // Check if already blocked to toggle
                if (this.blockedUsers.has(targetPubkey)) {
                    // Unblock
                    this.blockedUsers.delete(targetPubkey);
                    this.saveBlockedUsers();
                    this.showMessagesFromUnblockedUser(targetPubkey);

                    this.displaySystemMessage(`Unblocked ${cleanNym}`);
                    this.updateUserList();
                    this.updateBlockedList();

                    // Save to synced settings for persistent connections
                    if (this.connectionMode !== 'ephemeral') {
                        await this.saveSyncedSettings();
                    }
                    return;
                }

                this.blockedUsers.add(targetPubkey);
                this.saveBlockedUsers();
                this.hideMessagesFromBlockedUser(targetPubkey);

                this.displaySystemMessage(`Blocked ${cleanNym}`);
                this.updateUserList();
                this.updateBlockedList();

                // Save to synced settings for persistent connections
                if (this.connectionMode !== 'ephemeral') {
                    await this.saveSyncedSettings();
                }
            }

            unblockByPubkey(pubkey) {
                this.blockedUsers.delete(pubkey);
                this.saveBlockedUsers();
                this.showMessagesFromUnblockedUser(pubkey);

                const nym = this.getNymFromPubkey(pubkey);
                this.displaySystemMessage(`Unblocked ${nym}`);
                this.updateUserList();
                this.updateBlockedList();

                // Save to synced settings for persistent connections
                if (this.connectionMode !== 'ephemeral') {
                    this.saveSyncedSettings();
                }
            }

            hideMessagesFromBlockedUser(pubkey) {
                // Hide messages in current DOM
                document.querySelectorAll('.message').forEach(msg => {
                    if (msg.dataset.pubkey === pubkey) {
                        msg.style.display = 'none';
                        msg.classList.add('blocked-user-message');
                    }
                });

                // Mark messages as blocked in stored messages
                this.messages.forEach((channelMessages, channel) => {
                    channelMessages.forEach(msg => {
                        if (msg.pubkey === pubkey) {
                            msg.blocked = true;
                        }
                    });
                });

                // Mark PM messages as blocked
                this.pmMessages.forEach((conversationMessages, conversationKey) => {
                    conversationMessages.forEach(msg => {
                        if (msg.pubkey === pubkey) {
                            msg.blocked = true;
                        }
                    });
                });
            }

            hideMessagesWithBlockedKeywords() {
                // Hide messages in current DOM that contain blocked keywords
                document.querySelectorAll('.message').forEach(msg => {
                    const content = msg.querySelector('.message-content');
                    if (content) {
                        const hasBlockedKeyword = Array.from(this.blockedKeywords).some(kw =>
                            content.textContent.toLowerCase().includes(kw)
                        );

                        if (hasBlockedKeyword) {
                            msg.style.display = 'none';
                            msg.classList.add('blocked');
                        }
                    }
                });

                // Mark messages as blocked in stored messages
                this.messages.forEach((channelMessages, channel) => {
                    channelMessages.forEach(msg => {
                        if (this.hasBlockedKeyword(msg.content)) {
                            msg.blocked = true;
                        }
                    });
                });

                // Mark PM messages as blocked
                this.pmMessages.forEach((conversationMessages, conversationKey) => {
                    conversationMessages.forEach(msg => {
                        if (this.hasBlockedKeyword(msg.content)) {
                            msg.blocked = true;
                        }
                    });
                });
            }

            isNymBlocked(nym) {
                const cleanNym = this.parseNymFromDisplay(nym);
                return Array.from(this.blockedUsers).some(blockedNym =>
                    this.parseNymFromDisplay(blockedNym) === cleanNym
                );
            }

            async cmdUnblock(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /unblock nym, /unblock nym#xxxx, /unblock [pubkey], or /unblock #channel');
                    return;
                }

                const target = args.trim();

                // Check if it's a channel unblock
                if (target.startsWith('#')) {
                    const channelName = target.substring(1);

                    if (this.blockedChannels.has(channelName)) {
                        if (this.isValidGeohash(channelName)) {
                            this.unblockChannel(channelName, channelName);
                            this.displaySystemMessage(`Unblocked geohash channel #${channelName}`);
                        } else {
                            this.unblockChannel(channelName, '');
                            this.displaySystemMessage(`Unblocked channel #${channelName}`);
                        }

                        this.updateBlockedChannelsList();

                        // Sync to Nostr
                        if (this.connectionMode !== 'ephemeral') {
                            await this.saveSyncedSettings();
                        }
                    } else {
                        this.displaySystemMessage(`Channel #${channelName} is not blocked`);
                    }
                    return;
                }

                // User unblock - use findUserPubkey
                const targetPubkey = await this.findUserPubkey(target);
                if (!targetPubkey) {
                    this.displaySystemMessage(`User ${target} not found or is not blocked`);
                    return;
                }

                const targetNym = this.getNymFromPubkey(targetPubkey);

                if (!this.blockedUsers.has(targetPubkey)) {
                    this.displaySystemMessage(`User is not blocked`);
                    return;
                }

                this.blockedUsers.delete(targetPubkey);
                this.saveBlockedUsers();
                this.showMessagesFromUnblockedUser(targetPubkey);

                this.displaySystemMessage(`Unblocked ${this.formatNymWithPubkey(targetNym, targetPubkey)}`);
                this.updateUserList();
                this.updateBlockedList();

                // Save to synced settings for persistent connections
                if (this.connectionMode !== 'ephemeral') {
                    await this.saveSyncedSettings();
                }
            }

            showMessagesFromUnblockedUser(pubkey) {
                // Unmark messages in stored messages FIRST
                this.messages.forEach((channelMessages, channel) => {
                    channelMessages.forEach(msg => {
                        if (msg.pubkey === pubkey) {
                            delete msg.blocked;
                        }
                    });
                });

                // Unmark PM messages
                this.pmMessages.forEach((conversationMessages, conversationKey) => {
                    conversationMessages.forEach(msg => {
                        if (msg.pubkey === pubkey) {
                            delete msg.blocked;
                        }
                    });
                });

                // Show messages in current DOM (unless blocked by keywords)
                document.querySelectorAll('.message.blocked-user-message').forEach(msg => {
                    if (msg.dataset.pubkey === pubkey) {
                        const content = msg.querySelector('.message-content');
                        if (!content || !this.hasBlockedKeyword(content.textContent)) {
                            msg.style.display = '';
                            msg.classList.remove('blocked-user-message');
                        }
                    }
                });
            }

            async cmdSlap(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /slap nym, /slap nym#xxxx, or /slap [pubkey]');
                    return;
                }

                const targetInput = args.trim();

                // Check if input is a pubkey (64 hex characters)
                if (/^[0-9a-f]{64}$/i.test(targetInput)) {
                    const targetPubkey = targetInput.toLowerCase();
                    const targetNym = this.getNymFromPubkey(targetPubkey);
                    // Strip HTML tags from nym
                    const cleanNym = targetNym.replace(/<[^>]*>/g, '');
                    await this.publishMessage(`/me slaps ${cleanNym} around a bit with a large trout`);
                    return;
                }

                const hashIndex = targetInput.indexOf('#');
                let searchNym = targetInput;
                let searchSuffix = null;

                if (hashIndex !== -1) {
                    searchNym = targetInput.substring(0, hashIndex);
                    searchSuffix = targetInput.substring(hashIndex + 1);
                }

                // Find matching users
                const matches = [];
                this.users.forEach((user, pubkey) => {
                    const baseNym = user.nym.split('#')[0] || user.nym;
                    // Strip HTML from baseNym for comparison
                    const cleanBaseNym = baseNym.replace(/<[^>]*>/g, '');
                    if (cleanBaseNym === searchNym || cleanBaseNym.toLowerCase() === searchNym.toLowerCase()) {
                        if (searchSuffix) {
                            if (pubkey.endsWith(searchSuffix)) {
                                matches.push({ nym: user.nym, pubkey: pubkey });
                            }
                        } else {
                            matches.push({ nym: user.nym, pubkey: pubkey });
                        }
                    }
                });

                if (matches.length > 1 && !searchSuffix) {
                    const matchList = matches.map(m =>
                        `${this.formatNymWithPubkey(m.nym, m.pubkey)}`
                    ).join(', ');
                    this.displaySystemMessage(`Multiple users found with nym "${searchNym}": ${matchList}`);
                    this.displaySystemMessage('Please specify using the #xxxx suffix or full pubkey');
                    return;
                }

                // Use the target nym for the action (without suffix and without HTML tags)
                const targetNym = matches.length > 0 ? matches[0].nym.replace(/<[^>]*>/g, '') : searchNym;
                await this.publishMessage(`/me slaps ${targetNym} around a bit with a large trout`);
            }

            async cmdMe(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /me action');
                    return;
                }
                await this.publishMessage(`/me ${args}`);
            }

            async cmdShrug() {
                await this.publishMessage('¯\\_(ツ)_/¯');
            }

            async cmdBold(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /bold text');
                    return;
                }
                await this.publishMessage(`**${args}**`);
            }

            async cmdItalic(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /italic text');
                    return;
                }
                await this.publishMessage(`*${args}*`);
            }

            async cmdCode(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /code text');
                    return;
                }
                await this.publishMessage(`\`\`\`\n${args}\n\`\`\``);
            }

            async cmdStrike(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /strike text');
                    return;
                }
                await this.publishMessage(`~~${args}~~`);
            }

            async cmdQuote(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /quote text');
                    return;
                }

                // Handle both single line and multi-line quotes
                const lines = args.split('\n');
                const quotedText = lines.map(line => `> ${line}`).join('\n');
                await this.publishMessage(quotedText);
            }

            async cmdBRB(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /brb message (e.g., /brb lunch, back in 30)');
                    return;
                }

                const message = args.trim();
                this.awayMessages.set(this.pubkey, message);

                // Update user status
                if (this.users.has(this.pubkey)) {
                    this.users.get(this.pubkey).status = 'away';
                }

                this.displaySystemMessage(`Away message set: "${message}"`);
                this.displaySystemMessage('You will auto-reply to mentions in ALL channels while away');

                // Clear session storage for BRB responses to allow fresh responses
                const keysToRemove = [];
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i);
                    if (key && key.startsWith(`brb_universal_${this.pubkey}_`)) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => sessionStorage.removeItem(key));

                this.updateUserList();
            }

            async cmdBack() {
                if (this.awayMessages.has(this.pubkey)) {
                    this.awayMessages.delete(this.pubkey);

                    // Update user status
                    if (this.users.has(this.pubkey)) {
                        this.users.get(this.pubkey).status = 'online';
                    }

                    this.displaySystemMessage('Away message cleared - you are back!');

                    // Clear all universal BRB response keys
                    const keysToRemove = [];
                    for (let i = 0; i < sessionStorage.length; i++) {
                        const key = sessionStorage.key(i);
                        if (key && key.startsWith(`brb_universal_${this.pubkey}_`)) {
                            keysToRemove.push(key);
                        }
                    }
                    keysToRemove.forEach(key => sessionStorage.removeItem(key));

                    this.updateUserList();
                } else {
                    this.displaySystemMessage('You were not away');
                }
            }

            async cmdZap(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /zap nym, /zap nym#xxxx, or /zap [pubkey]');
                    return;
                }

                const targetInput = args.trim();

                // Check if input is a pubkey (64 hex characters)
                if (/^[0-9a-f]{64}$/i.test(targetInput)) {
                    const targetPubkey = targetInput.toLowerCase();

                    if (targetPubkey === this.pubkey) {
                        this.displaySystemMessage("You can't zap yourself");
                        return;
                    }

                    const targetNym = this.getNymFromPubkey(targetPubkey);
                    const displayNym = this.formatNymWithPubkey(targetNym, targetPubkey);
                    this.displaySystemMessage(`Checking if @${displayNym} can receive zaps...`);

                    const lnAddress = await this.fetchLightningAddressForUser(targetPubkey);

                    if (lnAddress) {
                        this.showProfileZapModal(targetPubkey, targetNym, lnAddress);
                    } else {
                        this.displaySystemMessage(`@${displayNym} cannot receive zaps (no lightning address set)`);
                    }
                    return;
                }

                const hashIndex = targetInput.indexOf('#');
                let searchNym = targetInput;
                let searchSuffix = null;

                if (hashIndex !== -1) {
                    searchNym = targetInput.substring(0, hashIndex);
                    searchSuffix = targetInput.substring(hashIndex + 1);
                }

                // Find matching users
                const matches = [];
                this.users.forEach((user, pubkey) => {
                    if (user.nym === searchNym || user.nym.toLowerCase() === searchNym.toLowerCase()) {
                        if (searchSuffix) {
                            if (pubkey.endsWith(searchSuffix)) {
                                matches.push({ nym: user.nym, pubkey: pubkey });
                            }
                        } else {
                            matches.push({ nym: user.nym, pubkey: pubkey });
                        }
                    }
                });

                if (matches.length === 0) {
                    this.displaySystemMessage(`User ${targetInput} not found`);
                    return;
                }

                if (matches.length > 1 && !searchSuffix) {
                    const matchList = matches.map(m =>
                        `${this.formatNymWithPubkey(m.nym, m.pubkey)}`
                    ).join(', ');
                    this.displaySystemMessage(`Multiple users found with nym "${searchNym}": ${matchList}`);
                    this.displaySystemMessage('Please specify using the #xxxx suffix or full pubkey');
                    return;
                }

                const targetPubkey = matches[0].pubkey;
                const targetNym = matches[0].nym;

                if (targetPubkey === this.pubkey) {
                    this.displaySystemMessage("You can't zap yourself");
                    return;
                }

                // Check for lightning address
                const displayNym = this.formatNymWithPubkey(targetNym, targetPubkey);
                this.displaySystemMessage(`Checking if @${displayNym} can receive zaps...`);

                const lnAddress = await this.fetchLightningAddressForUser(targetPubkey);

                if (lnAddress) {
                    // Show zap modal for profile zap (no messageId)
                    this.showProfileZapModal(targetPubkey, targetNym, lnAddress);
                } else {
                    this.displaySystemMessage(`@${displayNym} cannot receive zaps (no lightning address set)`);
                }
            }

            async cmdQuit() {
                this.displaySystemMessage('Disconnecting from NYM...');

                // Clear saved connection preferences
                localStorage.removeItem('nym_connection_mode');
                localStorage.removeItem('nym_relay_url');
                localStorage.removeItem('nym_nsec'); // Clear saved nsec

                // Clear pubkey-specific lightning address
                if (this.pubkey) {
                    localStorage.removeItem(`nym_lightning_address_${this.pubkey}`);
                }

                if (this.ws) {
                    this.ws.close();
                }
                setTimeout(() => {
                    location.reload();
                }, 1000);
            }

            loadBlockedChannels() {
                const saved = localStorage.getItem('nym_blocked_channels');
                if (saved) {
                    this.blockedChannels = new Set(JSON.parse(saved));
                }
            }

            saveBlockedChannels() {
                localStorage.setItem('nym_blocked_channels', JSON.stringify(Array.from(this.blockedChannels)));
            }

            isChannelBlocked(channel, geohash) {
                const key = geohash || channel;
                return this.blockedChannels.has(key);
            }

            blockChannel(channel, geohash) {
                const key = geohash || channel;
                this.blockedChannels.add(key);
                this.saveBlockedChannels();

                // Remove from DOM immediately
                const selector = geohash ?
                    `[data-geohash="${geohash}"]` :
                    `[data-channel="${channel}"][data-geohash=""]`;
                const element = document.querySelector(selector);
                if (element) {
                    element.remove();
                }

                // Remove from channels map
                this.channels.delete(key);

                // If currently in this channel, switch to #bar
                if ((this.currentChannel === channel && this.currentGeohash === geohash) ||
                    (geohash && this.currentGeohash === geohash)) {
                    this.switchChannel('bar', '');
                }

                // Update view more button after removing
                this.updateViewMoreButton('channelList');
            }

            unblockChannel(channel, geohash) {
                const key = geohash || channel;
                this.blockedChannels.delete(key);
                this.saveBlockedChannels();

                // Re-add the channel to the sidebar
                if (geohash) {
                    this.addChannel(geohash, geohash);
                } else {
                    this.addChannel(channel, '');
                }

                // Update view more button after adding
                this.updateViewMoreButton('channelList');
            }

            updateBlockedChannelsList() {
                const container = document.getElementById('blockedChannelsList');
                if (!container) return;

                if (this.blockedChannels.size === 0) {
                    container.innerHTML = '<div style="color: var(--text-dim); font-size: 12px;">No blocked channels</div>';
                } else {
                    container.innerHTML = Array.from(this.blockedChannels).map(key => {
                        const displayName = this.isValidGeohash(key) ? `#${key} [GEO]` : `#${key} [EPH]`;
                        return `
                <div class="blocked-item">
                    <span>${this.escapeHtml(displayName)}</span>
                    <button class="unblock-btn" onclick="nym.unblockChannelFromSettings('${this.escapeHtml(key)}')">Unblock</button>
                </div>
            `;
                    }).join('');
                }
            }

            unblockChannelFromSettings(key) {
                if (this.isValidGeohash(key)) {
                    this.unblockChannel(key, key);
                } else {
                    this.unblockChannel(key, '');
                }
                this.updateBlockedChannelsList();

                // Sync to Nostr if logged in
                if (this.connectionMode !== 'ephemeral') {
                    this.saveSyncedSettings();
                }
            }

            switchChannel(channel, geohash = '') {
                // Store previous state
                const previousChannel = this.currentChannel;
                const previousGeohash = this.currentGeohash;
                const previousCommunity = this.currentCommunity;

                // Check if we're actually switching to a different channel
                const isSameChannel = !this.inPMMode &&
                    channel === previousChannel &&
                    geohash === previousGeohash &&
                    !previousCommunity;

                if (isSameChannel) {
                    return; // Don't reload the same channel
                }

                this.inPMMode = false;
                this.currentPM = null;
                this.currentChannel = channel;
                this.currentGeohash = geohash;
                this.currentCommunity = null; // Clear community mode

                // Show share button in channel mode
                const shareBtn = document.getElementById('shareChannelBtn');
                if (shareBtn) {
                    shareBtn.style.display = 'block';
                }

                const displayName = geohash ? `#${geohash}` : `#${channel}`;
                let fullTitle = displayName;

                // Add channel type label
                if (geohash) {
                    // Geohash channel - add location info and label
                    const location = this.getGeohashLocation(geohash);
                    console.log(`Getting location for geohash ${geohash}: ${location}`);

                    if (location) {
                        fullTitle = `${displayName} <span style="font-size: 12px; color: var(--text-dim);">(Geohash)</span><br/><font size="2" style="color: var(--text-dim);text-shadow:none;"><a style="color: var(--text-dim);text-shadow:none;" href="https://www.openstreetmap.org/search?query=${location}&zoom=5&minlon=-138.55957031250003&minlat=11.953349393643416&maxlon=-97.69042968750001&maxlat=55.25407706707272#map=5/47.81/5.63" target="_blank" rel="noopener">${location}</a></font>`;

                        if (this.userLocation && this.settings.sortByProximity) {
                            try {
                                const coords = this.decodeGeohash(geohash);
                                const distance = this.calculateDistance(
                                    this.userLocation.lat, this.userLocation.lng,
                                    coords.lat, coords.lng
                                );
                                fullTitle = `${displayName} <span style="font-size: 12px; color: var(--text-dim);">(Geohash)</span><br/><font size="2" style="color: var(--text-dim);text-shadow:none;"><a style="color: var(--text-dim);text-shadow:none;" href="https://www.openstreetmap.org/search?query=${location}&zoom=5&minlon=-138.55957031250003&minlat=11.953349393643416&maxlon=-97.69042968750001&maxlat=55.25407706707272#map=5/47.81/5.63" target="_blank" rel="noopener">${location}</a> (${distance.toFixed(1)}km)</font>`;
                            } catch (e) {
                                console.error('Distance calculation error:', e);
                            }
                        }
                    } else {
                        // No location info available, just add label
                        fullTitle = `${displayName} <span style="font-size: 12px; color: var(--text-dim);">(Geohash)</span>`;
                    }
                } else {
                    // Standard ephemeral channel
                    fullTitle = `${displayName} <span style="font-size: 12px; color: var(--text-dim);">(Ephemeral)</span>`;
                }

                document.getElementById('currentChannel').innerHTML = fullTitle;

                // Update active state
                document.querySelectorAll('.channel-item').forEach(item => {
                    const isActive = item.dataset.channel === channel &&
                        item.dataset.geohash === geohash &&
                        !item.dataset.community; // Make sure it's not a community item
                    item.classList.toggle('active', isActive);
                });

                document.querySelectorAll('.pm-item').forEach(item => {
                    item.classList.remove('active');
                });

                // Clear unread count
                const unreadKey = geohash ? `#${geohash}` : channel;
                this.clearUnreadCount(unreadKey);

                // Load channel messages only if switching to different channel
                const storageKey = geohash ? `#${geohash}` : channel;
                const previousKey = previousGeohash ? `#${previousGeohash}` : previousChannel;

                if (storageKey !== previousKey || previousCommunity) {
                    this.loadChannelMessages(displayName);
                }

                // Update user list for this channel
                this.updateUserList();

                // Close mobile sidebar on mobile
                if (window.innerWidth <= 768) {
                    this.closeSidebar();
                }
            }

            switchToCommunity(communityId) {
                const community = this.communityChannels.get(communityId);
                if (!community) {
                    this.displaySystemMessage('Community not found');
                    return;
                }

                // Check if we're already in this community
                if (!this.inPMMode && this.currentCommunity === communityId) {
                    return; // Don't reload the same community
                }

                // Set community mode - clear ALL other modes
                this.inPMMode = false;
                this.currentPM = null;
                this.currentChannel = null; // Clear standard channel
                this.currentGeohash = ''; // Clear geohash
                this.currentCommunity = communityId; // Set community

                // Show share button in community mode
                const shareBtn = document.getElementById('shareChannelBtn');
                if (shareBtn) {
                    shareBtn.style.display = 'block';
                }

                document.getElementById('currentChannel').innerHTML = `#${this.escapeHtml(community.name)} <span style="font-size: 12px; color: var(--text-dim);">(Community)</span>`;

                // Update active state - only activate community items
                document.querySelectorAll('.channel-item').forEach(item => {
                    const itemCommunity = item.dataset.community || '';
                    const isCommunityItem = item.dataset.isCommunity === 'true';

                    if (isCommunityItem) {
                        item.classList.toggle('active', itemCommunity === communityId);
                    } else {
                        item.classList.remove('active');
                    }
                });

                document.querySelectorAll('.pm-item').forEach(item => {
                    item.classList.remove('active');
                });

                // Clear unread count
                this.clearUnreadCount(communityId);

                // Load community messages (will check internally if already loaded)
                this.loadCommunityMessages(communityId);

                // Update user list
                this.updateUserList();

                // Close mobile sidebar
                if (window.innerWidth <= 768) {
                    this.closeSidebar();
                }

                console.log('Switched to community. Current state:', {
                    currentCommunity: this.currentCommunity,
                    currentChannel: this.currentChannel,
                    currentGeohash: this.currentGeohash,
                    inPMMode: this.inPMMode
                });
            }

            loadCommunityMessages(communityId) {
                const container = document.getElementById('messagesContainer');

                // Check if we're loading the same community
                if (container.dataset.lastCommunity === communityId) {
                    console.log('Same community, not clearing messages');
                    return;
                }

                // Clear and mark new community
                container.innerHTML = '';
                container.dataset.lastCommunity = communityId;

                // Clear channel marker since we're in a community
                delete container.dataset.lastChannel;

                const community = this.communityChannels.get(communityId);
                if (!community) return;

                // Get the ban list for this community BEFORE displaying messages
                const bannedUsers = this.communityBans.get(communityId) || new Set();

                // Community messages would be stored under the community ID
                const communityMessages = this.messages.get(communityId) || [];

                // Filter out messages from banned users AND globally blocked users
                const filteredMessages = communityMessages.filter(msg => {
                    // Check if author is banned from THIS community
                    if (bannedUsers.has(msg.pubkey)) {
                        return false;
                    }
                    // Check if author is globally blocked (by pubkey or nym)
                    if (this.blockedUsers.has(msg.pubkey) || this.isNymBlocked(msg.author) || msg.blocked) {
                        return false;
                    }
                    // Check if message contains blocked keywords for this community
                    if (this.hasCommunityBlockedKeyword(msg.content, communityId)) {
                        return false;
                    }
                    // Check if message contains globally blocked keywords
                    if (this.hasBlockedKeyword(msg.content)) {
                        return false;
                    }
                    return true;
                });

                filteredMessages.forEach(msg => {
                    this.displayMessage(msg);
                });

                if (filteredMessages.length === 0) {
                    this.displaySystemMessage(`Welcome to #${community.name}`);
                    this.displaySystemMessage(`This is a ${community.isPrivate ? 'private' : 'public'} community`);
                }

                if (this.settings.autoscroll) {
                    setTimeout(() => {
                        container.scrollTop = container.scrollHeight;
                    }, 0);
                }
            }

            loadChannelMessages(displayName) {
                const container = document.getElementById('messagesContainer');
                const storageKey = this.currentGeohash ? `#${this.currentGeohash}` : this.currentChannel;

                // Check if we're loading the same channel
                if (container.dataset.lastChannel === storageKey) {
                    console.log('Same channel, not clearing messages');
                    return;
                }

                // Clear and mark new channel
                container.innerHTML = '';
                container.dataset.lastChannel = storageKey;

                // Clear community marker since we're in a regular channel
                delete container.dataset.lastCommunity;

                let channelMessages = this.messages.get(storageKey) || [];

                // Limit display to prevent freezing
                const maxDisplayMessages = 500;
                const originalCount = channelMessages.length;

                // Sort messages by timestamp
                channelMessages.sort((a, b) => a.timestamp - b.timestamp);

                // Get only the most recent messages for display
                const messagesToDisplay = channelMessages.slice(-maxDisplayMessages);

                // If we have more messages than we're displaying, show a notice
                if (originalCount > maxDisplayMessages) {
                    const loadMoreDiv = document.createElement('div');
                    loadMoreDiv.className = 'system-message';
                    loadMoreDiv.style.cssText = 'cursor: pointer; color: var(--text-dim); font-size: 12px; text-align: center; padding: 10px;';
                    loadMoreDiv.textContent = `Showing most recent ${maxDisplayMessages} messages (${originalCount - maxDisplayMessages} older messages available)`;
                    loadMoreDiv.onclick = () => {
                        // Load all messages (with a warning)
                        if (originalCount > 500) {
                            if (confirm(`Loading ${originalCount} messages may slow down your browser. Continue?`)) {
                                this.displayAllChannelMessages(storageKey);
                            }
                        } else {
                            this.displayAllChannelMessages(storageKey);
                        }
                    };
                    container.appendChild(loadMoreDiv);
                }

                // Display messages, filtering out blocked users
                messagesToDisplay.forEach(msg => {
                    if (!this.blockedUsers.has(msg.author) && !msg.blocked) {
                        this.displayMessage(msg);
                    }
                });

                if (channelMessages.length === 0) {
                    this.displaySystemMessage(`Joined ${displayName}`);
                }

                // Scroll to bottom after rendering
                if (this.settings.autoscroll) {
                    setTimeout(() => {
                        container.scrollTop = container.scrollHeight;
                    }, 0);
                }
            }

            displayAllChannelMessages(storageKey) {
                const container = document.getElementById('messagesContainer');
                container.innerHTML = '';

                const channelMessages = this.messages.get(storageKey) || [];

                // Show loading indicator for large sets
                if (channelMessages.length > 1000) {
                    this.displaySystemMessage('Loading all messages...');
                }

                // Use requestAnimationFrame to prevent blocking
                let index = 0;
                const batchSize = 50;

                const renderBatch = () => {
                    const batch = channelMessages.slice(index, index + batchSize);

                    batch.forEach(msg => {
                        if (!this.blockedUsers.has(msg.author) && !msg.blocked) {
                            this.displayMessage(msg);
                        }
                    });

                    index += batchSize;

                    if (index < channelMessages.length) {
                        requestAnimationFrame(renderBatch);
                    } else {
                        // Finished loading all
                        if (this.settings.autoscroll) {
                            container.scrollTop = container.scrollHeight;
                        }
                    }
                };

                requestAnimationFrame(renderBatch);
            }

            addChannel(channel, geohash = '') {
                const list = document.getElementById('channelList');
                const key = geohash || channel;

                // Don't add blocked channels
                if (this.isChannelBlocked(channel, geohash)) {
                    console.log(`Channel ${key} is blocked, not adding to list`);
                    return;
                }

                if (!document.querySelector(`[data-channel="${channel}"][data-geohash="${geohash}"]`)) {
                    const item = document.createElement('div');
                    item.className = 'channel-item list-item';
                    item.dataset.channel = channel;
                    item.dataset.geohash = geohash;

                    const displayName = geohash ? `#${geohash}` : `#${channel}`;
                    const badge = geohash ? '<span class="geohash-badge">GEO</span>' : '<span class="std-badge">EPH</span>';

                    // Get location information for geohash channels
                    let locationHint = '';
                    if (geohash) {
                        const location = this.getGeohashLocation(geohash);
                        if (location) {
                            locationHint = ` title="${location}"`;
                        }
                    }

                    const isPinned = this.pinnedChannels.has(key);
                    if (isPinned) {
                        item.classList.add('pinned');
                    }

                    // Don't show pin button for #bar
                    const isBar = channel === 'bar' && !geohash;
                    const pinButton = isBar ? '' : `
            <span class="pin-btn ${isPinned ? 'pinned' : ''}" data-channel="${channel}" data-geohash="${geohash}">
                <svg viewBox="0 0 24 24">
                    <path d="M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z"/>
                </svg>
            </span>
        `;

                    item.innerHTML = `
            <span class="channel-name"${locationHint}>${displayName}</span>
            <div class="channel-badges">
                ${pinButton}
                ${badge}
                <span class="unread-badge" style="display:none">0</span>
            </div>
        `;

                    // Add pin button handler using event listener instead of inline onclick
                    if (!isBar) {
                        const pinBtn = item.querySelector('.pin-btn');
                        if (pinBtn) {
                            pinBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                e.preventDefault();
                                this.togglePin(channel, geohash);
                            });
                        }
                    }

                    // Insert before the view more button if it exists
                    const viewMoreBtn = list.querySelector('.view-more-btn');
                    if (viewMoreBtn) {
                        list.insertBefore(item, viewMoreBtn);
                    } else {
                        list.appendChild(item);
                    }

                    this.channels.set(key, { channel, geohash });
                    this.updateChannelPins();

                    // Check if we need to add/update view more button
                    this.updateViewMoreButton('channelList');
                }
            }

            updateViewMoreButton(listId) {
                const list = document.getElementById(listId);
                if (!list) return;

                // Don't manage view more button if search is active
                const searchInput = list.parentElement?.querySelector('.search-input.active');
                if (searchInput && searchInput.value.trim().length > 0) {
                    return;
                }

                const items = list.querySelectorAll('.list-item:not(.search-hidden)');
                let existingBtn = list.querySelector('.view-more-btn');

                // Get current expansion state
                const isExpanded = this.listExpansionStates.get(listId) || false;

                if (items.length > 20) {
                    // We need a button
                    if (!existingBtn) {
                        const btn = document.createElement('div');
                        btn.className = 'view-more-btn';
                        btn.onclick = () => this.toggleListExpansion(listId);
                        list.appendChild(btn);
                        existingBtn = btn;
                    }

                    // Update button text based on state
                    if (isExpanded) {
                        existingBtn.textContent = 'Show less';
                        list.classList.remove('list-collapsed');
                        list.classList.add('list-expanded');
                    } else {
                        existingBtn.textContent = `View ${items.length - 20} more...`;
                        list.classList.add('list-collapsed');
                        list.classList.remove('list-expanded');
                    }

                    // Make sure button is visible
                    existingBtn.style.display = 'block';
                } else {
                    // Don't need a button - remove if exists
                    if (existingBtn) {
                        existingBtn.remove();
                    }
                    list.classList.remove('list-collapsed', 'list-expanded');
                    // Clear expansion state since button is gone
                    this.listExpansionStates.delete(listId);
                }
            }

            toggleListExpansion(listId) {
                const list = document.getElementById(listId);
                if (!list) return;

                let btn = list.querySelector('.view-more-btn');
                const items = list.querySelectorAll('.list-item');

                // Toggle the state
                const currentState = this.listExpansionStates.get(listId) || false;
                const newState = !currentState;
                this.listExpansionStates.set(listId, newState);

                if (newState) {
                    // Expanding
                    list.classList.remove('list-collapsed');
                    list.classList.add('list-expanded');

                    // Move button to the end of the list
                    if (btn) {
                        btn.remove();
                        btn = document.createElement('div');
                        btn.className = 'view-more-btn';
                        btn.textContent = 'Show less';
                        btn.onclick = () => this.toggleListExpansion(listId);
                        list.appendChild(btn);
                    }
                } else {
                    // Collapsing
                    list.classList.add('list-collapsed');
                    list.classList.remove('list-expanded');

                    // Move button back to after the 20th item
                    if (btn) {
                        btn.remove();
                        btn = document.createElement('div');
                        btn.className = 'view-more-btn';
                        btn.textContent = `View ${items.length - 20} more...`;
                        btn.onclick = () => this.toggleListExpansion(listId);

                        // Insert after the 20th visible item
                        if (items.length > 20 && items[19]) {
                            items[19].insertAdjacentElement('afterend', btn);
                        } else {
                            list.appendChild(btn);
                        }
                    }
                }
            }

            removeChannel(channel, geohash = '') {
                const key = geohash || channel;

                // Don't allow removing #bar (default channel)
                if (channel === 'bar' && !geohash) {
                    this.displaySystemMessage('Cannot remove the default #bar channel');
                    return;
                }

                // Remove from channels map
                this.channels.delete(key);

                // Remove from user-joined set
                this.userJoinedChannels.delete(key);

                // Remove from DOM
                const selector = geohash ?
                    `[data-geohash="${geohash}"]` :
                    `[data-channel="${channel}"][data-geohash=""]`;
                const element = document.querySelector(selector);
                if (element) {
                    element.remove();
                }

                // If we're currently in this channel, switch to #bar
                if ((this.currentChannel === channel && this.currentGeohash === geohash) ||
                    (geohash && this.currentGeohash === geohash)) {
                    this.switchChannel('bar', '');
                }

                // Save the updated channel list
                this.saveUserChannels();

                this.displaySystemMessage(`Left channel ${geohash ? '#' + geohash : '#' + channel}`);
            }

            // Add left-click context menu for channel items
            setupChannelContextMenu() {
                document.addEventListener('contextmenu', (e) => {
                    const channelItem = e.target.closest('.channel-item');
                    if (channelItem) {
                        e.preventDefault();
                        const channel = channelItem.dataset.channel;
                        const geohash = channelItem.dataset.geohash;

                        // Don't allow removing #bar
                        if (channel === 'bar' && !geohash) {
                            return;
                        }

                        // Create a simple context menu for leaving channel
                        const menu = document.createElement('div');
                        menu.className = 'context-menu active';
                        menu.style.left = e.pageX + 'px';
                        menu.style.top = e.pageY + 'px';
                        menu.innerHTML = `
                <div class="context-menu-item" onclick="nym.removeChannel('${channel}', '${geohash}'); this.parentElement.remove();">
                    Leave Channel
                </div>
            `;

                        // Remove any existing channel context menu
                        document.querySelectorAll('.channel-context-menu').forEach(m => m.remove());
                        menu.classList.add('channel-context-menu');
                        document.body.appendChild(menu);

                        // Close on click outside
                        setTimeout(() => {
                            document.addEventListener('click', () => menu.remove(), { once: true });
                        }, 100);
                    }
                });
            }

            saveUserJoinedChannels() {
                const existing = this.loadUserJoinedChannels();
                const combined = new Set([...existing, ...this.userJoinedChannels]);
                localStorage.setItem('nym_user_joined_channels', JSON.stringify(Array.from(combined)));
            }

            loadUserJoinedChannels() {
                const saved = localStorage.getItem('nym_user_joined_channels');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (error) {
                        console.error('Failed to load user-joined channels:', error);
                        return [];
                    }
                }
                return [];
            }

            saveUserChannels() {
                const userChannels = [];
                this.channels.forEach((value, key) => {
                    const isCommunity = value.isCommunity;
                    const isOwnedCommunity = isCommunity && this.ownedCommunities.has(key);
                    const isModeratedCommunity = isCommunity && this.moderatedCommunities.has(key);
                    const isMemberCommunity = isCommunity && this.communityMembers.has(key) &&
                        this.communityMembers.get(key).has(this.pubkey);
                    if (this.userJoinedChannels.has(key) || isOwnedCommunity || isModeratedCommunity || isMemberCommunity) {
                        userChannels.push({
                            key: key,
                            channel: value.channel,
                            geohash: value.geohash,
                            isCommunity: value.isCommunity,
                            community: value.community
                        });
                    }
                });

                // Save the channels
                localStorage.setItem('nym_user_channels', JSON.stringify(userChannels));

                // Also save the joined channels set
                this.saveUserJoinedChannels();
            }

            loadUserChannels() {
                const saved = localStorage.getItem('nym_user_channels');
                const savedJoined = localStorage.getItem('nym_user_joined_channels');

                // First, load the joined channels set
                if (savedJoined) {
                    try {
                        const joinedChannels = JSON.parse(savedJoined);
                        joinedChannels.forEach(key => this.userJoinedChannels.add(key));
                    } catch (error) {
                        console.error('Failed to load joined channels set:', error);
                    }
                }

                // Then load the channel details
                if (saved) {
                    try {
                        const userChannels = JSON.parse(saved);

                        userChannels.forEach(({ key, channel, geohash, isCommunity, community }) => {
                            if (isCommunity) {
                                // For communities, only restore if owned/moderated/member
                                // Public communities will be re-discovered automatically
                                const isOwned = this.ownedCommunities.has(key);
                                const isModerated = this.moderatedCommunities.has(key);
                                const isMember = this.communityMembers.has(key) &&
                                    this.communityMembers.get(key).has(this.pubkey);

                                if (isOwned || isModerated || isMember) {
                                    // Will be added when community definition is received
                                    this.userJoinedChannels.add(key);
                                }
                            } else {
                                // Regular channels - add the channel to the list if not already present
                                if (!this.channels.has(key)) {
                                    this.addChannel(channel, geohash);
                                }
                                // Make sure it's marked as user-joined
                                this.userJoinedChannels.add(key);
                            }
                        });

                        // Sort channels after loading
                        this.sortChannelsByActivity();

                        const regularChannelCount = userChannels.filter(c => !c.isCommunity).length;
                        if (regularChannelCount > 0) {
                            this.displaySystemMessage(`Restored ${regularChannelCount} previously joined channels`);
                        }
                    } catch (error) {
                        console.error('Failed to load user channels:', error);
                    }
                }
            }

            clearUserChannels() {
                localStorage.removeItem('nym_user_channels');
            }

            addChannelToList(channel, geohash) {
                // For geohash channels, ALWAYS use the geohash as the key
                const key = geohash ? geohash : channel;

                // Check if this channel was previously user-joined
                const wasUserJoined = this.userJoinedChannels.has(key);

                // Only add if not already in channels map
                if (geohash) {
                    // This is a geohash channel
                    if (!this.channels.has(geohash)) {
                        this.addChannel(geohash, geohash);
                        if (wasUserJoined) {
                            this.userJoinedChannels.add(geohash);
                        }
                        this.addGeohashChannelToGlobe(geohash);
                    }
                } else {
                    // This is a standard channel
                    if (!this.channels.has(channel)) {
                        this.addChannel(channel, '');
                        if (wasUserJoined) {
                            this.userJoinedChannels.add(channel);
                        }
                    }
                }
            }

            updateUnreadCount(channel) {
                const count = (this.unreadCounts.get(channel) || 0) + 1;
                this.unreadCounts.set(channel, count);

                // Handle PM unread counts using conversation key
                if (channel.startsWith('pm-')) {
                    // Extract the other user's pubkey from conversation key
                    const keys = channel.substring(3).split('-');
                    const otherPubkey = keys.find(k => k !== this.pubkey);
                    if (otherPubkey) {
                        const badge = document.querySelector(`[data-pubkey="${otherPubkey}"] .unread-badge`);
                        if (badge) {
                            badge.textContent = count > 99 ? '99+' : count;
                            badge.style.display = count > 0 ? 'block' : 'none';
                        }
                    }
                } else {
                    // Regular channel unread counts
                    let selector;
                    if (channel.startsWith('#')) {
                        // Geohash channel
                        selector = `[data-geohash="${channel.substring(1)}"]`;
                    } else {
                        // Check if it's a community channel by ID
                        const communityElement = document.querySelector(`[data-community="${channel}"]`);
                        if (communityElement) {
                            // It's a community channel
                            selector = `[data-community="${channel}"]`;
                        } else {
                            // Standard channel
                            selector = `[data-channel="${channel}"][data-geohash=""]`;
                        }
                    }

                    const badge = document.querySelector(`${selector} .unread-badge`);
                    if (badge) {
                        badge.textContent = count > 99 ? '99+' : count;
                        badge.style.display = count > 0 ? 'block' : 'none';
                    }
                }

                // Re-sort channels by activity
                this.sortChannelsByActivity();
            }

            sortChannelsByActivity() {
                const channelList = document.getElementById('channelList');
                const channels = Array.from(channelList.querySelectorAll('.channel-item'));

                // Save view more button if it exists
                const viewMoreBtn = channelList.querySelector('.view-more-btn');

                // Store current scroll position
                const scrollTop = channelList.scrollTop;

                channels.sort((a, b) => {
                    // #bar is always first
                    const aIsBar = a.dataset.channel === 'bar' && !a.dataset.geohash && !a.dataset.isCommunity;
                    const bIsBar = b.dataset.channel === 'bar' && !b.dataset.geohash && !b.dataset.isCommunity;

                    if (aIsBar) return -1;
                    if (bIsBar) return 1;

                    // Check if either is the NYM community (special pin that can't be unpinned)
                    const aIsNYM = a.dataset.community &&
                        this.communityChannels.get(a.dataset.community)?.name?.toLowerCase() === 'nym' &&
                        this.communityChannels.get(a.dataset.community)?.admin === this.verifiedDeveloper.pubkey;
                    const bIsNYM = b.dataset.community &&
                        this.communityChannels.get(b.dataset.community)?.name?.toLowerCase() === 'nym' &&
                        this.communityChannels.get(b.dataset.community)?.admin === this.verifiedDeveloper.pubkey;

                    // NYM community comes right after #bar
                    if (aIsNYM && !bIsBar) return -1;
                    if (bIsNYM && !aIsBar) return 1;

                    // Active channel is third
                    const aIsActive = a.classList.contains('active');
                    const bIsActive = b.classList.contains('active');

                    if (aIsActive && !bIsActive) return -1;
                    if (!aIsActive && bIsActive) return 1;

                    // Then sort by pinned status
                    const aPinned = a.classList.contains('pinned');
                    const bPinned = b.classList.contains('pinned');

                    if (aPinned && !bPinned) return -1;
                    if (!aPinned && bPinned) return 1;

                    // Check if these are geohash channels
                    const aIsGeo = !!a.dataset.geohash && a.dataset.geohash !== '';
                    const bIsGeo = !!b.dataset.geohash && b.dataset.geohash !== '';

                    // PRIORITY: If proximity sorting is enabled, sort ALL geohash channels by distance first
                    if (this.settings.sortByProximity && this.userLocation) {
                        // If both are geohash, sort by distance
                        if (aIsGeo && bIsGeo) {
                            try {
                                const coordsA = this.decodeGeohash(a.dataset.geohash);
                                const coordsB = this.decodeGeohash(b.dataset.geohash);

                                const distA = this.calculateDistance(
                                    this.userLocation.lat, this.userLocation.lng,
                                    coordsA.lat, coordsA.lng
                                );
                                const distB = this.calculateDistance(
                                    this.userLocation.lat, this.userLocation.lng,
                                    coordsB.lat, coordsB.lng
                                );

                                // Return distance comparison (don't fall through to unread count)
                                return distA - distB;
                            } catch (e) {
                                console.error('Error calculating distance:', e);
                                // Fall through to unread count if error
                            }
                        }

                        // If only one is geo, put geo channels first when proximity sorting is on
                        if (aIsGeo && !bIsGeo) return -1;
                        if (!aIsGeo && bIsGeo) return 1;
                    }

                    // Default: sort by unread count for non-geo or when proximity is off
                    const aChannel = a.dataset.community || (a.dataset.geohash ? `#${a.dataset.geohash}` : a.dataset.channel);
                    const bChannel = b.dataset.community || (b.dataset.geohash ? `#${b.dataset.geohash}` : b.dataset.channel);

                    const aUnread = this.unreadCounts.get(aChannel) || 0;
                    const bUnread = this.unreadCounts.get(bChannel) || 0;

                    if (aUnread === bUnread) return 0;
                    return bUnread - aUnread;
                });

                // Clear and re-append
                channelList.innerHTML = '';
                channels.forEach(channel => channelList.appendChild(channel));

                // Re-add view more button
                this.updateViewMoreButton('channelList');

                // Restore scroll position
                channelList.scrollTop = scrollTop;
            }

            clearUnreadCount(channel) {
                const storageKey = channel.startsWith('#') && !this.isValidGeohash(channel.substring(1))
                    ? channel.substring(1)
                    : channel;

                this.unreadCounts.set(storageKey, 0);

                // Handle PM unread counts using conversation key
                if (storageKey.startsWith('pm-')) {
                    // Extract the other user's pubkey from conversation key
                    const keys = storageKey.substring(3).split('-');
                    const otherPubkey = keys.find(k => k !== this.pubkey);
                    if (otherPubkey) {
                        const badge = document.querySelector(`[data-pubkey="${otherPubkey}"] .unread-badge`);
                        if (badge) {
                            badge.style.display = 'none';
                        }
                    }
                } else {
                    // Regular channel unread counts
                    let selector;
                    if (channel.startsWith('#')) {
                        const channelName = channel.substring(1);
                        if (this.isValidGeohash(channelName)) {
                            // It's a geohash
                            selector = `[data-geohash="${channelName}"]`;
                        } else {
                            // It's a standard channel with # prefix in display
                            selector = `[data-channel="${channelName}"][data-geohash=""]`;
                        }
                    } else {
                        // Check if it's a community channel
                        const communityElement = document.querySelector(`[data-community="${channel}"]`);
                        if (communityElement) {
                            selector = `[data-community="${channel}"]`;
                        } else {
                            // Standard channel without # prefix
                            selector = `[data-channel="${channel}"][data-geohash=""]`;
                        }
                    }

                    const badge = document.querySelector(`${selector} .unread-badge`);
                    if (badge) {
                        badge.style.display = 'none';
                    }
                }
            }

            navigateHistory(direction) {
                const input = document.getElementById('messageInput');

                if (direction === -1 && this.historyIndex > 0) {
                    this.historyIndex--;
                    input.value = this.commandHistory[this.historyIndex];
                } else if (direction === 1 && this.historyIndex < this.commandHistory.length - 1) {
                    this.historyIndex++;
                    input.value = this.commandHistory[this.historyIndex];
                } else if (direction === 1 && this.historyIndex === this.commandHistory.length - 1) {
                    this.historyIndex = this.commandHistory.length;
                    input.value = '';
                }

                this.autoResizeTextarea(input);
            }

            autoResizeTextarea(textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
            }

            updateConnectionStatus(status) {
                const statusEl = document.getElementById('connectionStatus');
                const dot = document.getElementById('statusDot');

                // If status is a custom message, show it
                if (status && typeof status === 'string') {
                    statusEl.textContent = status;

                    // Update dot color based on status text
                    if (status.includes('Connected') || status.includes('relays')) {
                        dot.style.background = 'var(--primary)';
                    } else if (status.includes('Connecting') || status.includes('Discovering')) {
                        dot.style.background = 'var(--warning)';
                    } else if (status.includes('Failed') || status.includes('Disconnected')) {
                        dot.style.background = 'var(--danger)';
                    }
                } else {
                    // Check actual WebSocket connection states, not just pool size
                    let actuallyConnected = 0;

                    this.relayPool.forEach((relay, url) => {
                        if (relay.ws && relay.ws.readyState === WebSocket.OPEN) {
                            actuallyConnected++;
                        } else {
                            // Clean up dead connections from pool
                            this.relayPool.delete(url);
                            this.relayKinds.delete(url);
                        }
                    });

                    if (actuallyConnected > 0) {
                        statusEl.textContent = `Connected (${actuallyConnected} relays)`;
                        dot.style.background = 'var(--primary)';
                        this.connected = true;
                    } else {
                        statusEl.textContent = 'Disconnected';
                        dot.style.background = 'var(--danger)';
                        this.connected = false;
                    }
                }
            }

            setupEmojiPicker() {
                const emojis = this.recentEmojis.length > 0 ? this.recentEmojis :
                    ['😊', '😂', '🤣', '❤️', '👍', '🔥', '✨', '🎉', '💯', '🤔', '😎', '🚀',
                        '💻', '🌟', '⚡', '🎯', '💡', '🤖', '👻', '🎭', '🌈', '🍕', '☕', '🎮'];
                const picker = document.getElementById('emojiPicker');

                picker.innerHTML = '';
                emojis.forEach(emoji => {
                    const btn = document.createElement('button');
                    btn.className = 'emoji-btn';
                    btn.textContent = emoji;
                    btn.onclick = () => this.insertEmoji(emoji);
                    picker.appendChild(btn);
                });
            }

            insertEmoji(emoji) {
                const input = document.getElementById('messageInput');
                const start = input.selectionStart;
                const end = input.selectionEnd;
                const text = input.value;

                input.value = text.substring(0, start) + emoji + text.substring(end);
                input.selectionStart = input.selectionEnd = start + emoji.length;
                input.focus();

                this.addToRecentEmojis(emoji);
            }

            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('mobileOverlay');
                const isOpen = sidebar.classList.contains('open');

                if (isOpen) {
                    sidebar.classList.remove('open');
                    overlay.classList.remove('active');
                } else {
                    sidebar.classList.add('open');
                    overlay.classList.add('active');
                }
            }

            showNotification(title, body, channelInfo = null) {
                const baseTitle = this.parseNymFromDisplay(title);

                // If this is a PM notification (we have a pubkey), append plain suffix for readability
                let titleToShow = baseTitle;
                if (channelInfo && channelInfo.pubkey) {
                    const suffix = this.getPubkeySuffix(channelInfo.pubkey);
                    titleToShow = `${baseTitle}#${suffix}`;
                }

                // Sound
                if (this.settings.sound !== 'none') {
                    this.playSound(this.settings.sound);
                }

                // Browser notification
                if (typeof Notification !== 'undefined' && Notification.permission === 'granted') {
                    try {
                        const notification = new Notification(titleToShow, {
                            body: body,
                            icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23000"/><text x="50" y="55" font-size="40" fill="%230ff" text-anchor="middle" font-family="monospace">NYM</text></svg>',
                            tag: channelInfo ? (channelInfo.id || 'nym-notification') : 'nym-notification',
                            requireInteraction: false,
                            data: { channelInfo: channelInfo }
                        });

                        if (channelInfo) {
                            notification.onclick = (event) => {
                                event.preventDefault();
                                window.focus();

                                if (channelInfo.type === 'pm') {
                                    this.openUserPM(baseTitle, channelInfo.pubkey);
                                } else if (channelInfo.type === 'community') {
                                    this.switchToCommunity(channelInfo.communityId);
                                } else if (channelInfo.type === 'geohash') {
                                    this.switchChannel(channelInfo.channel, channelInfo.geohash);
                                } else {
                                    this.switchChannel(channelInfo.channel, '');
                                }

                                notification.close();
                            };
                        }
                    } catch (error) {
                        console.error('Failed to create browser notification:', error);
                    }
                }

                // In-app notification (fallback)
                const notifEl = document.createElement('div');
                notifEl.className = 'notification';
                notifEl.innerHTML = `
        <div class="notification-title">${this.escapeHtml(titleToShow)}</div>
        <div class="notification-body">${this.escapeHtml(body)}</div>
        <div class="notification-time">${new Date().toLocaleTimeString()}</div>
    `;

                if (channelInfo) {
                    notifEl.style.cursor = 'pointer';
                    notifEl.onclick = () => {
                        if (channelInfo.type === 'pm') {
                            this.openUserPM(baseTitle, channelInfo.pubkey);
                        } else if (channelInfo.type === 'community') {
                            this.switchToCommunity(channelInfo.communityId);
                        } else if (channelInfo.type === 'geohash') {
                            this.switchChannel(channelInfo.channel, channelInfo.geohash);
                        } else {
                            this.switchChannel(channelInfo.channel, '');
                        }
                        notifEl.remove();
                    };
                }

                document.body.appendChild(notifEl);
                setTimeout(() => {
                    notifEl.style.animation = 'slideIn 0.3s reverse';
                    setTimeout(() => notifEl.remove(), 300);
                }, 3000);
            }

            playSound(type) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                switch (type) {
                    case 'beep':
                        oscillator.frequency.value = 800;
                        gainNode.gain.value = 0.1;
                        break;
                    case 'icq':
                        oscillator.frequency.value = 600;
                        gainNode.gain.value = 0.15;
                        break;
                    case 'msn':
                        oscillator.frequency.value = 1000;
                        gainNode.gain.value = 0.1;
                        break;
                }

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            }

            applyTheme(theme) {
                const root = document.documentElement;
                document.body.classList.remove('theme-ghost', 'theme-bitchat');

                if (theme === 'ghost') {
                    document.body.classList.add('theme-ghost');
                } else if (theme === 'bitchat') {
                    document.body.classList.add('theme-bitchat');
                }

                const themes = {
                    matrix: {
                        primary: '#00ff00',
                        secondary: '#00ffff',
                        text: '#00ff00',
                        textDim: '#008800',
                        textBright: '#00ffaa',
                        lightning: '#f7931a'
                    },
                    amber: {
                        primary: '#ffb000',
                        secondary: '#ffd700',
                        text: '#ffb000',
                        textDim: '#cc8800',
                        textBright: '#ffcc00',
                        lightning: '#ffa500'
                    },
                    cyber: {
                        primary: '#ff00ff',
                        secondary: '#00ffff',
                        text: '#ff00ff',
                        textDim: '#aa00aa',
                        textBright: '#ff66ff',
                        lightning: '#ffaa00'
                    },
                    hacker: {
                        primary: '#00ffff',
                        secondary: '#00ff00',
                        text: '#00ffff',
                        textDim: '#008888',
                        textBright: '#66ffff',
                        lightning: '#00ff88'
                    },
                    ghost: {
                        primary: '#ffffff',
                        secondary: '#cccccc',
                        text: '#ffffff',
                        textDim: '#666666',
                        textBright: '#ffffff',
                        lightning: '#dddddd'
                    },
                    bitchat: {
                        primary: '#00ff00',
                        secondary: '#00ffff',
                        text: '#00ff00',
                        textDim: '#008800',
                        textBright: '#00ffaa',
                        lightning: '#f7931a'
                    }
                };

                if (theme === 'ghost') {
                    document.body.classList.add('theme-ghost');
                }

                const selectedTheme = themes[theme];
                if (selectedTheme) {
                    Object.entries(selectedTheme).forEach(([key, value]) => {
                        const cssVar = `--${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
                        root.style.setProperty(cssVar, value);
                    });
                }
                this.refreshMessages();
            }

            refreshMessages() {
                // Clear user colors cache when theme changes
                this.userColors.clear();

                // Re-display all messages to apply new colors
                const container = document.getElementById('messagesContainer');
                const messages = container.querySelectorAll('.message');

                messages.forEach(msg => {
                    const pubkey = msg.dataset.pubkey;
                    const authorElement = msg.querySelector('.message-author');
                    if (authorElement) {
                        // Remove existing bitchat classes
                        const classesToRemove = [];
                        authorElement.classList.forEach(cls => {
                            if (cls.startsWith('bitchat-user-') || cls === 'bitchat-theme') {
                                classesToRemove.push(cls);
                            }
                        });

                        classesToRemove.forEach(cls => authorElement.classList.remove(cls));

                        // Add new color class
                        const colorClass = this.getUserColorClass(pubkey);
                        if (colorClass) {
                            authorElement.classList.add(colorClass);
                        }
                    }
                });

                // Also refresh user list
                this.updateUserList();
            }

            refreshMessageTimestamps() {
                // Update all visible timestamps to use new format
                document.querySelectorAll('.message-time').forEach(timeEl => {
                    const timestamp = parseInt(timeEl.closest('.message').dataset.timestamp);
                    if (timestamp) {
                        const date = new Date(timestamp);
                        const newTime = date.toLocaleTimeString('en-US', {
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: this.settings.timeFormat === '12hr'
                        });
                        timeEl.textContent = newTime;

                        // Update class for spacing
                        if (this.settings.timeFormat === '12hr') {
                            timeEl.classList.add('time-12hr');
                        } else {
                            timeEl.classList.remove('time-12hr');
                        }
                    }
                });
            }

            cleanupBitchatStyles() {
                // Remove all dynamically created bitchat styles
                document.querySelectorAll('style[id^="bitchat-user-"]').forEach(style => {
                    style.remove();
                });
            }

            cleanupBannedMessages(communityId, bannedPubkey) {
                // Mark messages from banned user as blocked in stored messages
                if (this.messages.has(communityId)) {
                    this.messages.get(communityId).forEach(msg => {
                        if (msg.pubkey === bannedPubkey) {
                            msg.blocked = true;
                        }
                    });
                }

                // Remove from DOM
                document.querySelectorAll(`.message[data-pubkey="${bannedPubkey}"]`).forEach(msg => {
                    msg.remove();
                });
            }

            restoreUnbannedMessages(communityId, unbannedPubkey) {
                // Unmark messages from unbanned user in stored messages
                if (this.messages.has(communityId)) {
                    this.messages.get(communityId).forEach(msg => {
                        if (msg.pubkey === unbannedPubkey) {
                            delete msg.blocked;
                        }
                    });
                }

                // Reload community messages if currently viewing this community
                if (this.currentCommunity === communityId) {
                    this.loadCommunityMessages(communityId);
                }
            }

            loadSettings() {
                return {
                    theme: localStorage.getItem('nym_theme') || 'bitchat',
                    sound: localStorage.getItem('nym_sound') || 'beep',
                    autoscroll: localStorage.getItem('nym_autoscroll') !== 'false',
                    showTimestamps: localStorage.getItem('nym_timestamps') !== 'false',
                    sortByProximity: localStorage.getItem('nym_sort_proximity') === 'true',
                    timeFormat: localStorage.getItem('nym_time_format') || '24hr',
                    dmForwardSecrecyEnabled: localStorage.getItem('nym_dm_fwdsec_enabled') === 'true',
                    dmTTLSeconds: parseInt(localStorage.getItem('nym_dm_ttl_seconds') || '86400', 10)
                };
            }

            loadImageBlurSettings() {
                const saved = localStorage.getItem(`nym_image_blur_${this.pubkey}`);
                if (saved !== null) {
                    return saved === 'true';
                }
                return true; // Default to blur
            }

            saveImageBlurSettings() {
                localStorage.setItem(`nym_image_blur_${this.pubkey}`, this.blurOthersImages.toString());

                // Sync to Nostr for persistent connections
                if (this.connectionMode !== 'ephemeral') {
                    this.saveSyncedSettings();
                }
            }

            toggleImageBlur() {
                this.blurOthersImages = !this.blurOthersImages;
                this.saveImageBlurSettings();

                // Update all existing images
                document.querySelectorAll('.message img').forEach(img => {
                    const messageEl = img.closest('.message');
                    if (messageEl && !messageEl.classList.contains('self')) {
                        if (this.blurOthersImages) {
                            img.classList.add('blurred');
                        } else {
                            img.classList.remove('blurred');
                        }
                    }
                });
            }

            saveSettings() {
                localStorage.setItem('nym_theme', this.settings.theme);
                localStorage.setItem('nym_sound', this.settings.sound);
                localStorage.setItem('nym_autoscroll', this.settings.autoscroll);
                localStorage.setItem('nym_timestamps', this.settings.showTimestamps);
                localStorage.setItem('nym_sort_proximity', this.settings.sortByProximity);
            }

            loadBlockedUsers() {
                const blocked = localStorage.getItem('nym_blocked');
                if (blocked) {
                    this.blockedUsers = new Set(JSON.parse(blocked));
                }
                this.updateBlockedList();
            }

            saveBlockedUsers() {
                localStorage.setItem('nym_blocked', JSON.stringify(Array.from(this.blockedUsers)));
            }

            updateBlockedList() {
                const list = document.getElementById('blockedList');
                if (this.blockedUsers.size === 0) {
                    list.innerHTML = '<div style="color: var(--text-dim); font-size: 12px;">No blocked users</div>';
                } else {
                    // Show loading state
                    list.innerHTML = '<div style="color: var(--text-dim); font-size: 12px;">Loading...</div>';

                    // Load async without blocking
                    this.loadBlockedUsersAsync(list);
                }
            }

            async loadBlockedUsersAsync(listElement) {
                // Initialize nymCache if it doesn't exist
                if (!this.nymCache) {
                    this.nymCache = {};
                }

                // Fetch metadata for blocked users who aren't in cache
                const blockedArray = Array.from(this.blockedUsers);
                const uncachedPubkeys = blockedArray.filter(pk => !this.nymCache[pk]);

                if (uncachedPubkeys.length > 0) {
                    await this.fetchMetadataForBlockedUsers(uncachedPubkeys);
                }

                // Now render with proper nyms
                listElement.innerHTML = blockedArray.map(pubkey => {
                    const nym = this.getNymFromPubkey(pubkey);
                    return `
            <div class="blocked-item">
                <span>${nym}</span>
                <button class="unblock-btn" onclick="nym.unblockByPubkey('${pubkey}')">Unblock</button>
            </div>
        `;
                }).join('');
            }

            // Fetch metadata for blocked users
            async fetchMetadataForBlockedUsers(pubkeys) {
                if (pubkeys.length === 0) return;

                return new Promise((resolve) => {
                    const subId = "blocked-meta-" + Math.random().toString(36).substring(7);
                    let receivedCount = 0;
                    let messageHandlers = [];

                    const cleanup = () => {
                        messageHandlers.forEach(handler => {
                            const index = this.relayMessageHandlers?.indexOf(handler);
                            if (index > -1) {
                                this.relayMessageHandlers.splice(index, 1);
                            }
                        });
                        this.sendToRelay(["CLOSE", subId]);
                    };

                    const timeout = setTimeout(() => {
                        cleanup();
                        resolve();
                    }, 3000);

                    const handleMessage = (msg, relayUrl) => {
                        if (!Array.isArray(msg)) return false;

                        const [type, ...data] = msg;

                        if (type === 'EVENT' && data[0] === subId) {
                            const event = data[1];
                            if (event && event.kind === 0) {
                                // Temporarily process metadata ONLY for caching the nym
                                try {
                                    const metadata = JSON.parse(event.content);
                                    const name = metadata.name || metadata.display_name || metadata.displayName;
                                    if (name) {
                                        // Store in nym cache (without adding to profile cache)
                                        this.nymCache[event.pubkey] = name;
                                    }
                                    receivedCount++;

                                    // If we got all metadata, resolve early
                                    if (receivedCount >= pubkeys.length) {
                                        clearTimeout(timeout);
                                        cleanup();
                                        resolve();
                                    }
                                } catch (e) {
                                    console.error('Failed to parse blocked user metadata:', e);
                                }
                            }
                        } else if (type === 'EOSE' && data[0] === subId) {
                            clearTimeout(timeout);
                            cleanup();
                            resolve();
                        }

                        return false;
                    };

                    if (!this.relayMessageHandlers) {
                        this.relayMessageHandlers = [];
                    }
                    this.relayMessageHandlers.push(handleMessage);
                    messageHandlers.push(handleMessage);

                    // Request metadata for blocked users
                    const subscription = [
                        "REQ",
                        subId,
                        {
                            kinds: [0],
                            authors: pubkeys
                        }
                    ];

                    this.sendToRelay(subscription);
                });
            }

            escapeHtml(text) {
                const map = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                };
                return String(text).replace(/[&<>"]/g, m => map[m]);
            }

            isCurrentChannelCommunity() {
                return this.currentCommunity !== null;
            }

            getCurrentCommunityId() {
                return this.currentCommunity;
            }

            canModerate(communityId) {
                const isAdmin = this.ownedCommunities.has(communityId);
                const isMod = this.communityModerators.has(communityId) &&
                    this.communityModerators.get(communityId).has(this.pubkey);
                return isAdmin || isMod;
            }

            async findUserPubkey(input) {
                const hashIndex = input.indexOf('#');
                let searchNym = input;
                let searchSuffix = null;

                if (hashIndex !== -1) {
                    searchNym = input.substring(0, hashIndex);
                    searchSuffix = input.substring(hashIndex + 1);
                }

                const matches = [];

                // First, search in active users
                this.users.forEach((user, pubkey) => {
                    const baseNym = user.nym.split('#')[0] || user.nym;
                    if (baseNym === searchNym || baseNym.toLowerCase() === searchNym.toLowerCase()) {
                        if (searchSuffix) {
                            if (pubkey.endsWith(searchSuffix)) {
                                matches.push({ nym: user.nym, pubkey: pubkey });
                            }
                        } else {
                            matches.push({ nym: user.nym, pubkey: pubkey });
                        }
                    }
                });

                // If no matches in active users, search in stored messages
                if (matches.length === 0) {
                    // Search through all stored messages
                    this.messages.forEach((channelMessages, channel) => {
                        channelMessages.forEach(msg => {
                            if (msg.pubkey && msg.author) {
                                const baseNym = msg.author.split('#')[0] || msg.author;
                                if (baseNym === searchNym || baseNym.toLowerCase() === searchNym.toLowerCase()) {
                                    if (searchSuffix) {
                                        if (msg.pubkey.endsWith(searchSuffix)) {
                                            // Check if not already in matches
                                            if (!matches.find(m => m.pubkey === msg.pubkey)) {
                                                matches.push({ nym: msg.author, pubkey: msg.pubkey });
                                            }
                                        }
                                    } else {
                                        // Check if not already in matches
                                        if (!matches.find(m => m.pubkey === msg.pubkey)) {
                                            matches.push({ nym: msg.author, pubkey: msg.pubkey });
                                        }
                                    }
                                }
                            }
                        });
                    });

                    // Also search in PM messages
                    this.pmMessages.forEach((conversationMessages, conversationKey) => {
                        conversationMessages.forEach(msg => {
                            if (msg.pubkey && msg.author) {
                                const baseNym = msg.author.split('#')[0] || msg.author;
                                if (baseNym === searchNym || baseNym.toLowerCase() === searchNym.toLowerCase()) {
                                    if (searchSuffix) {
                                        if (msg.pubkey.endsWith(searchSuffix)) {
                                            // Check if not already in matches
                                            if (!matches.find(m => m.pubkey === msg.pubkey)) {
                                                matches.push({ nym: msg.author, pubkey: msg.pubkey });
                                            }
                                        }
                                    } else {
                                        // Check if not already in matches
                                        if (!matches.find(m => m.pubkey === msg.pubkey)) {
                                            matches.push({ nym: msg.author, pubkey: msg.pubkey });
                                        }
                                    }
                                }
                            }
                        });
                    });

                    // Also search in community members if in a community
                    if (this.currentCommunity && this.communityMembers.has(this.currentCommunity)) {
                        this.communityMembers.get(this.currentCommunity).forEach(pubkey => {
                            // Try to get nym from cache
                            const cachedNym = this.getNymFromPubkey(pubkey);
                            if (cachedNym) {
                                const baseNym = cachedNym.split('#')[0] || cachedNym;
                                if (baseNym === searchNym || baseNym.toLowerCase() === searchNym.toLowerCase()) {
                                    if (searchSuffix) {
                                        if (pubkey.endsWith(searchSuffix)) {
                                            if (!matches.find(m => m.pubkey === pubkey)) {
                                                matches.push({ nym: cachedNym, pubkey: pubkey });
                                            }
                                        }
                                    } else {
                                        if (!matches.find(m => m.pubkey === pubkey)) {
                                            matches.push({ nym: cachedNym, pubkey: pubkey });
                                        }
                                    }
                                }
                            }
                        });
                    }
                }

                // If still no matches and we have a suffix, we can construct a pubkey
                // This is useful for moderators who might have the full nym#suffix
                if (matches.length === 0 && searchSuffix && searchSuffix.length === 4) {
                    // If we're in a community, search through all messages to find a pubkey ending with this suffix
                    if (this.currentCommunity) {
                        const communityMessages = this.messages.get(this.currentCommunity) || [];
                        communityMessages.forEach(msg => {
                            if (msg.pubkey && msg.pubkey.endsWith(searchSuffix)) {
                                const baseNym = msg.author.split('#')[0] || msg.author;
                                if (baseNym.toLowerCase() === searchNym.toLowerCase()) {
                                    if (!matches.find(m => m.pubkey === msg.pubkey)) {
                                        matches.push({ nym: msg.author, pubkey: msg.pubkey });
                                    }
                                }
                            }
                        });
                    }
                }

                if (matches.length === 0) {
                    this.displaySystemMessage(`User ${input} not found. Try using the full nym#xxxx format if you know their pubkey suffix.`);
                    return null;
                }

                if (matches.length > 1 && !searchSuffix) {
                    const matchList = matches.map(m =>
                        `${this.formatNymWithPubkey(m.nym, m.pubkey)}`
                    ).join(', ');
                    this.displaySystemMessage(`Multiple users found: ${matchList}`);
                    this.displaySystemMessage('Please specify using the #xxxx suffix');
                    return null;
                }

                return matches[0].pubkey;
            }

            async updateCommunityRole(communityId, targetPubkey, role) {
                const community = this.communityChannels.get(communityId);
                if (!community) return;

                // Get current moderators
                const mods = this.communityModerators.get(communityId) || new Set();

                // Update community definition with new moderator list
                const event = {
                    kind: 34550,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ['d', communityId],
                        ['name', community.name],
                        ['description', community.description || ''],
                        ['p', this.pubkey, '', 'admin'],
                    ],
                    content: community.description || '',
                    pubkey: this.pubkey
                };

                // Add all moderators
                if (role === 'moderator') {
                    mods.add(targetPubkey);
                } else if (role === 'remove') {
                    mods.delete(targetPubkey);
                }

                mods.forEach(modPubkey => {
                    event.tags.push(['p', modPubkey, '', 'moderator']);
                });

                // Add privacy tag
                if (community.isPrivate) {
                    event.tags.push(['private']);
                } else {
                    event.tags.push(['public']);
                }

                // Sign and send
                let signedEvent;
                if (window.nostr && !this.privkey) {
                    signedEvent = await window.nostr.signEvent(event);
                } else if (this.privkey) {
                    signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                }

                if (signedEvent) {
                    this.sendToRelay(["EVENT", signedEvent]);
                }
            }

            async updateCommunityDefinitionWithBans(communityId) {
                const community = this.communityChannels.get(communityId);
                if (!community) return;

                // Only admin can update community definition
                if (community.admin !== this.pubkey) {
                    console.log('Only admin can update community definition');
                    return;
                }

                // Get current moderators
                const mods = this.communityModerators.get(communityId) || new Set();

                // Get current banned users
                const banned = this.communityBans.get(communityId) || new Set();

                // Create updated community definition
                const event = {
                    kind: 34550,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ['d', communityId],
                        ['name', community.name],
                        ['description', community.description || ''],
                        ['image', community.imageUrl || ''],
                        ['p', this.pubkey, '', 'admin'],
                    ],
                    content: community.description || '',
                    pubkey: this.pubkey
                };

                // Add moderators
                mods.forEach(modPubkey => {
                    event.tags.push(['p', modPubkey, '', 'moderator']);
                });

                // Add banned users - THIS IS KEY FOR PERSISTENCE
                banned.forEach(bannedPubkey => {
                    event.tags.push(['p', bannedPubkey, '', 'banned']);
                });

                // Add privacy tag
                if (community.isPrivate) {
                    event.tags.push(['private']);
                } else {
                    event.tags.push(['public']);
                }

                // Sign and send
                let signedEvent;
                if (window.nostr && !this.privkey) {
                    signedEvent = await window.nostr.signEvent(event);
                } else if (this.privkey) {
                    signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                }

                if (signedEvent) {
                    this.sendToRelay(["EVENT", signedEvent]);
                    console.log('Updated community definition with ban list');
                }
            }

            async publishCommunityModeration(communityId, targetPubkey, action) {
                const community = this.communityChannels.get(communityId);
                if (!community) return;

                // Use NIP-56 reporting event (kind 1984) for moderation
                const event = {
                    kind: 1984, // NIP-56 report/moderation
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ['a', `34550:${community.admin}:${communityId}`], // Reference to community
                        ['p', targetPubkey], // Target user
                        ['action', action], // ban, unban, kick
                        ['reason', `${action} by moderator`]
                    ],
                    content: `User ${action} in community ${community.name}`,
                    pubkey: this.pubkey
                };

                let signedEvent;
                if (window.nostr && !this.privkey) {
                    signedEvent = await window.nostr.signEvent(event);
                } else if (this.privkey) {
                    signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                }

                if (signedEvent) {
                    this.sendToRelay(["EVENT", signedEvent]);
                    console.log(`Published ${action} event for user ${targetPubkey} in community ${communityId}`);
                }
            }

            showCommunitySettingsModal(communityId) {
                const community = this.communityChannels.get(communityId);
                if (!community) return;

                const modal = document.getElementById('communitySettingsModal');
                if (!modal) {
                    this.displaySystemMessage('Community settings UI not available');
                    return;
                }

                // Populate modal with community data
                document.getElementById('communityNameDisplay').textContent = community.name;
                document.getElementById('communityDescEdit').value = community.description || '';
                document.getElementById('communityPrivacyEdit').value = community.isPrivate ? 'private' : 'public';

                // Load dynamic content
                this.loadCommunitySettingsUI(communityId);

                modal.classList.add('active');
            }

            async loadCommunitySettingsUI(communityId) {
                const community = this.communityChannels.get(communityId);
                if (!community) return;

                // Load community image
                const imageEdit = document.getElementById('communityImageEdit');
                const imagePreview = document.getElementById('communityImagePreview');
                const imagePreviewImg = document.getElementById('communityImagePreviewImg');

                if (imageEdit) {
                    imageEdit.value = community.imageUrl || '';
                }

                if (community.imageUrl && imagePreviewImg && imagePreview) {
                    imagePreviewImg.src = community.imageUrl;
                    imagePreview.style.display = 'block';

                    imagePreviewImg.onerror = () => {
                        imagePreview.style.display = 'none';
                    };
                } else if (imagePreview) {
                    imagePreview.style.display = 'none';
                }

                // Add live preview on image URL change
                if (imageEdit) {
                    imageEdit.addEventListener('input', (e) => {
                        const url = e.target.value.trim();
                        if (url && imagePreviewImg && imagePreview) {
                            imagePreviewImg.src = url;
                            imagePreview.style.display = 'block';

                            imagePreviewImg.onerror = () => {
                                imagePreview.style.display = 'none';
                            };
                        } else if (imagePreview) {
                            imagePreview.style.display = 'none';
                        }
                    });
                }

                // Load blocked keywords for this community
                const keywordList = document.getElementById('communityKeywordList');
                if (keywordList) {
                    const communityKeywords = this.communityBlockedKeywords?.get(communityId) || new Set();

                    if (communityKeywords.size === 0) {
                        keywordList.innerHTML = '<div style="color: var(--text-dim); font-size: 12px;">No blocked keywords</div>';
                    } else {
                        keywordList.innerHTML = '';
                        communityKeywords.forEach(keyword => {
                            const item = document.createElement('div');
                            item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 2px 0;';
                            item.innerHTML = `
                    <span>${this.escapeHtml(keyword)}</span>
                    <button class="unblock-btn" onclick="nym.removeCommunityKeyword('${this.escapeHtml(keyword).replace(/'/g, "\\'")}')">Remove</button>
                `;
                            keywordList.appendChild(item);
                        });
                    }
                }

                // Load moderators list
                const mods = this.communityModerators.get(communityId) || new Set();
                const modsList = document.getElementById('communityModsList');

                if (mods.size === 0) {
                    modsList.innerHTML = '<div style="color: var(--text-dim); font-size: 12px;">No moderators assigned</div>';
                } else {
                    modsList.innerHTML = '';
                    mods.forEach(pubkey => {
                        const nym = this.getNymFromPubkey(pubkey);
                        const item = document.createElement('div');
                        item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 2px 0;';
                        item.innerHTML = `
                <span>${nym}</span>
                <button class="unblock-btn" onclick="nym.removeModFromSettings('${pubkey}')">Remove</button>
            `;
                        modsList.appendChild(item);
                    });
                }

                // Load banned users list
                const banned = this.communityBans.get(communityId) || new Set();
                const bansList = document.getElementById('communityBansList');

                if (banned.size === 0) {
                    bansList.innerHTML = '<div style="color: var(--text-dim); font-size: 12px;">No banned users</div>';
                } else {
                    bansList.innerHTML = '';
                    banned.forEach(pubkey => {
                        const nym = this.getNymFromPubkey(pubkey);
                        const item = document.createElement('div');
                        item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 2px 0;';
                        item.innerHTML = `
                <span>${nym}</span>
                <button class="unblock-btn" onclick="nym.unbanFromSettings('${pubkey}')">Unban</button>
            `;
                        bansList.appendChild(item);
                    });
                }

                // Update statistics with deduplication
                const members = this.communityMembers.get(communityId) || new Set();

                // Create a deduplicated set of all members (admin + mods + regular members)
                const allMembers = new Set();

                // Add admin (community owner)
                allMembers.add(community.admin);

                // Add all moderators
                mods.forEach(modPubkey => allMembers.add(modPubkey));

                // Add all regular members
                members.forEach(memberPubkey => allMembers.add(memberPubkey));

                // Now calculate stats without double-counting
                const totalMembers = allMembers.size;
                const totalMods = mods.size;
                const totalBanned = banned.size;

                document.getElementById('statMembers').textContent = totalMembers;
                document.getElementById('statMods').textContent = totalMods;
                document.getElementById('statBanned').textContent = totalBanned;
            }

            addCommunityKeyword() {
                const communityId = this.getCurrentCommunityId();
                if (!communityId) return;

                const input = document.getElementById('newCommunityKeywordInput');
                const keyword = input.value.trim().toLowerCase();

                if (keyword) {
                    if (!this.communityBlockedKeywords) {
                        this.communityBlockedKeywords = new Map();
                    }
                    if (!this.communityBlockedKeywords.has(communityId)) {
                        this.communityBlockedKeywords.set(communityId, new Set());
                    }

                    this.communityBlockedKeywords.get(communityId).add(keyword);
                    this.saveCommunityKeywords(communityId);
                    this.loadCommunitySettingsUI(communityId);
                    input.value = '';

                    // Hide messages containing this keyword in this community
                    if (this.currentCommunity === communityId) {
                        document.querySelectorAll('.message').forEach(msg => {
                            const content = msg.querySelector('.message-content');
                            if (content && content.textContent.toLowerCase().includes(keyword)) {
                                msg.classList.add('blocked');
                                msg.style.display = 'none';
                            }
                        });
                    }

                    this.displaySystemMessage(`Blocked keyword in community: "${keyword}"`);
                }
            }

            removeCommunityKeyword(keyword) {
                const communityId = this.getCurrentCommunityId();
                if (!communityId) return;

                if (this.communityBlockedKeywords?.has(communityId)) {
                    this.communityBlockedKeywords.get(communityId).delete(keyword);
                    this.saveCommunityKeywords(communityId);
                    this.loadCommunitySettingsUI(communityId);

                    // Re-check all messages in this community
                    if (this.currentCommunity === communityId) {
                        document.querySelectorAll('.message.blocked').forEach(msg => {
                            const content = msg.querySelector('.message-content');
                            if (content) {
                                const hasOtherBlockedKeyword = Array.from(
                                    this.communityBlockedKeywords.get(communityId) || []
                                ).some(kw => content.textContent.toLowerCase().includes(kw));

                                if (!hasOtherBlockedKeyword) {
                                    msg.classList.remove('blocked');
                                    msg.style.display = '';
                                }
                            }
                        });
                    }

                    this.displaySystemMessage(`Unblocked keyword in community: "${keyword}"`);
                }
            }

            saveCommunityKeywords(communityId) {
                if (!this.communityBlockedKeywords?.has(communityId)) return;

                const keywords = Array.from(this.communityBlockedKeywords.get(communityId));
                localStorage.setItem(`nym_community_keywords_${communityId}`, JSON.stringify(keywords));
            }

            loadCommunityKeywords(communityId) {
                const saved = localStorage.getItem(`nym_community_keywords_${communityId}`);
                if (saved) {
                    if (!this.communityBlockedKeywords) {
                        this.communityBlockedKeywords = new Map();
                    }
                    this.communityBlockedKeywords.set(communityId, new Set(JSON.parse(saved)));
                }
            }

            hasCommunityBlockedKeyword(text, communityId) {
                if (!this.communityBlockedKeywords?.has(communityId)) return false;

                const lowerText = text.toLowerCase();
                return Array.from(this.communityBlockedKeywords.get(communityId)).some(
                    keyword => lowerText.includes(keyword)
                );
            }

            async addModFromSettings() {
                const input = document.getElementById('addModInput').value.trim();
                if (!input) {
                    this.displaySystemMessage('Please enter a nym');
                    return;
                }

                const communityId = this.getCurrentCommunityId();
                if (!communityId) return;

                const community = this.communityChannels.get(communityId);
                if (!community) {
                    this.displaySystemMessage('Current community not found');
                    return;
                }

                // Only admin can add moderators
                if (!this.ownedCommunities.has(communityId)) {
                    this.displaySystemMessage('Only the community admin can add moderators');
                    return;
                }

                const targetPubkey = await this.findUserPubkey(input);
                if (!targetPubkey) {
                    // Clear input even on failure
                    document.getElementById('addModInput').value = '';
                    return;
                }

                const matchedNym = this.getNymFromPubkey(targetPubkey);

                if (targetPubkey === this.pubkey) {
                    this.displaySystemMessage("You're already the admin (and a moderator)");
                    document.getElementById('addModInput').value = '';
                    return;
                }

                // Check if already a moderator
                if (this.communityModerators.has(communityId) &&
                    this.communityModerators.get(communityId).has(targetPubkey)) {
                    this.displaySystemMessage(`${this.formatNymWithPubkey(matchedNym, targetPubkey)} is already a moderator`);
                    document.getElementById('addModInput').value = '';
                    return;
                }

                // Add as moderator
                if (!this.communityModerators.has(communityId)) {
                    this.communityModerators.set(communityId, new Set());
                }
                this.communityModerators.get(communityId).add(targetPubkey);

                // Update community definition
                await this.updateCommunityDefinitionWithBans(communityId);

                // Parse base nym from display format - this removes HTML tags
                const parsedNym = this.parseNymFromDisplay(matchedNym);
                // Get just the base nym without any suffix
                const baseNym = parsedNym.split('#')[0] || parsedNym;
                const suffix = this.getPubkeySuffix(targetPubkey);
                const fullNym = `${baseNym}#${suffix}`;

                const displayNym = this.formatNymWithPubkey(matchedNym, targetPubkey);
                this.displaySystemMessage(`Added ${displayNym} as a moderator`);

                // Announce in channel with full nym#suffix
                await this.publishCommunityMessage(`⭐ ${fullNym} is now a moderator of this community`, communityId);

                // Clear input and reload UI
                document.getElementById('addModInput').value = '';
                this.loadCommunitySettingsUI(communityId);
            }

            async removeModFromSettings(pubkey) {
                const communityId = this.getCurrentCommunityId();
                if (!communityId) return;

                const community = this.communityChannels.get(communityId);
                if (!community) {
                    this.displaySystemMessage('Current community not found');
                    return;
                }

                // Only admin can remove moderators
                if (!this.ownedCommunities.has(communityId)) {
                    this.displaySystemMessage('Only the community admin can remove moderators');
                    return;
                }

                const matchedNym = this.getNymFromPubkey(pubkey);

                if (pubkey === this.pubkey) {
                    this.displaySystemMessage("You can't remove yourself as admin");
                    return;
                }

                // Check if actually a moderator
                if (!this.communityModerators.has(communityId) ||
                    !this.communityModerators.get(communityId).has(pubkey)) {
                    this.displaySystemMessage(`${this.formatNymWithPubkey(matchedNym, pubkey)} is not a moderator`);
                    return;
                }

                // Remove from moderators
                this.communityModerators.get(communityId).delete(pubkey);

                // Update community definition
                await this.updateCommunityDefinitionWithBans(communityId);

                // Parse base nym from display format - this removes HTML tags
                const parsedNym = this.parseNymFromDisplay(matchedNym);
                // Get just the base nym without any suffix
                const baseNym = parsedNym.split('#')[0] || parsedNym;
                const suffix = this.getPubkeySuffix(pubkey);
                const fullNym = `${baseNym}#${suffix}`;

                const displayNym = this.formatNymWithPubkey(matchedNym, pubkey);
                this.displaySystemMessage(`Removed ${displayNym} as a moderator`);

                // Announce in channel with full nym#suffix
                await this.publishCommunityMessage(`📋 ${fullNym} is no longer a moderator of this community`, communityId);

                // Reload UI
                this.loadCommunitySettingsUI(communityId);
            }

            async unbanFromSettings(pubkey) {
                const communityId = this.getCurrentCommunityId();
                if (!communityId) return;

                const community = this.communityChannels.get(communityId);
                if (!community) return;

                // Check if user is admin or moderator
                const isAdmin = this.ownedCommunities.has(communityId);
                const isMod = this.communityModerators.has(communityId) &&
                    this.communityModerators.get(communityId).has(this.pubkey);

                if (!isAdmin && !isMod) {
                    this.displaySystemMessage('Only admins and moderators can unban users');
                    return;
                }

                // Get target nym for display
                const targetNym = this.getNymFromPubkey(pubkey);

                // Parse base nym from display format - this removes HTML tags
                const parsedNym = this.parseNymFromDisplay(targetNym);
                // Get just the base nym without any suffix
                const baseNym = parsedNym.split('#')[0] || parsedNym;
                const suffix = this.getPubkeySuffix(pubkey);
                const fullNym = `${baseNym}#${suffix}`;

                // Check if actually banned
                if (!this.communityBans.has(communityId) ||
                    !this.communityBans.get(communityId).has(pubkey)) {
                    this.displaySystemMessage(`${this.formatNymWithPubkey(targetNym, pubkey)} is not banned`);
                    return;
                }

                // Remove from bans
                this.communityBans.get(communityId).delete(pubkey);

                // Update community definition
                await this.updateCommunityDefinitionWithBans(communityId);

                // Re-subscribe to the unbanned user's messages for this community
                if (this.connected && this.relay) {
                    const filter = {
                        kinds: [1],
                        authors: [pubkey],
                        '#q': [communityId],
                        since: Math.floor(Date.now() / 1000)
                    };

                    this.relay.subscribe([filter], {
                        onevent: (event) => {
                            this.handleNostrEvent(event);
                        },
                        oneose: () => {
                            console.log(`Re-subscribed to messages from unbanned user ${fullNym}`);
                        }
                    });
                }

                const displayNym = this.formatNymWithPubkey(targetNym, pubkey);
                this.displaySystemMessage(`Unbanned ${displayNym} from this community`);

                // Announce in channel with full nym#suffix
                await this.publishCommunityMessage(`✅ ${fullNym} has been unbanned from this community`, communityId);

                // Reload UI
                this.loadCommunitySettingsUI(communityId);
            }

            async saveCommunitySettings() {
                const communityId = this.getCurrentCommunityId();
                if (!communityId) return;

                const community = this.communityChannels.get(communityId);
                if (!community) return;

                // Get updated values
                const newDesc = document.getElementById('communityDescEdit').value.trim();
                const newImageUrl = document.getElementById('communityImageEdit').value.trim();
                const newPrivacy = document.getElementById('communityPrivacyEdit').value === 'private';

                // Update local state
                community.description = newDesc;
                community.imageUrl = newImageUrl;
                community.isPrivate = newPrivacy;

                // Update the community definition event
                const mods = this.communityModerators.get(communityId) || new Set();

                const event = {
                    kind: 34550,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ['d', communityId],
                        ['name', community.name],
                        ['description', newDesc],
                        ['image', newImageUrl],
                        ['p', this.pubkey, '', 'admin'],
                    ],
                    content: newDesc,
                    pubkey: this.pubkey
                };

                // Add moderators
                mods.forEach(modPubkey => {
                    event.tags.push(['p', modPubkey, '', 'moderator']);
                });

                // Add privacy tag
                if (newPrivacy) {
                    event.tags.push(['private']);
                } else {
                    event.tags.push(['public']);
                }

                // Sign and send
                let signedEvent;
                if (window.nostr && !this.privkey) {
                    signedEvent = await window.nostr.signEvent(event);
                } else if (this.privkey) {
                    signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                }

                if (signedEvent) {
                    this.sendToRelay(["EVENT", signedEvent]);
                    this.displaySystemMessage('Community settings updated');

                    // Update channel badge if privacy changed
                    this.updateCommunityBadge(communityId, newPrivacy);

                    closeModal('communitySettingsModal');
                }
            }

            updateCommunityBadge(communityId, isPrivate) {
                const item = document.querySelector(`[data-community="${communityId}"]`);
                if (!item) return;

                const badgeContainer = item.querySelector('.channel-badges');
                const existingBadge = badgeContainer.querySelector('.std-badge');

                if (existingBadge) {
                    if (isPrivate) {
                        existingBadge.style.borderColor = 'var(--purple)';
                        existingBadge.style.color = 'var(--purple)';
                        existingBadge.textContent = 'PRI';
                    } else {
                        existingBadge.style.borderColor = 'var(--primary)';
                        existingBadge.style.color = 'var(--primary)';
                        existingBadge.textContent = 'PUB';
                    }
                }
            }

            async deleteCommunity() {
                const communityId = this.getCurrentCommunityId();
                if (!communityId) return;

                const community = this.communityChannels.get(communityId);
                if (!community) return;

                if (!confirm(`Are you sure you want to delete the community "${community.name}"? This cannot be undone.`)) {
                    return;
                }

                // Publish deletion event (kind 5 - deletion)
                const event = {
                    kind: 5,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ['a', `34550:${this.pubkey}:${communityId}`]
                    ],
                    content: 'Community deleted by admin',
                    pubkey: this.pubkey
                };

                let signedEvent;
                if (window.nostr && !this.privkey) {
                    signedEvent = await window.nostr.signEvent(event);
                } else if (this.privkey) {
                    signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                }

                if (signedEvent) {
                    this.sendToRelay(["EVENT", signedEvent]);
                }

                // Remove locally
                this.communityChannels.delete(communityId);
                this.ownedCommunities.delete(communityId);
                this.communityMembers.delete(communityId);
                this.communityModerators.delete(communityId);
                this.communityBans.delete(communityId);
                this.communityInvites.delete(communityId);

                // Remove from UI
                const item = document.querySelector(`[data-community="${communityId}"]`);
                if (item) {
                    item.remove();
                }

                this.channels.delete(communityId);
                this.userJoinedChannels.delete(communityId);

                this.displaySystemMessage(`Community "${community.name}" has been deleted`);

                closeModal('communitySettingsModal');

                // Switch to bar
                this.switchChannel('bar', '');
            }
        }

        // Global instance
        const nym = new NYM();

        // Global functions for onclick handlers
        function toggleSidebar() {
            nym.toggleSidebar();
        }

        function toggleSearch(inputId) {
            const search = document.getElementById(inputId);
            search.classList.toggle('active');
            if (search.classList.contains('active')) {
                search.focus();
            }
        }

        function sendMessage() {
            nym.sendMessage();
        }

        function selectImage() {
            document.getElementById('fileInput').click();
        }

        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
        }

        function closeImageModal() {
            document.getElementById('imageModal').classList.remove('active');
        }

        function editNick() {
            document.getElementById('newNickInput').value = nym.nym;
            document.getElementById('nickEditModal').classList.add('active');
        }

        function changeNick() {
            const newNick = document.getElementById('newNickInput').value.trim();
            if (newNick && newNick !== nym.nym) {
                nym.cmdNick(newNick);
            }
            closeModal('nickEditModal');
        }

        async function changeRelay() {
            const relaySelect = document.getElementById('connectedRelaySelect').value;
            const customRelay = document.getElementById('customConnectedRelay').value;

            const newRelayUrl = relaySelect === 'custom' ? customRelay : relaySelect;

            if (!newRelayUrl) {
                alert('Please select or enter a relay URL');
                return;
            }

            nym.displaySystemMessage('Switching relay...');
            await nym.connectToRelay(newRelayUrl);
        }

        async function showSettings() {
            nym.updateRelayStatus();

            // Load lightning address
            const lightningInput = document.getElementById('lightningAddressInput');
            if (lightningInput) {
                lightningInput.value = nym.lightningAddress || '';
            }

            // Load proximity sorting setting
            const proximitySelect = document.getElementById('proximitySelect');
            if (proximitySelect) {
                proximitySelect.value = nym.settings.sortByProximity ? 'true' : 'false';
            }

            // Load blur settings
            const blurSelect = document.getElementById('blurImagesSelect');
            if (blurSelect) {
                blurSelect.value = nym.blurOthersImages ? 'true' : 'false';
            }

            // Show/hide and load auto-ephemeral setting ONLY for ephemeral mode
            const autoEphemeralSettingGroup = document.getElementById('autoEphemeralSettingGroup');
            const autoEphemeralSelect = document.getElementById('autoEphemeralSelect');

            if (nym.connectionMode === 'ephemeral') {
                autoEphemeralSettingGroup.style.display = 'block';
                if (autoEphemeralSelect) {
                    const autoEphemeral = localStorage.getItem('nym_auto_ephemeral') === 'true';
                    autoEphemeralSelect.value = autoEphemeral ? 'true' : 'false';
                }
            } else {
                autoEphemeralSettingGroup.style.display = 'none';
            }

            document.getElementById('themeSelect').value = nym.settings.theme;
            document.getElementById('soundSelect').value = nym.settings.sound;
            document.getElementById('autoscrollSelect').value = nym.settings.autoscroll;
            document.getElementById('timestampSelect').value = nym.settings.showTimestamps;
            document.getElementById('timeFormatSelect').value = nym.settings.timeFormat;

            // Show/hide time format option based on timestamp visibility
            const timeFormatGroup = document.getElementById('timeFormatGroup');
            if (timeFormatGroup) {
                timeFormatGroup.style.display = nym.settings.showTimestamps ? 'block' : 'none';
            }

            nym.updateBlockedList();
            nym.updateKeywordList();
            nym.updateBlockedChannelsList();

            // Fill in disappearing message controls
            const dmEnabledSel = document.getElementById('dmForwardSecrecySelect');
            const dmTtlSel = document.getElementById('dmTTLSelect');
            const dmTtlGroup = document.getElementById('dmTTLGroup');

            if (dmEnabledSel && dmTtlSel && dmTtlGroup) {
                dmEnabledSel.value = nym.settings.dmForwardSecrecyEnabled ? 'true' : 'false';
                dmTtlSel.value = String(nym.settings.dmTTLSeconds || 86400);
                dmTtlGroup.style.display = nym.settings.dmForwardSecrecyEnabled ? 'block' : 'none';

                dmEnabledSel.onchange = () => {
                    dmTtlGroup.style.display = dmEnabledSel.value === 'true' ? 'block' : 'none';
                };
            }

            document.getElementById('settingsModal').classList.add('active');
        }

        async function saveSettings() {
            // Get all settings values
            const lightningAddress = document.getElementById('lightningAddressInput').value.trim();
            const theme = document.getElementById('themeSelect').value;
            const sound = document.getElementById('soundSelect').value;
            const autoscroll = document.getElementById('autoscrollSelect').value === 'true';
            const showTimestamps = document.getElementById('timestampSelect').value === 'true';
            const timeFormat = document.getElementById('timeFormatSelect').value;
            const sortByProximity = document.getElementById('proximitySelect').value === 'true';
            const blurImages = document.getElementById('blurImagesSelect').value === 'true';

            // Apply all settings
            nym.settings.theme = theme;
            nym.settings.sound = sound;
            nym.settings.autoscroll = autoscroll;
            nym.settings.showTimestamps = showTimestamps;
            nym.settings.timeFormat = timeFormat;

            // Apply blur settings
            nym.blurOthersImages = blurImages;
            nym.saveImageBlurSettings();

            // Read disappearing message controls
            const dmEnabled = document.getElementById('dmForwardSecrecySelect').value === 'true';
            const dmTTL = parseInt(document.getElementById('dmTTLSelect').value || '86400', 10);

            // Apply in memory
            nym.settings.dmForwardSecrecyEnabled = dmEnabled;
            nym.settings.dmTTLSeconds = isFinite(dmTTL) && dmTTL > 0 ? dmTTL : 86400;

            // Persist locally
            localStorage.setItem('nym_dm_fwdsec_enabled', String(nym.settings.dmForwardSecrecyEnabled));
            localStorage.setItem('nym_dm_ttl_seconds', String(nym.settings.dmTTLSeconds));

            // Only handle auto-ephemeral if currently in ephemeral mode
            if (nym.connectionMode === 'ephemeral') {
                const autoEphemeral = document.getElementById('autoEphemeralSelect').value === 'true';
                if (autoEphemeral) {
                    localStorage.setItem('nym_auto_ephemeral', 'true');
                } else {
                    localStorage.removeItem('nym_auto_ephemeral');
                }
            }

            // Handle proximity sorting
            if (sortByProximity) {
                if (!nym.userLocation) {
                    // Request location permission
                    navigator.geolocation.getCurrentPosition(
                        async (position) => {
                            nym.userLocation = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            };
                            nym.settings.sortByProximity = true;
                            localStorage.setItem('nym_sort_proximity', 'true');

                            // IMPORTANT: Re-sort immediately after getting location
                            nym.sortChannelsByActivity();

                            nym.displaySystemMessage('Location access granted. Geohash channels sorted by proximity.');

                            // Sync to Nostr if logged in
                            if (nym.connectionMode !== 'ephemeral') {
                                await nym.saveSyncedSettings();
                            }
                        },
                        (error) => {
                            nym.displaySystemMessage('Location access denied. Proximity sorting disabled.');
                            nym.settings.sortByProximity = false;
                            localStorage.setItem('nym_sort_proximity', 'false');
                            document.getElementById('proximitySelect').value = 'false';
                        }
                    );
                } else {
                    // Already have location
                    nym.settings.sortByProximity = true;
                    localStorage.setItem('nym_sort_proximity', 'true');
                    nym.sortChannelsByActivity(); // Re-sort
                }
            } else {
                // Disabling
                nym.settings.sortByProximity = false;
                localStorage.setItem('nym_sort_proximity', 'false');
                nym.userLocation = null;
                nym.sortChannelsByActivity(); // Re-sort to default
            }

            // Save theme and other settings
            nym.applyTheme(theme);
            nym.saveSettings();
            localStorage.setItem('nym_time_format', timeFormat);

            // Refresh messages to apply new time format
            nym.refreshMessageTimestamps();

            // Save lightning address
            if (lightningAddress !== nym.lightningAddress) {
                await nym.saveLightningAddress(lightningAddress || null);
            }

            // Sync to Nostr
            if (nym.connectionMode !== 'ephemeral') {
                await nym.saveSyncedSettings();
                nym.displaySystemMessage('Settings saved and synced to Nostr');
            } else {
                nym.displaySystemMessage('Settings saved locally');
            }

            closeModal('settingsModal');
        }

        function showAbout() {
            const connectedRelays = nym.relayPool.size;
            nym.displaySystemMessage(`
        ═══ NYM - Nostr Ynstant Messenger v2.16.46 ═══<br/>
        Protocol: <a href="https://nostr.com" target="_blank" rel="noopener" style="color: var(--secondary)">Nostr</a> (kinds 4550, 20000, 23333, 34550 channels)<br/>
        Connected Relays: ${connectedRelays} relays<br/>
        Your nym: ${nym.nym || 'Not set'}<br/>
        <br/>
        Created for ephemeral, anonymous communication.<br/>
        Your identity exists only for this session.<br/>
        No accounts. No persistence. Just nyms.<br/>
        <br/>
        Inspired by and bridged with Jack Dorsey's <a href="https://bitchat.free" target="_blank" rel="noopener" style="color: var(--secondary)">Bitchat</a><br/>
        <br/>
        NYM is FOSS code on <a href="https://github.com/Spl0itable/NYM" target="_blank" rel="noopener" style="color: var(--secondary)">GitHub</a><br/><br/>
        Made with ♥ by <a href="https://nostrservices.com" target="_blank" rel="noopener" style="color: var(--secondary)">21 Million LLC</a><br/><br/>
        Lead developer: <a href="https://nostr.band/npub16jdfqgazrkapk0yrqm9rdxlnys7ck39c7zmdzxtxqlmmpxg04r0sd733sv" target="_blank" rel="noopener" style="color: var(--secondary)">Luxas</a>
    `);
        }

        function showChannelModal() {
            document.getElementById('channelModal').classList.add('active');
        }

        async function joinOrCreateChannel() {
            const channelType = document.getElementById('channelTypeSelect').value;

            if (channelType === 'standard') {
                let name = document.getElementById('channelNameInput').value.trim();

                // Validate and sanitize
                if (!name) {
                    alert('Please enter a channel name');
                    return;
                }

                // Remove spaces and invalid characters
                name = name.toLowerCase().replace(/[^a-z0-9-]/g, '');

                if (!name) {
                    alert('Invalid channel name. Use only letters, numbers, and hyphens.');
                    return;
                }

                if (name.includes(' ')) {
                    alert('Channel names cannot contain spaces. Use hyphens instead (e.g., "my-channel")');
                    return;
                }

                await nym.cmdJoin(name);

            } else if (channelType === 'geohash') {
                let geohash = document.getElementById('geohashInput').value.trim().toLowerCase();
                geohash = geohash.replace(/[^0-9bcdefghjkmnpqrstuvwxyz]/g, '');

                if (!geohash) {
                    alert('Please enter a valid geohash');
                    return;
                }

                if (!nym.isValidGeohash(geohash)) {
                    alert('Invalid geohash. Valid characters are: 0-9, b-z (except a, i, l, o)');
                    return;
                }

                await nym.cmdJoin('#' + geohash);

            } else if (channelType === 'community') {
                // Check if ephemeral user
                if (nym.connectionMode === 'ephemeral') {
                    alert('Community channels require a persistent identity. Please use extension or nsec login.');
                    closeModal('channelModal');
                    return;
                }

                let name = document.getElementById('communityNameInput').value.trim();
                const description = document.getElementById('communityDescInput').value.trim();
                const imageUrl = document.getElementById('communityImageInput').value.trim();
                const isPrivate = document.getElementById('communityPrivacySelect').value === 'private';

                if (!name) {
                    alert('Please enter a community name');
                    return;
                }

                // Remove spaces and invalid characters
                name = name.toLowerCase().replace(/[^a-z0-9-]/g, '');

                if (!name) {
                    alert('Invalid community name. Use only letters, numbers, and hyphens.');
                    return;
                }

                // Double-check for spaces (should be caught by oninput, but just in case)
                if (name.includes(' ')) {
                    alert('Community names cannot contain spaces. Use hyphens instead (e.g., "my-community")');
                    return;
                }

                const communityId = await nym.createCommunityChannel(name, description, isPrivate, imageUrl);
                if (communityId) {
                    nym.switchToCommunity(communityId);
                }
            }

            closeModal('channelModal');
            document.getElementById('channelNameInput').value = '';
            document.getElementById('geohashInput').value = '';
            document.getElementById('communityNameInput').value = '';
            document.getElementById('communityDescInput').value = '';
            document.getElementById('communityImageInput').value = '';
            document.getElementById('communityPrivacySelect').value = 'public';
        }

        // Function to check for saved connection on page load
        async function checkSavedConnection() {
            // Auto-ephemeral preference FIRST
            const autoEphemeral = localStorage.getItem('nym_auto_ephemeral');
            if (autoEphemeral === 'true') {
                try {
                    // Hide setup modal
                    const setupModal = document.getElementById('setupModal');
                    setupModal.classList.remove('active');

                    nym.displaySystemMessage('Auto-starting ephemeral session...');

                    // Generate ephemeral keypair
                    await nym.generateKeypair();
                    nym.nym = nym.generateRandomNym();
                    nym.connectionMode = 'ephemeral';
                    document.getElementById('currentNym').textContent = nym.nym;

                    // Connect to relays
                    await nym.connectToRelays();

                    // Request notification permission
                    if (typeof Notification !== 'undefined' && Notification.permission === 'default') {
                        Notification.requestPermission();
                    }

                    // Welcome message
                    nym.displaySystemMessage(`Welcome to NYM, ${nym.nym}! Type /help for available commands.`);
                    nym.displaySystemMessage(`Your ephemeral identity is active for this session only.`);
                    nym.displaySystemMessage(`Click on any nym's nickname for more options.`);

                    // Start tutorial if not seen
                    window.maybeStartTutorial(false);

                    // Route to channel from URL if present
                    await routeToUrlChannel();

                    return; // Exit early
                } catch (error) {
                    console.error('Failed to auto-start ephemeral session:', error);
                    // Clear the preference and show setup modal
                    localStorage.removeItem('nym_auto_ephemeral');
                    document.getElementById('setupModal').classList.add('active');
                    return;
                }
            }

            const savedMode = localStorage.getItem('nym_connection_mode');
            const savedRelay = localStorage.getItem('nym_relay_url');
            const savedNsec = localStorage.getItem('nym_nsec');

            // Saved NSEC restore
            if (savedNsec) {
                try {
                    const setupModal = document.getElementById('setupModal');
                    setupModal.classList.remove('active');

                    nym.displaySystemMessage('Restoring NSEC session...');

                    // Restore from saved nsec
                    nym.privkey = nym.decodeNsec(savedNsec);
                    nym.pubkey = window.NostrTools.getPublicKey(nym.privkey);
                    nym.connectionMode = 'nsec';

                    // Default text while loading
                    nym.nym = 'Loading profile...';
                    document.getElementById('currentNym').textContent = nym.nym;

                    // Connect to relays
                    await nym.connectToRelays();

                    // Fetch profile after connection
                    if (nym.connected) {
                        await nym.fetchProfileFromRelay(nym.pubkey);
                        if (nym.nym === 'Loading profile...') {
                            nym.nym = nym.generateRandomNym();
                            document.getElementById('currentNym').textContent = nym.nym;
                        }
                    }

                    if (typeof Notification !== 'undefined' && Notification.permission === 'default') {
                        Notification.requestPermission();
                    }

                    nym.displaySystemMessage(`Welcome back to NYM, ${nym.nym}!`);
                    nym.displaySystemMessage(`Your Nostr identity has been restored.`);
                    nym.displaySystemMessage(`Type /help for available commands.`);

                    // Start tutorial if not seen
                    window.maybeStartTutorial(false);

                    return;
                } catch (error) {
                    console.error('Failed to restore connection:', error);
                    localStorage.removeItem('nym_nsec');
                    localStorage.removeItem('nym_connection_mode');
                    localStorage.removeItem('nym_relay_url');
                    document.getElementById('setupModal').classList.add('active');
                }
                return;
            }

            // Extension mode restore
            if (savedMode === 'extension' && window.nostr) {
                try {
                    const setupModal = document.getElementById('setupModal');
                    setupModal.classList.remove('active');

                    nym.displaySystemMessage('Reconnecting with Nostr extension...');
                    await nym.useExtension();

                    await nym.connectToRelay(savedRelay);

                    if (nym.connected) {
                        await nym.fetchProfileFromRelay(nym.pubkey);
                    }

                    if (typeof Notification !== 'undefined' && Notification.permission === 'default') {
                        Notification.requestPermission();
                    }

                    nym.displaySystemMessage(`Welcome back to NYM, ${nym.nym}!`);
                    nym.displaySystemMessage(`Your Nostr identity has been restored.`);
                    nym.displaySystemMessage(`Type /help for available commands.`);

                    // Start tutorial if not seen
                    window.maybeStartTutorial(false);

                } catch (error) {
                    console.error('Failed to restore connection:', error);
                    localStorage.removeItem('nym_connection_mode');
                    localStorage.removeItem('nym_relay_url');
                    document.getElementById('setupModal').classList.add('active');
                }
            }
            // If no saved connection, the setup modal remains visible (default).
        }

        async function initializeNym() {
            try {
                // Check if running in NYMApp shell
                const isNYMApp = navigator.userAgent.includes('NYMApp');

                const mode = document.getElementById('connectionMode').value;
                nym.connectionMode = mode; // Store connection mode

                // Get or generate nym first
                const nymInput = document.getElementById('nymInput').value.trim();

                // Handle different connection modes
                if (mode === 'ephemeral') {
                    await nym.generateKeypair();
                    nym.nym = nymInput || nym.generateRandomNym();
                    document.getElementById('currentNym').textContent = nym.nym;
                    localStorage.removeItem('nym_connection_mode');

                    // Auto-ephemeral checkbox
                    const autoEphemeralCheckbox = document.getElementById('autoEphemeralCheckbox');
                    if (autoEphemeralCheckbox && autoEphemeralCheckbox.checked) {
                        localStorage.setItem('nym_auto_ephemeral', 'true');
                    }

                } else if (mode === 'extension') {
                    await nym.useExtension();

                    if (nym.nym === 'Loading profile...' && !nymInput) {
                        nym.nym = nym.generateRandomNym();
                        document.getElementById('currentNym').textContent = nym.nym;
                    } else if (nymInput && nym.nym === 'Loading profile...') {
                        nym.nym = nymInput;
                        document.getElementById('currentNym').textContent = nym.nym;
                    }

                } else if (mode === 'nsec') {
                    let nsecValue = document.getElementById('nsecInput').value.trim();

                    if (!nsecValue) {
                        const savedNsec = localStorage.getItem('nym_nsec');
                        if (savedNsec) {
                            nsecValue = savedNsec;
                        }
                    }

                    if (!nsecValue) {
                        throw new Error('Please enter your NSEC');
                    }

                    // Decode NSEC to get private key
                    nym.privkey = nym.decodeNsec(nsecValue);
                    nym.pubkey = window.NostrTools.getPublicKey(nym.privkey);

                    // Fetch existing profile BEFORE setting nym
                    await nym.fetchProfileFromRelay(nym.pubkey);

                    // Only use input nym if provided, otherwise use profile name or generate
                    if (nymInput) {
                        nym.nym = nymInput;
                    } else if (!nym.nym || nym.nym === 'Loading profile...') {
                        nym.nym = nym.generateRandomNym();
                    }

                    document.getElementById('currentNym').textContent = nym.nym;

                    // Store NSEC securely
                    localStorage.setItem('nym_nsec', nsecValue);
                }

                // If nym is still not generated, generate it now
                if (!nym.nym) {
                    nym.nym = nym.generateRandomNym();
                    document.getElementById('currentNym').textContent = nym.nym;
                }

                // Save connection preferences
                if (mode !== 'ephemeral') {
                    localStorage.setItem('nym_connection_mode', mode);
                }

                // Connect to relays
                await nym.connectToRelays();

                // Fetch profile after connection for persistent modes
                if ((mode === 'extension' || mode === 'nsec') && nym.connected) {
                    // Fetch profile
                    await nym.fetchProfileFromRelay(nym.pubkey);

                    // Load synced settings (give relays time to respond)
                    setTimeout(() => {
                        nym.loadSyncedSettings();
                    }, 2000);
                }

                // Request notification permission
                if (typeof Notification !== 'undefined' && Notification.permission === 'default') {
                    Notification.requestPermission();
                }

                // Close setup modal
                closeModal('setupModal');

                // Welcome messages
                const modeText = mode === 'ephemeral' ? 'ephemeral' : 'persistent Nostr';
                nym.displaySystemMessage(`Welcome to NYM, ${nym.nym}! Type /help for available commands.`);
                nym.displaySystemMessage(`Your ${modeText} identity is active${mode === 'ephemeral' ? ' for this session only' : ''}.`);
                nym.displaySystemMessage(`Click on any nym's nickname for more options.`);

                // Route to channel from URL if present
                await routeToUrlChannel();

                // Start tutorial if not seen yet
                window.maybeStartTutorial(false);

            } catch (error) {
                console.error('Initialization failed:', error);
                alert('Failed to initialize: ' + error.message);
            }
        }

        // Disconnect/logout function
        function disconnectNym() {
            // Clear saved connection
            localStorage.removeItem('nym_connection_mode');
            localStorage.removeItem('nym_relay_url');

            // Disconnect from relay
            if (nym && nym.ws) {
                nym.disconnect();
            }

            // Reload page to start fresh
            window.location.reload();
        }

        // Sign-out button
        function signOut() {
            if (confirm('Sign out and disconnect from NYM?')) {
                // Clear auto-ephemeral preference on logout
                localStorage.removeItem('nym_auto_ephemeral');
                nym.cmdQuit();
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            // Parse URL for channel routing BEFORE initialization
            parseUrlChannel();

            // Check if running in NYMApp shell and hide extension option
            const isNYMApp = navigator.userAgent.includes('NYMApp');
            if (isNYMApp) {
                const connectionMode = document.getElementById('connectionMode');
                const extensionOption = connectionMode.querySelector('option[value="extension"]');
                if (extensionOption) {
                    extensionOption.remove();
                }

                // If extension was the default selected, switch to ephemeral
                if (connectionMode.value === 'extension') {
                    connectionMode.value = 'ephemeral';
                }
            }

            nym.initialize();

            // Pre-connect to a broadcast relay for instant connection
            async function preConnect() {
                for (const relayUrl of nym.broadcastRelays) {
                    try {
                        await nym.connectToRelay(relayUrl, 'broadcast');
                        console.log(`Pre-connected to ${relayUrl}`);
                        nym.updateConnectionStatus('Ready');
                        return; // Stop after first successful connection
                    } catch (err) {
                        console.log(`Failed to pre-connect to ${relayUrl}, trying next...`);
                    }
                }
                // If all failed, just log it - the main connection flow will try again
                console.log('Pre-connection failed, will retry during initialization');
            }

            preConnect();

            // Auto-focus nickname input
            document.getElementById('nymInput').focus();

            // Connection mode change listener
            document.getElementById('connectionMode').addEventListener('change', (e) => {
                const mode = e.target.value;
                const nsecGroup = document.getElementById('nsecGroup');
                const nymGroup = document.getElementById('nymGroup');
                const hint = document.getElementById('nymHint');
                const nymInput = document.getElementById('nymInput');
                const nsecInput = document.getElementById('nsecInput');
                const autoEphemeralGroup = document.getElementById('autoEphemeralGroup');

                // Hide all special groups first
                nsecGroup.style.display = 'none';
                autoEphemeralGroup.style.display = 'none'; // Hide auto-ephemeral by default

                switch (mode) {
                    case 'ephemeral':
                        hint.textContent = 'Your ephemeral pseudonym for this session';
                        nymInput.placeholder = 'Leave empty for random nick';
                        autoEphemeralGroup.style.display = 'block'; // Show only for ephemeral
                        break;
                    case 'extension':
                        hint.textContent = 'Will use your Nostr profile name if available';
                        nymInput.placeholder = 'Override profile name (optional)';
                        break;
                    case 'nsec':
                        nsecGroup.style.display = 'block';
                        hint.textContent = 'Will use your Nostr profile name if available';
                        nymInput.placeholder = 'Override profile name (optional)';

                        // Auto-fill saved nsec if available
                        const savedNsec = localStorage.getItem('nym_nsec');
                        if (savedNsec) {
                            nsecInput.value = savedNsec;
                        }
                        break;
                }
            });

            // Add listener to show/hide time format option
            document.getElementById('timestampSelect').addEventListener('change', (e) => {
                const timeFormatGroup = document.getElementById('timeFormatGroup');
                if (timeFormatGroup) {
                    timeFormatGroup.style.display = e.target.value === 'true' ? 'block' : 'none';
                }
            });

            // Check if proximity sorting was enabled
            setTimeout(() => {
                if (nym.settings.sortByProximity === true) {
                    console.log('Proximity sorting is enabled, requesting location...');
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            nym.userLocation = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            };
                            console.log('Got user location:', nym.userLocation);
                            // Re-sort channels with location
                            nym.sortChannelsByActivity();
                        },
                        (error) => {
                            console.error('Location error:', error);
                            nym.settings.sortByProximity = false;
                            localStorage.setItem('nym_sort_proximity', 'false');
                        }
                    );
                }
            }, 1000);

            // Periodically clean up non-responsive relays
            setInterval(() => {
                if (nym.connected) {
                    nym.cleanupNonResponsiveRelays();
                }
            }, 5000);

            // Periodically update connection status
            setInterval(() => {
                if (nym.connected) {
                    nym.updateConnectionStatus();
                }
            }, 1000);

            // Periodic connection health check
            setInterval(() => {
                if (nym.connected || nym.relayPool.size > 0) {
                    // Only log if we think we should be connected
                    nym.checkConnectionHealth();
                }
            }, 1000);

            // Check for saved connection AFTER initialization is complete
            setTimeout(() => {
                checkSavedConnection();
            }, 100);

            // Periodically update user list
            setInterval(() => {
                if (nym.connected) {
                    nym.updateUserList();
                }
            }, 5000);

            // Override the existing search functions to handle collapsed lists properly
            const originalHandleChannelSearch = nym.handleChannelSearch;
            nym.handleChannelSearch = function (searchTerm) {
                // First expand the list to make all items searchable
                const channelList = document.getElementById('channelList');
                const wasCollapsed = channelList.classList.contains('list-collapsed');

                if (wasCollapsed && searchTerm.length > 0) {
                    channelList.classList.remove('list-collapsed');
                    channelList.classList.add('list-expanded');
                }

                // Call original search function
                originalHandleChannelSearch.call(this, searchTerm);

                // Restore collapsed state if search is cleared
                if (wasCollapsed && searchTerm.length === 0) {
                    channelList.classList.add('list-collapsed');
                    channelList.classList.remove('list-expanded');
                }
            };

            const originalFilterPMs = nym.filterPMs;
            nym.filterPMs = function (searchTerm) {
                // First expand the list to make all items searchable
                const pmList = document.getElementById('pmList');
                const wasCollapsed = pmList.classList.contains('list-collapsed');

                if (wasCollapsed && searchTerm.length > 0) {
                    pmList.classList.remove('list-collapsed');
                    pmList.classList.add('list-expanded');
                }

                // Call original filter function
                originalFilterPMs.call(this, searchTerm);

                // Restore collapsed state if search is cleared
                if (wasCollapsed && searchTerm.length === 0) {
                    pmList.classList.add('list-collapsed');
                    pmList.classList.remove('list-expanded');
                }
            };

            const originalFilterUsers = nym.filterUsers;
            nym.filterUsers = function (searchTerm) {
                // First expand the list to make all items searchable
                const userList = document.getElementById('userListContent');
                const wasCollapsed = userList.classList.contains('list-collapsed');

                if (wasCollapsed && searchTerm.length > 0) {
                    userList.classList.remove('list-collapsed');
                    userList.classList.add('list-expanded');
                }

                // Call original filter function
                originalFilterUsers.call(this, searchTerm);

                // Restore collapsed state if search is cleared
                if (wasCollapsed && searchTerm.length === 0) {
                    userList.classList.add('list-collapsed');
                    userList.classList.remove('list-expanded');
                }
            };

            // Background message cleanup
            setInterval(() => {
                // Clean up stored messages for inactive channels
                const currentKey = nym.currentGeohash ? `#${nym.currentGeohash}` : nym.currentChannel;

                nym.messages.forEach((messages, channel) => {
                    // Skip current channel
                    if (channel === currentKey) return;

                    // Prune inactive channels to 500 messages max
                    if (messages.length > 500) {
                        nym.messages.set(channel, messages.slice(-500));
                        console.log(`Background pruned ${channel} to 500 messages`);
                    }
                });

                // Clear event deduplication if too large
                if (nym.eventDeduplication.size > 5000) {
                    nym.eventDeduplication.clear();
                    console.log('Cleared event deduplication cache');
                }
            }, 60000);

            // Periodically check and clear expired blacklists
            setInterval(() => {
                if (nym.connected) {
                    // Check all blacklisted relays for expiration
                    const expiredRelays = [];
                    nym.blacklistedRelays.forEach(relayUrl => {
                        if (nym.isBlacklistExpired(relayUrl)) {
                            expiredRelays.push(relayUrl);
                        }
                    });

                    // Try to reconnect to expired blacklisted relays
                    expiredRelays.forEach(relayUrl => {
                        if (nym.broadcastRelays.includes(relayUrl) && !nym.relayPool.has(relayUrl)) {
                            nym.connectToRelay(relayUrl, 'broadcast')
                                .then(() => {
                                    nym.subscribeToSingleRelay(relayUrl);
                                    nym.updateConnectionStatus();
                                })
                                .catch(err => {
                                    nym.trackRelayFailure(relayUrl);
                                });
                        }
                    });
                }
            }, 60000); // Check every minute
        });

        // Parse URL for channel routing
        function parseUrlChannel() {
            const hash = window.location.hash;
            if (hash && hash.length > 1) {
                const channelFromUrl = hash.substring(1).toLowerCase();

                // Store for use after initialization
                window.pendingChannel = channelFromUrl;
                console.log('Channel from URL:', channelFromUrl);
            }
        }

        // Handle channel routing after initialization
        async function routeToUrlChannel() {
            if (window.pendingChannel) {
                const channelInput = window.pendingChannel;
                delete window.pendingChannel;

                // Small delay for persistent connections to ensure relays are ready
                if (nym.connectionMode !== 'ephemeral') {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }

                // Parse channel type from prefix
                let channelType = 'auto'; // auto-detect if no prefix
                let channelName = channelInput;

                if (channelInput.startsWith('c:')) {
                    channelType = 'community';
                    channelName = channelInput.substring(2);
                } else if (channelInput.startsWith('g:')) {
                    channelType = 'geohash';
                    channelName = channelInput.substring(2);
                } else if (channelInput.startsWith('e:')) {
                    channelType = 'ephemeral';
                    channelName = channelInput.substring(2);
                }

                // Handle based on type
                if (channelType === 'community') {
                    // Handle community routing
                    const communityId = channelName;

                    // Function to check for community
                    const checkForCommunity = () => {
                        if (nym.communityChannels.has(communityId)) {
                            const community = nym.communityChannels.get(communityId);

                            if (nym.connectionMode === 'ephemeral') {
                                nym.displaySystemMessage(`Community "${community.name}" requires a persistent identity (extension or nsec login)`);
                                return false;
                            }

                            if (!document.querySelector(`[data-community="${communityId}"]`)) {
                                nym.addCommunityChannel(community.name, communityId, community.isPrivate);
                            }

                            nym.switchToCommunity(communityId);
                            nym.userJoinedChannels.add(communityId);
                            nym.saveUserChannels();
                            nym.displaySystemMessage(`Joined community #${community.name} from URL`);
                            return true;
                        }
                        return false;
                    };

                    // Try to find community immediately
                    let foundCommunity = checkForCommunity();

                    // If not found and user is persistent, wait for discovery
                    if (!foundCommunity && nym.connectionMode !== 'ephemeral') {
                        nym.displaySystemMessage(`Looking for community...`);

                        // Wait up to 5 seconds for community to be discovered
                        for (let i = 0; i < 10; i++) {
                            await new Promise(resolve => setTimeout(resolve, 500));
                            foundCommunity = checkForCommunity();
                            if (foundCommunity) break;
                        }

                        if (!foundCommunity) {
                            nym.displaySystemMessage(`Community not found. It may be private or no longer exist.`);
                        }
                    }
                } else if (channelType === 'geohash' || (channelType === 'auto' && nym.isValidGeohash(channelName))) {
                    // Geohash channel
                    nym.addChannel(channelName, channelName);
                    nym.switchChannel(channelName, channelName);
                    nym.userJoinedChannels.add(channelName);
                    nym.saveUserChannels();
                    nym.displaySystemMessage(`Joined geohash channel #${channelName} from URL`);
                } else {
                    // Standard ephemeral channel
                    nym.addChannel(channelName, '');
                    nym.switchChannel(channelName, '');
                    await nym.createChannel(channelName);
                    nym.userJoinedChannels.add(channelName);
                    nym.saveUserChannels();
                    nym.displaySystemMessage(`Joined channel #${channelName} from URL`);
                }

                // Clear the URL hash to clean up
                history.replaceState(null, null, window.location.pathname);
            }
        }
    </script>

    <!-- QRCode library for Lightning invoices -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <!-- Three.js and Globe libraries -->
    <script type="importmap">
    {
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
    }
    </script>
    <script async type="module">
        import * as THREE from 'three';

        // Make available globally
        window.THREE = THREE;

        // Load three-globe after THREE is available
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/three-globe@2.31.0/dist/three-globe.min.js';
        document.head.appendChild(script);
    </script>
</body>

</html>