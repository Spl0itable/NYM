<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NYM - Nostr Ynstant Messenger</title>
    <meta name="description" content="Ephemeral anonymous messaging over Nostr">
    <link rel="manifest"
        href="data:application/json;base64,eyJuYW1lIjoiTllNIC0gTm9zdHIgWW5zdGFudCBNZXNzZW5nZXIiLCJzaG9ydF9uYW1lIjoiTllNIiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwidGhlbWVfY29sb3IiOiIjMDAwMDAwIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwMDAwMDAiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAxMDAgMTAwJyUzRSUzQ3JlY3Qgd2lkdGg9JzEwMCcgaGVpZ2h0PScxMDAnIGZpbGw9JyUyMzAwMCclMkYlM0UlM0N0ZXh0IHg9JzUwJyB5PSc1NScgZm9udC1zaXplPSc0MCcgZmlsbD0nJTIzMGZmJyB0ZXh0LWFuY2hvcj0nbWlkZGxlJyBmb250LWZhbWlseT0nbW9ub3NwYWNlJyUzRU5ZTSUzQyUyRnRleHQlM0UlM0MlMkZzdmclM0UiLCJzaXplcyI6ImFueSIsInR5cGUiOiJpbWFnZS9zdmcreG1sIn1dfQ==">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Anonymously Chat with NYM">
    <meta property="og:description" content="Ephemeral anonymous messaging over Nostr">
    <meta property="og:image" content="https://nym.bar/images/NYM-icon.png">
    <meta property="og:url" content="https://nym.bar">
    <meta property="og:type" content="website">
    <link rel="icon" href="./images/NYM-icon.png" type="image/png">
    <link rel="canonical" href="https://nym.bar/">
    <meta name="theme-color" content="#000000">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="NYM">
    <link rel="apple-touch-icon" href="./images/NYM-icon.png">

    <!-- Import nostr-tools -->
    <script src="https://unpkg.com/nostr-tools/lib/nostr.bundle.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00ff00;
            --secondary: #00ffff;
            --warning: #ffff00;
            --danger: #ff0000;
            --purple: #ff00ff;
            --blue: #0080ff;
            --bg: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #111111;
            --text: #00ff00;
            --text-dim: #008800;
            --text-bright: #00ffaa;
            --border: #00ff00;
            --font-mono: 'Courier New', 'Consolas', 'Monaco', monospace;
        }

        body {
            font-family: var(--font-mono);
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 255, 0, 0.03) 2px,
                    rgba(0, 255, 0, 0.03) 4px);
            pointer-events: none;
            z-index: 1;
        }

        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.4) 100%);
            pointer-events: none;
            z-index: 1;
        }

        .container {
            display: flex;
            height: 100vh;
            position: relative;
            z-index: 2;
        }

        .sidebar {
            width: 240px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s;
        }

        .sidebar-header {
            padding: 20px 15px;
            border-bottom: 1px solid var(--border);
            text-align: center;
            background: var(--bg-tertiary);
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
            text-shadow: 0 0 10px var(--primary);
            margin-bottom: 5px;
            letter-spacing: 4px;
        }

        .tagline {
            font-size: 10px;
            color: var(--text-dim);
            letter-spacing: 1px;
        }

        .nym-display {
            margin-top: 15px;
            padding: 8px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .nym-display:hover {
            border-color: var(--primary);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .nym-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .nym-value {
            font-size: 14px;
            color: var(--text-bright);
            margin-top: 3px;
            overflow: hidden;
            text-overflow: ellipsis;
            word-break: break-all;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--primary);
            animation: pulse 2s infinite;
            box-shadow: 0 0 5px var(--primary);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(0.9);
            }
        }

        .nav-section {
            padding: 15px 10px 10px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.2);
        }

        .nav-title {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            padding-left: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-title-text {
            flex: 1;
        }

        .search-icon {
            cursor: pointer;
            padding: 2px 5px;
            transition: all 0.2s;
            width: 20px;
            height: 20px;
        }

        .search-icon:hover svg {
            stroke: var(--primary);
        }

        .search-icon svg {
            width: 14px;
            height: 14px;
            stroke: var(--text-dim);
            stroke-width: 2;
            fill: none;
            transition: stroke 0.2s;
        }

        .search-input {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 8px;
            font-family: var(--font-mono);
            font-size: 12px;
            outline: none;
            margin-bottom: 10px;
            display: none;
        }

        .search-input.active {
            display: block;
        }

        .search-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .channel-list,
        .pm-list {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .channel-item,
        .pm-item {
            padding: 8px 10px;
            margin: 3px 0;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .channel-item.pinned {
            order: -1;
            background: rgba(255, 215, 0, 0.05);
            border-color: rgba(255, 215, 0, 0.3);
        }

        .channel-item:hover,
        .pm-item:hover {
            border-color: var(--border);
            background: rgba(0, 255, 0, 0.1);
            padding-left: 15px;
        }

        .channel-item.active,
        .pm-item.active {
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.2);
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.1);
        }

        .channel-item.active::before,
        .pm-item.active::before {
            content: "▶";
            position: absolute;
            left: -2px;
            color: var(--primary);
            animation: blink 1s infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        .channel-name,
        .pm-name {
            flex: 1;
        }

        .channel-badges {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .pin-btn {
            font-size: 12px;
            color: var(--text-dim);
            padding: 2px;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
        }

        .pin-btn:hover {
            opacity: 1;
        }

        .pin-btn.pinned {
            opacity: 1;
            color: var(--warning);
        }

        .pin-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        .std-badge {
            font-size: 9px;
            color: var(--blue);
            background: var(--bg);
            padding: 2px 4px;
            border: 1px solid var(--blue);
            border-radius: 3px;
        }

        .geohash-badge {
            font-size: 9px;
            color: var(--warning);
            background: var(--bg);
            padding: 2px 4px;
            border: 1px solid var(--warning);
            border-radius: 3px;
        }

        .pm-badge {
            font-size: 9px;
            color: var(--purple);
            background: var(--bg);
            padding: 2px 4px;
            border: 1px solid var(--purple);
            border-radius: 3px;
        }

        .delete-pm {
            font-size: 10px;
            color: var(--danger);
            padding: 2px 5px;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .delete-pm:hover {
            opacity: 1;
        }

        .unread-badge {
            background: var(--danger);
            color: var(--bg);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            animation: glow 1s infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 3px var(--danger);
            }

            to {
                box-shadow: 0 0 8px var(--danger);
            }
        }

        .user-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .user-item {
            padding: 6px 10px;
            font-size: 12px;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .user-item:hover {
            color: var(--text);
            background: rgba(0, 255, 0, 0.05);
        }

        .user-item.search-hidden {
            display: none !important;
        }

        .user-status {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--primary);
        }

        .user-status.away {
            background: var(--warning);
        }

        .user-status.offline {
            background: var(--text-dim);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: var(--bg);
        }

        .chat-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
        }

        .channel-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .channel-title {
            font-size: 18px;
            color: var(--primary);
            text-shadow: 0 0 5px var(--primary);
        }

        .channel-meta {
            font-size: 11px;
            color: var(--text-dim);
        }

        .header-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .icon-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 12px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .icon-btn:hover {
            background: var(--primary);
            color: var(--bg);
            box-shadow: 0 0 10px var(--primary);
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 14px;
        }

        .message {
            display: flex;
            gap: 10px;
            padding: 8px 10px;
            border-left: 2px solid transparent;
            transition: all 0.2s;
            animation: messageIn 0.3s;
            position: relative;
            flex-wrap: wrap;
        }

        .message.blocked {
            display: none;
        }

        .message.flooded {
            opacity: 0.3;
            filter: blur(2px);
        }

        .message.pm {
            border-left-color: transparent;
            background: transparent;
        }

        .message.pm:hover {
            border-left-color: var(--purple);
            background: rgba(255, 0, 255, 0.05);
        }

        @keyframes messageIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .message:hover {
            background: rgba(0, 255, 0, 0.05);
            border-left-color: var(--primary);
        }

        .message:hover .reaction-btn {
            opacity: 1;
        }

        .reaction-btn {
            position: absolute;
            right: 10px;
            top: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 4px 8px;
            cursor: pointer;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reaction-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--primary);
        }

        .reaction-btn svg {
            width: 16px;
            height: 16px;
            stroke: var(--text);
            fill: none;
        }

        .reactions-row {
            width: 100%;
            display: flex;
            gap: 5px;
            margin-top: 5px;
            margin-left: auto;
            align-items: center;
            flex-wrap: wrap;
        }

        .reaction-badge {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 3px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            user-select: none;
        }

        .reaction-badge:hover {
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.1);
            transform: scale(1.05);
        }

        .reaction-badge:active {
            transform: scale(0.95);
        }

        .reaction-badge.user-reacted {
            background: rgba(0, 255, 0, 0.2);
            border-color: var(--primary);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .reaction-badge[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 4px 8px;
            font-size: 10px;
            white-space: nowrap;
            margin-bottom: 4px;
            z-index: 1000;
            pointer-events: none;
        }

        .message-time {
            color: var(--text-dim);
            font-size: 12px;
            min-width: 50px;
        }

        .message-author {
            color: var(--secondary);
            min-width: 120px;
            font-weight: bold;
            text-shadow: 0 0 3px var(--secondary);
            cursor: pointer;
        }

        .message-author:hover {
            text-decoration: underline;
        }

        .message-author.self {
            color: var(--primary);
            text-shadow: 0 0 3px var(--primary);
        }

        .message-content {
            flex: 1;
            word-wrap: break-word;
            word-break: break-word;
            color: var(--text);
            overflow-wrap: anywhere;
        }

        .message-content a {
            color: var(--secondary);
            text-decoration: underline;
        }

        .message-content .channel-link {
            color: var(--secondary);
            cursor: pointer;
            text-decoration: underline;
        }

        .message-content .channel-link:hover {
            color: var(--primary);
        }

        .message-content img {
            max-width: 300px;
            max-height: 300px;
            display: block;
            margin: 10px 0;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .message-content img:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .reaction-badge {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 3px;
            cursor: default;
            position: relative;
        }

        .reaction-badge:hover {
            border-color: var(--primary);
        }

        .reaction-badge[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 4px 8px;
            font-size: 10px;
            white-space: nowrap;
            margin-bottom: 4px;
            z-index: 1000;
        }

        .message-content strong {
            color: var(--text-bright);
            font-weight: bold;
        }

        .message-content em {
            font-style: italic;
            color: var(--text);
        }

        .message-content code {
            background: var(--bg-tertiary);
            padding: 2px 4px;
            font-family: var(--font-mono);
            color: var(--secondary);
        }

        .message-content pre {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            padding: 10px;
            margin: 10px 0;
            overflow-x: auto;
        }

        .message-content blockquote {
            border-left: 3px solid var(--primary);
            padding-left: 10px;
            margin: 10px 0;
            color: var(--text-dim);
        }

        .message-content h1,
        .message-content h2,
        .message-content h3 {
            color: var(--primary);
            margin: 10px 0;
        }

        .message-content ul,
        .message-content ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .message-content del {
            text-decoration: line-through;
            color: var(--text-dim);
        }

        .system-message {
            color: var(--warning);
            font-style: italic;
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-top: 1px dashed var(--text-dim);
            border-bottom: 1px dashed var(--text-dim);
        }

        .action-message {
            color: var(--purple);
            font-style: italic;
        }

        .typing-indicator {
            padding: 5px 20px;
            color: var(--text-dim);
            font-size: 12px;
            min-height: 20px;
            font-style: italic;
        }

        .input-container {
            padding: 15px;
            border-top: 1px solid var(--border);
            background: var(--bg-secondary);
            display: flex;
            gap: 10px;
            align-items: stretch;
            position: relative;
        }

        .input-wrapper {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
        }

        .message-input {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px;
            font-family: var(--font-mono);
            font-size: 14px;
            outline: none;
            resize: vertical;
            min-height: 40px;
            max-height: 120px;
        }

        .message-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        .char-counter {
            position: absolute;
            bottom: -18px;
            right: 5px;
            font-size: 10px;
            color: var(--text-dim);
        }

        .input-buttons {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .send-btn {
            background: var(--bg);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 10px 20px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            height: 40px;
        }

        .send-btn:hover:not(:disabled) {
            background: var(--primary);
            color: var(--bg);
            box-shadow: 0 0 15px var(--primary);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .icon-btn.input-btn {
            height: 40px;
            padding: 0 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-btn.input-btn svg {
            width: 18px;
            height: 18px;
            stroke: var(--text);
            stroke-width: 2;
            fill: none;
        }

        .icon-btn.input-btn:hover svg {
            stroke: var(--bg);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 2px solid var(--primary);
            padding: 30px;
            max-width: 500px;
            width: 90%;
            animation: modalIn 0.3s;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
            max-height: 90vh;
            overflow-y: auto;
        }

        @keyframes modalIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .modal-header {
            font-size: 20px;
            color: var(--primary);
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--primary);
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-dim);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px;
            font-family: var(--font-mono);
            font-size: 14px;
            outline: none;
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            border-color: var(--primary);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .form-hint {
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 5px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .blocked-list,
        .keyword-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border);
            padding: 10px;
            background: var(--bg);
        }

        .blocked-item,
        .keyword-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin: 2px 0;
        }

        .blocked-item:hover,
        .keyword-item:hover {
            background: rgba(0, 255, 0, 0.1);
        }

        .unblock-btn,
        .remove-keyword-btn {
            padding: 2px 8px;
            font-size: 10px;
            background: var(--bg);
            border: 1px solid var(--danger);
            color: var(--danger);
            cursor: pointer;
        }

        .unblock-btn:hover,
        .remove-keyword-btn:hover {
            background: var(--danger);
            color: var(--bg);
        }

        .search-create-prompt {
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            margin-top: 5px;
            font-size: 12px;
            color: var(--text-bright);
            cursor: pointer;
        }

        .search-create-prompt:hover {
            background: rgba(0, 255, 0, 0.1);
            border-color: var(--primary);
        }

        .image-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .image-modal.active {
            display: flex;
        }

        .image-modal img {
            max-width: 90%;
            max-height: 90%;
            border: 2px solid var(--primary);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }

        .image-modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: var(--primary);
            font-size: 30px;
            cursor: pointer;
            background: var(--bg);
            border: 2px solid var(--primary);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-modal-close:hover {
            background: var(--primary);
            color: var(--bg);
        }

        .mobile-menu-toggle {
            display: none;
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 100;
            background: var(--bg-secondary);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 10px;
            cursor: pointer;
            font-size: 20px;
        }

        .mobile-title {
            display: none;
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            color: var(--primary);
            font-size: 14px;
            text-shadow: 0 0 5px var(--primary);
        }

        .nick-edit-modal {
            display: none;
        }

        .nick-edit-modal.active {
            display: flex;
        }

        .autocomplete-dropdown,
        .emoji-autocomplete {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            max-height: 150px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 -5px 20px rgba(0, 255, 0, 0.2);
            margin-bottom: 5px;
        }

        .autocomplete-dropdown.active,
        .emoji-autocomplete.active {
            display: block;
        }

        .autocomplete-item,
        .emoji-item {
            padding: 8px 10px;
            cursor: pointer;
            color: var(--text-dim);
            transition: all 0.2s;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected,
        .emoji-item:hover,
        .emoji-item.selected {
            background: rgba(0, 255, 0, 0.1);
            color: var(--text);
        }

        .autocomplete-item strong {
            color: var(--primary);
        }

        .emoji-item {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .emoji-item-emoji {
            font-size: 18px;
        }

        .emoji-item-name {
            font-size: 12px;
        }

        .command-palette {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 5px;
            display: none;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 -5px 20px rgba(0, 255, 0, 0.2);
            margin-bottom: 5px;
        }

        .command-palette.active {
            display: block;
        }

        .command-item {
            padding: 8px 10px;
            cursor: pointer;
            color: var(--text-dim);
            display: flex;
            justify-content: space-between;
            transition: all 0.2s;
        }

        .command-item:hover,
        .command-item.selected {
            background: rgba(0, 255, 0, 0.1);
            color: var(--text);
        }

        .command-item:active {
            background: rgba(0, 255, 0, 0.2);
        }

        .command-name {
            color: var(--primary);
            font-weight: bold;
        }

        .command-desc {
            font-size: 12px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 15px 20px;
            max-width: 350px;
            animation: slideIn 0.3s;
            z-index: 2000;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.4);
        }

        @keyframes slideIn {
            from {
                transform: translateX(120%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification-title {
            color: var(--primary);
            margin-bottom: 5px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
        }

        .notification-body {
            color: var(--text);
            font-size: 13px;
        }

        .notification-time {
            color: var(--text-dim);
            font-size: 10px;
            margin-top: 5px;
        }

        .file-input {
            display: none;
        }

        .upload-progress {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 10px;
            margin-bottom: 5px;
            display: none;
        }

        .upload-progress.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            transition: width 0.3s;
        }

        .reaction-picker {
            position: absolute;
            bottom: calc(100% + 5px);
            right: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 10px;
            display: none;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            box-shadow: 0 -5px 20px rgba(0, 255, 0, 0.2);
            z-index: 600;
        }

        .reaction-picker.active {
            display: grid;
        }

        .reaction-emoji {
            background: var(--bg);
            border: 1px solid transparent;
            padding: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .reaction-emoji:hover {
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.1);
            transform: scale(1.2);
        }

        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100%;
                z-index: 99;
                transform: translateX(-100%);
                width: 280px;
            }

            .sidebar.open {
                transform: translateX(0);
                box-shadow: 5px 0 20px rgba(0, 0, 0, 0.8);
            }

            .mobile-menu-toggle {
                display: block;
            }

            .mobile-title {
                display: block;
            }

            .main-content {
                margin-left: 0;
            }

            .messages-container {
                padding: 15px 10px;
            }

            .modal-content {
                margin: 20px;
            }

            .header-actions {
                position: fixed;
                top: 10px;
                right: 10px;
                z-index: 100;
                flex-direction: row;
                gap: 3px;
            }

            .header-actions .icon-btn {
                padding: 8px;
                font-size: 11px;
            }

            .chat-header {
                padding-top: 50px;
            }

            .input-container {
                padding: 10px;
                gap: 5px;
            }

            .input-buttons {
                flex-direction: column;
                gap: 5px;
            }

            .icon-btn.input-btn {
                width: 40px;
            }

            .send-btn {
                padding: 10px;
                font-size: 11px;
            }

            .reaction-btn {
                opacity: 1;
                font-size: 14px;
                padding: 2px 4px;
            }
        }

        .emoji-picker {
            position: absolute;
            bottom: 100%;
            right: 60px;
            background: var(--bg-tertiary);
            border: 1px solid var(--primary);
            padding: 10px;
            display: none;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            max-width: 320px;
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: 0 -5px 20px rgba(0, 255, 0, 0.2);
            margin-bottom: 5px;
            z-index: 500;
        }

        .emoji-picker.active {
            display: grid;
        }

        .emoji-btn {
            background: var(--bg);
            border: 1px solid transparent;
            padding: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .emoji-btn:hover {
            border-color: var(--primary);
            background: rgba(0, 255, 0, 0.1);
            transform: scale(1.2);
        }

        @media (max-width: 480px) {
            .emoji-picker {
                grid-template-columns: repeat(6, 1fr);
                right: 10px;
            }
        }

        .loader {
            display: inline-block;
            width: 15px;
            height: 15px;
            border: 2px solid var(--text-dim);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--text-dim);
            border: 1px solid var(--border);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* Ghost theme specific styles */
        body.theme-ghost {
            --primary: #ffffff;
            --secondary: #cccccc;
            --warning: #888888;
            --danger: #666666;
            --purple: #999999;
            --blue: #bbbbbb;
            --bg: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #111111;
            --text: #ffffff;
            --text-dim: #666666;
            --text-bright: #ffffff;
            --border: #333333;
        }

        body.theme-ghost::before {
            background: repeating-linear-gradient(0deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 255, 255, 0.02) 2px,
                    rgba(255, 255, 255, 0.02) 4px);
        }
    </style>
</head>

<body>
    <button class="mobile-menu-toggle" onclick="toggleSidebar()">☰</button>
    <div class="mobile-title" id="mobileTitle">#bar</div>

    <div class="container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="logo">NYM</div>
                <div class="tagline">Ephemeral Nostr Chat</div>
                <div class="nym-display" onclick="editNick()">
                    <div class="nym-label">Your Nym (click to edit)</div>
                    <div class="nym-value" id="currentNym">anonymous</div>
                </div>
                <div class="status-indicator">
                    <span class="status-dot" id="statusDot"></span>
                    <span id="connectionStatus">Disconnected</span>
                </div>
            </div>

            <div class="nav-section">
                <div class="nav-title">
                    <span class="nav-title-text">Channels</span>
                    <span class="search-icon" onclick="toggleSearch('channelSearch')">
                        <svg viewBox="0 0 24 24">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </span>
                </div>
                <input type="text" class="search-input" id="channelSearch" placeholder="Search channels..."
                    onkeyup="nym.handleChannelSearch(this.value)">
                <div id="channelSearchResults"></div>
                <div class="channel-list" id="channelList">
                    <div class="channel-item active" data-channel="bar" data-geohash="">
                        <span class="channel-name">#bar</span>
                        <div class="channel-badges">
                            <span class="pin-btn" onclick="event.stopPropagation(); nym.togglePin('bar', '')">
                                <svg viewBox="0 0 24 24">
                                    <path d="M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z" />
                                </svg>
                            </span>
                            <span class="std-badge">STD</span>
                            <span class="unread-badge" style="display:none">0</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="nav-section">
                <div class="nav-title">
                    <span class="nav-title-text">Private Messages</span>
                    <span class="search-icon" onclick="toggleSearch('pmSearch')">
                        <svg viewBox="0 0 24 24">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </span>
                </div>
                <input type="text" class="search-input" id="pmSearch" placeholder="Search PMs..."
                    onkeyup="nym.filterPMs(this.value)">
                <div class="pm-list" id="pmList"></div>
            </div>

            <div class="user-list" id="userList">
                <div class="nav-title">
                    <span class="nav-title-text">Active Nyms</span>
                    <span class="search-icon" onclick="toggleSearch('userSearch')">
                        <svg viewBox="0 0 24 24">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </span>
                </div>
                <input type="text" class="search-input" id="userSearch" placeholder="Search users..."
                    onkeyup="nym.filterUsers(this.value)">
                <div id="userListContent"></div>
            </div>
        </aside>

        <main class="main-content">
            <header class="chat-header">
                <div class="channel-info">
                    <div>
                        <div class="channel-title" id="currentChannel">#bar</div>
                        <div class="channel-meta" id="channelMeta">0 nyms in channel</div>
                    </div>
                </div>
                <div class="header-actions">
                    <button class="icon-btn" onclick="showChannelModal()">+ Channel</button>
                    <button class="icon-btn" onclick="showSettings()">Settings</button>
                    <button class="icon-btn" onclick="signOut()" title="Signout">Signout</button>
                    <button class="icon-btn" onclick="showAbout()">About</button>
                </div>
            </header>

            <div class="messages-container" id="messagesContainer">
                <div class="system-message">
                    ═══ Welcome to NYM - Ephemeral Nostr Chat ═══<br>
                    Type /help for available commands • Choose your nym to begin
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator"></div>

            <div class="input-container">
                <div class="input-wrapper">
                    <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
                    <div class="emoji-autocomplete" id="emojiAutocomplete"></div>
                    <div class="command-palette" id="commandPalette"></div>
                    <div class="upload-progress" id="uploadProgress">
                        <div>Uploading image...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                    </div>
                    <textarea class="message-input" id="messageInput" placeholder="Type a message or / for commands..."
                        rows="1" disabled></textarea>
                    <div class="char-counter" id="charCounter">0</div>
                </div>
                <div class="input-buttons">
                    <input type="file" class="file-input" id="fileInput" accept="image/*">
                    <button class="icon-btn input-btn" onclick="selectImage()" title="Upload Image">
                        <svg viewBox="0 0 24 24">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                    </button>
                    <button class="icon-btn input-btn" onclick="nym.toggleEmojiPicker()" title="Emoji">
                        <svg viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                            <circle cx="9" cy="9" r="1"></circle>
                            <circle cx="15" cy="9" r="1"></circle>
                        </svg>
                    </button>
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()" disabled>SEND</button>
                </div>
                <div class="emoji-picker" id="emojiPicker"></div>
            </div>
        </main>
    </div>

    <!-- Image Modal -->
    <div class="image-modal" id="imageModal" onclick="closeImageModal()">
        <span class="image-modal-close" onclick="closeImageModal()">×</span>
        <img id="modalImage" src="" alt="Expanded image">
    </div>

    <!-- Nick Edit Modal -->
    <div class="modal nick-edit-modal" id="nickEditModal">
        <div class="modal-content">
            <div class="modal-header">Change Your Nym</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">New Nym</label>
                    <input type="text" class="form-input" id="newNickInput" placeholder="Enter new nym" maxlength="20">
                    <div class="form-hint">Your ephemeral pseudonym for this session</div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="icon-btn" onclick="closeModal('nickEditModal')">Cancel</button>
                <button class="send-btn" onclick="changeNick()">Change</button>
            </div>
        </div>
    </div>

    <!-- Initial Setup Modal -->
    <div class="modal active" id="setupModal">
        <div class="modal-content">
            <div class="modal-header">Welcome to NYM</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Connection Mode</label>
                    <select class="form-select" id="connectionMode">
                        <option value="ephemeral">Ephemeral (Auto-generate temporary keys)</option>
                        <option value="extension">Use Nostr Extension (Persistent identity)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Choose Your Nym (optional)</label>
                    <input type="text" class="form-input" id="nymInput" placeholder="Leave empty for random nym"
                        maxlength="20">
                    <div class="form-hint" id="nymHint">Your ephemeral pseudonym for this session</div>
                </div>

                <div class="form-group">
                    <label class="form-label">Relay Selection</label>
                    <select class="form-select" id="relaySelect">
                        <option value="wss://relay.damus.io">Damus Relay</option>
                        <option value="wss://relay.nostr.band">Nostr.band</option>
                        <option value="wss://nos.lol">Nos.lol</option>
                        <option value="wss://relay.snort.social">Snort Social</option>
                        <option value="wss://nostr.bitcoiner.social">Bitcoiner Social</option>
                        <option value="wss://relay.primal.net">Primal</option>
                        <option value="custom">Custom Relay...</option>
                    </select>
                </div>

                <div class="form-group" id="customRelayGroup" style="display:none">
                    <label class="form-label">Custom Relay URL</label>
                    <input type="text" class="form-input" id="customRelayInput" placeholder="wss://relay.example.com">
                </div>

                <div
                    style="color: var(--warning); font-size: 12px; margin-top: 15px; padding: 10px; border: 1px solid var(--warning);">
                    💬 NYM is for ephemeral, anonymous chat. Messages are public and temporary. Your identity exists
                    only for this session.
                </div>
            </div>
            <div class="modal-actions">
                <button class="send-btn" onclick="initializeNym()">Enter NYM</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">Settings</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Connected Relay</label>
                    <select class="form-select" id="connectedRelaySelect">
                        <option value="wss://relay.damus.io">Damus Relay</option>
                        <option value="wss://relay.nostr.band">Nostr.band</option>
                        <option value="wss://nos.lol">Nos.lol</option>
                        <option value="wss://relay.snort.social">Snort Social</option>
                        <option value="wss://nostr.bitcoiner.social">Bitcoiner Social</option>
                        <option value="wss://relay.primal.net">Primal</option>
                        <option value="custom">Custom...</option>
                    </select>
                    <input type="text" class="form-input" id="customConnectedRelay" placeholder="Custom relay URL"
                        style="display:none; margin-top: 10px;">
                    <button class="icon-btn" onclick="changeRelay()" style="margin-top: 10px; width: 100%;">Change
                        Relay</button>
                </div>

                <div class="form-group">
                    <label class="form-label">Theme</label>
                    <select class="form-select" id="themeSelect">
                        <option value="matrix">Matrix Green</option>
                        <option value="amber">Amber Terminal</option>
                        <option value="cyber">Cyberpunk</option>
                        <option value="hacker">Hacker Blue</option>
                        <option value="ghost">Ghost (B&W)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Notification Sound</label>
                    <select class="form-select" id="soundSelect">
                        <option value="beep">Classic Beep</option>
                        <option value="icq">ICQ Uh-Oh</option>
                        <option value="msn">MSN Alert</option>
                        <option value="none">Silent</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Auto-scroll Messages</label>
                    <select class="form-select" id="autoscrollSelect">
                        <option value="true">Enabled</option>
                        <option value="false">Disabled</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Show Timestamps</label>
                    <select class="form-select" id="timestampSelect">
                        <option value="true">Show</option>
                        <option value="false">Hide</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label">Blocked Keywords/Phrases</label>
                    <input type="text" class="form-input" id="newKeywordInput"
                        placeholder="Add keyword or phrase to block">
                    <button class="icon-btn" onclick="nym.addBlockedKeyword()"
                        style="margin-top: 10px; width: 100%;">Add Keyword</button>
                    <div class="keyword-list" id="keywordList" style="margin-top: 10px;">
                        <div style="color: var(--text-dim); font-size: 12px;">No blocked keywords</div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Blocked Users</label>
                    <div class="blocked-list" id="blockedList">
                        <div style="color: var(--text-dim); font-size: 12px;">No blocked users</div>
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="icon-btn" onclick="closeModal('settingsModal')">Cancel</button>
                <button class="send-btn" onclick="saveSettings()">Save</button>
            </div>
        </div>
    </div>

    <!-- Channel Modal -->
    <div class="modal" id="channelModal">
        <div class="modal-content">
            <div class="modal-header">Join/Create Channel</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Channel Type</label>
                    <select class="form-select" id="channelTypeSelect">
                        <option value="standard">Standard Channel</option>
                        <option value="geohash">Location-based (Geohash)</option>
                    </select>
                </div>

                <div class="form-group" id="standardChannelGroup">
                    <label class="form-label">Channel Name</label>
                    <input type="text" class="form-input" id="channelNameInput" placeholder="random">
                    <div class="form-hint">Enter channel name without # (e.g., "random" for #random)</div>
                </div>

                <div class="form-group" id="geohashGroup" style="display:none">
                    <label class="form-label">Geohash</label>
                    <input type="text" class="form-input" id="geohashInput" placeholder="e.g., w1, dr5r, etc.">
                    <div class="form-hint">Enter a geohash code for location-based channel</div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="icon-btn" onclick="closeModal('channelModal')">Cancel</button>
                <button class="send-btn" onclick="joinChannel()">Join</button>
            </div>
        </div>
    </div>

    <script>
        // NYM - Ephemeral Nostr Chat
        class NYM {
            constructor() {
                this.ws = null;
                this.nosflareWs = null;
                this.pubkey = null;
                this.privkey = null;
                this.nym = null;
                this.currentChannel = 'bar';
                this.currentGeohash = '';
                this.currentPM = null;
                this.messages = new Map();
                this.pmMessages = new Map();
                this.users = new Map();
                this.channelUsers = new Map();
                this.channels = new Map();
                this.pmConversations = new Map();
                this.unreadCounts = new Map();
                this.blockedUsers = new Set();
                this.blockedKeywords = new Set();
                this.settings = this.loadSettings();
                this.commandHistory = [];
                this.historyIndex = -1;
                this.relayUrl = null;
                this.connected = false;
                this.messageQueue = [];
                this.autocompleteIndex = -1;
                this.commandPaletteIndex = -1;
                this.emojiAutocompleteIndex = -1;
                this.commonChannels = ['bar', 'random', 'nostr', 'bitcoin', 'tech', 'music', 'gaming'];
                this.commonGeohashes = ['w1', 'w2', 'dr5r', '9q8y', 'u4pr'];
                this.inPMMode = false;
                this.userSearchTerm = '';
                this.geohashRegex = /^[0-9bcdefghjkmnpqrstuvwxyz]{1,12}$/;
                this.pinnedChannels = new Set();
                this.reactions = new Map(); // messageId -> Map(emoji -> Set(pubkeys))
                this.floodTracking = new Map(); // pubkey -> { count, firstMessageTime, blocked }
                this.activeReactionPicker = null;
                this.activeReactionPickerButton = null;  // Add this line
                this.usingExtension = false;
                this.emojiMap = {
                    'smile': '😊', 'laugh': '😂', 'heart': '❤️', 'thumbsup': '👍', 'fire': '🔥',
                    'party': '🎉', 'eyes': '👀', 'thinking': '🤔', 'cry': '😢', 'cool': '😎',
                    'rocket': '🚀', 'beer': '🍺', 'coffee': '☕', 'pizza': '🍕', 'wave': '👋',
                    'rofl': '🤣', 'thumbsdown': '👎', 'clap': '👏', '100': '💯', 'star': '🌟',
                    'lightning': '⚡', 'target': '🎯', 'bulb': '💡', 'robot': '🤖', 'ghost': '👻',
                    'mask': '🎭', 'rainbow': '🌈', 'gaming': '🎮', 'sparkles': '✨', 'computer': '💻',
                    'shocked': '😮', 'wink': '😉', 'kiss': '😘', 'angry': '😠', 'sad': '😢',
                    'happy': '😊', 'neutral': '😐', 'confused': '😕', 'sleeping': '😴', 'sick': '🤢'
                };
            }

            isValidGeohash(str) {
                return this.geohashRegex.test(str.toLowerCase());
            }

            getChannelType(channel) {
                if (this.isValidGeohash(channel)) {
                    return 'geo';
                }
                return 'standard';
            }

            handleChannelSearch(searchTerm) {
                const term = searchTerm.toLowerCase();
                const resultsDiv = document.getElementById('channelSearchResults');

                // Filter existing channels
                this.filterChannels(term);

                // Show create/join prompt if search term exists
                if (term.length > 0) {
                    const isGeohash = this.isValidGeohash(term);
                    const type = isGeohash ? 'geohash' : 'channel';
                    const exists = Array.from(this.channels.keys()).some(k => k.toLowerCase() === term);

                    if (!exists) {
                        const prompt = document.createElement('div');
                        prompt.className = 'search-create-prompt';
                        prompt.innerHTML = `Create or Join ${type} "${term}"`;
                        prompt.onclick = () => {
                            if (isGeohash) {
                                this.cmdJoin('#' + term);
                            } else {
                                this.cmdJoin(term);
                            }
                            document.getElementById('channelSearch').value = '';
                            resultsDiv.innerHTML = '';
                            this.filterChannels('');
                        };
                        resultsDiv.innerHTML = '';
                        resultsDiv.appendChild(prompt);
                    } else {
                        resultsDiv.innerHTML = '';
                    }
                } else {
                    resultsDiv.innerHTML = '';
                }
            }

            async initialize() {
                try {
                    // Check if nostr-tools is loaded
                    if (typeof window.NostrTools === 'undefined') {
                        throw new Error('nostr-tools not loaded');
                    }

                    // Setup event listeners
                    this.setupEventListeners();
                    this.setupCommands();
                    this.setupEmojiPicker();

                    // Load saved preferences
                    this.applyTheme(this.settings.theme);
                    this.loadBlockedUsers();
                    this.loadBlockedKeywords();
                    this.loadPinnedChannels();

                    console.log('NYM initialized successfully');
                } catch (error) {
                    console.error('Failed to initialize NYM:', error);
                    this.showNotification('Error', 'Failed to initialize: ' + error.message);
                }
            }

            loadBlockedKeywords() {
                const saved = localStorage.getItem('nym_blocked_keywords');
                if (saved) {
                    this.blockedKeywords = new Set(JSON.parse(saved));
                }
                this.updateKeywordList();
            }

            saveBlockedKeywords() {
                localStorage.setItem('nym_blocked_keywords', JSON.stringify(Array.from(this.blockedKeywords)));
            }

            addBlockedKeyword() {
                const input = document.getElementById('newKeywordInput');
                const keyword = input.value.trim().toLowerCase();

                if (keyword) {
                    this.blockedKeywords.add(keyword);
                    this.saveBlockedKeywords();
                    this.updateKeywordList();
                    input.value = '';

                    // Hide messages containing this keyword
                    document.querySelectorAll('.message').forEach(msg => {
                        const content = msg.querySelector('.message-content');
                        if (content && content.textContent.toLowerCase().includes(keyword)) {
                            msg.classList.add('blocked');
                        }
                    });

                    this.displaySystemMessage(`Blocked keyword: "${keyword}"`);
                }
            }

            removeBlockedKeyword(keyword) {
                this.blockedKeywords.delete(keyword);
                this.saveBlockedKeywords();
                this.updateKeywordList();

                // Re-check all messages
                document.querySelectorAll('.message').forEach(msg => {
                    const author = msg.dataset.author;
                    const content = msg.querySelector('.message-content');

                    if (content && !this.blockedUsers.has(author)) {
                        const hasBlockedKeyword = Array.from(this.blockedKeywords).some(kw =>
                            content.textContent.toLowerCase().includes(kw)
                        );

                        if (!hasBlockedKeyword) {
                            msg.classList.remove('blocked');
                        }
                    }
                });

                this.displaySystemMessage(`Unblocked keyword: "${keyword}"`);
            }

            updateKeywordList() {
                const list = document.getElementById('keywordList');
                if (this.blockedKeywords.size === 0) {
                    list.innerHTML = '<div style="color: var(--text-dim); font-size: 12px;">No blocked keywords</div>';
                } else {
                    list.innerHTML = Array.from(this.blockedKeywords).map(keyword => `
                        <div class="keyword-item">
                            <span>${this.escapeHtml(keyword)}</span>
                            <button class="remove-keyword-btn" onclick="nym.removeBlockedKeyword('${this.escapeHtml(keyword).replace(/'/g, "\\'")}')">Remove</button>
                        </div>
                    `).join('');
                }
            }

            hasBlockedKeyword(text) {
                const lowerText = text.toLowerCase();
                return Array.from(this.blockedKeywords).some(keyword => lowerText.includes(keyword));
            }

            generateRandomNym() {
                const adjectives = ['cosmic', 'neon', 'cyber', 'shadow', 'plasma', 'quantum', 'echo', 'nexus', 'void', 'flux'];
                const nouns = ['ghost', 'nomad', 'drift', 'pulse', 'wave', 'spark', 'node', 'byte', 'mesh', 'link'];
                const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
                const noun = nouns[Math.floor(Math.random() * nouns.length)];
                const num = Math.floor(Math.random() * 999);
                return `${adj}_${noun}_${num}`;
            }

            async connectToRelay(relayUrl) {
                return new Promise((resolve, reject) => {
                    try {
                        // Close existing connection if any
                        if (this.ws) {
                            this.ws.close();
                        }

                        this.updateConnectionStatus('Connecting...');
                        this.relayUrl = relayUrl;

                        this.ws = new WebSocket(relayUrl);

                        this.ws.onopen = () => {
                            this.connected = true;
                            this.updateConnectionStatus('Connected');
                            this.displaySystemMessage(`Connected to ${relayUrl}`);
                            this.subscribeToMessages();
                            this.loadHistoricalMessages();
                            this.subscribeToPMs();
                            this.subscribeToReactions();
                            this.discoverChannels();

                            // Load synced settings if using extension
                            if (this.usingExtension) {
                                this.loadSyncedSettings();
                            }

                            // Enable input
                            document.getElementById('messageInput').disabled = false;
                            document.getElementById('sendBtn').disabled = false;

                            // Process queued messages
                            while (this.messageQueue.length > 0) {
                                const msg = this.messageQueue.shift();
                                this.ws.send(msg);
                            }

                            resolve();
                        };

                        this.ws.onmessage = (event) => {
                            try {
                                const msg = JSON.parse(event.data);
                                this.handleRelayMessage(msg);
                            } catch (e) {
                                console.error('Failed to parse message:', e);
                            }
                        };

                        this.ws.onerror = (error) => {
                            console.error('WebSocket error:', error);
                            this.updateConnectionStatus('Error');
                            reject(error);
                        };

                        this.ws.onclose = () => {
                            this.connected = false;
                            this.updateConnectionStatus('Disconnected');
                            this.displaySystemMessage('Disconnected from relay');
                            document.getElementById('messageInput').disabled = true;
                            document.getElementById('sendBtn').disabled = true;

                            // Try to reconnect after 5 seconds
                            setTimeout(() => {
                                if (!this.connected) {
                                    this.connectToRelay(this.relayUrl);
                                }
                            }, 5000);
                        };

                    } catch (error) {
                        console.error('Connection failed:', error);
                        this.updateConnectionStatus('Connection Failed');
                        reject(error);
                    }
                });
            }

            subscribeToMessages() {
                // Subscribe to both ephemeral and channel messages
                const subscription = [
                    "REQ",
                    "nym-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [20000, 23333], // Geohash and standard channels
                        limit: 200
                    }
                ];

                this.sendToRelay(subscription);
            }

            subscribeToReactions() {
                // Subscribe to reactions (NIP-25) with broader filter
                const subscription = [
                    "REQ",
                    "reactions-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [7], // Reaction events
                        limit: 1000, // Increase limit for more reactions
                        since: Math.floor(Date.now() / 1000) - 7200 // Last 2 hours
                    }
                ];

                this.sendToRelay(subscription);

                // Also subscribe to reactions tagged to our pubkey
                if (this.pubkey) {
                    const userReactionsSubscription = [
                        "REQ",
                        "user-reactions-" + Math.random().toString(36).substring(7),
                        {
                            kinds: [7],
                            "#p": [this.pubkey], // Reactions to our messages
                            limit: 500
                        }
                    ];

                    this.sendToRelay(userReactionsSubscription);
                }
            }

            subscribeToPMs() {
                if (!this.pubkey) return;

                // Subscribe to NIP-17 private messages
                const subscription = [
                    "REQ",
                    "pms-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [1059], // NIP-17 gift wrap
                        "#p": [this.pubkey],
                        limit: 100
                    }
                ];

                this.sendToRelay(subscription);

                // Also subscribe to messages FROM us
                const sentSubscription = [
                    "REQ",
                    "pms-sent-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [1059], // NIP-17 gift wrap
                        authors: [this.pubkey],
                        limit: 100
                    }
                ];

                this.sendToRelay(sentSubscription);

                // Legacy NIP-04 support for compatibility
                const legacySubscription = [
                    "REQ",
                    "pms-legacy-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [4], // NIP-04 encrypted direct messages
                        "#p": [this.pubkey],
                        limit: 50
                    }
                ];

                this.sendToRelay(legacySubscription);
            }

            loadHistoricalMessages() {
                // Request recent messages with both since and until
                const now = Math.floor(Date.now() / 1000);
                const since = now - 7200; // 2 hours ago

                const subscription = [
                    "REQ",
                    "history-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [20000, 23333, 7], // Include reactions
                        since: since,
                        until: now,
                        limit: 500
                    }
                ];

                this.sendToRelay(subscription);
            }

            async loadSyncedSettings() {
                if (!this.pubkey || !this.usingExtension) return;

                // Request NIP-78 settings (kind 30078)
                const subscription = [
                    "REQ",
                    "settings-" + Math.random().toString(36).substring(7),
                    {
                        kinds: [30078],
                        authors: [this.pubkey],
                        limit: 1
                    }
                ];

                this.sendToRelay(subscription);
            }

            async saveSyncedSettings() {
                if (!this.pubkey || !this.usingExtension) return;

                try {
                    const settingsData = {
                        theme: this.settings.theme,
                        sound: this.settings.sound,
                        autoscroll: this.settings.autoscroll,
                        showTimestamps: this.settings.showTimestamps,
                        pinnedChannels: Array.from(this.pinnedChannels),
                        blockedUsers: Array.from(this.blockedUsers),
                        blockedKeywords: Array.from(this.blockedKeywords)
                    };

                    const event = {
                        kind: 30078,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ["d", "nym-settings"],
                            ["title", "NYM Settings"]
                        ],
                        content: JSON.stringify(settingsData),
                        pubkey: this.pubkey
                    };

                    // Sign event
                    let signedEvent;
                    if (window.nostr) {
                        signedEvent = await window.nostr.signEvent(event);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                    }

                    if (signedEvent) {
                        this.sendToRelay(["EVENT", signedEvent]);
                    }
                } catch (error) {
                    console.error('Failed to save synced settings:', error);
                }
            }

            discoverChannels() {
                // Mix standard channels and geohashes randomly
                const allChannels = [];

                // Add standard channels
                this.commonChannels.forEach(channel => {
                    allChannels.push({ name: channel, geohash: '', type: 'standard' });
                });

                // Add geohash channels
                this.commonGeohashes.forEach(geohash => {
                    allChannels.push({ name: geohash, geohash: geohash, type: 'geo' });
                });

                // Shuffle all channels except bar
                const bar = allChannels.shift(); // Remove bar
                for (let i = allChannels.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allChannels[i], allChannels[j]] = [allChannels[j], allChannels[i]];
                }

                // Add bar back at the beginning
                allChannels.unshift(bar);

                // Add channels to UI
                allChannels.forEach(channel => {
                    if (!this.channels.has(channel.name)) {
                        this.addChannel(channel.name, channel.geohash);
                    }
                });
            }

            sendToRelay(message) {
                const msg = JSON.stringify(message);

                // Send to primary relay
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(msg);
                } else {
                    this.messageQueue.push(msg);
                }

                // Also send EVENT messages to Nosflare blaster relay 
                if (Array.isArray(message) && message[0] === 'EVENT') {
                    this.sendToNosflare(message);
                }
            }

            sendToNosflare(message) {
                // Create a separate connection to Nosflare
                if (!this.nosflareWs || this.nosflareWs.readyState !== WebSocket.OPEN) {
                    this.nosflareWs = new WebSocket('wss://sendit.nosflare.com');

                    this.nosflareWs.onopen = () => {
                        // Send the queued message once connected
                        this.nosflareWs.send(JSON.stringify(message));
                    };

                    this.nosflareWs.onerror = (error) => {
                        console.error('Nosflare relay error:', error);
                    };

                    this.nosflareWs.onmessage = () => { };

                    this.nosflareWs.onclose = () => {
                        this.nosflareWs = null;
                    };
                } else {
                    // Connection already open, send immediately
                    this.nosflareWs.send(JSON.stringify(message));
                }
            }

            handleRelayMessage(msg) {
                if (!Array.isArray(msg)) return;

                const [type, ...data] = msg;

                switch (type) {
                    case 'EVENT':
                        const [subscriptionId, event] = data;
                        this.handleEvent(event);
                        break;
                    case 'OK':
                        // Event was accepted
                        break;
                    case 'EOSE':
                        // End of stored events
                        break;
                    case 'NOTICE':
                        const notice = data[0];
                        this.displaySystemMessage(`Relay notice: ${notice}`);
                        break;
                }
            }

            async handleEvent(event) {
                // Determine if this is a historical message
                const now = Math.floor(Date.now() / 1000);
                const messageAge = now - event.created_at;
                const isHistorical = messageAge > 60; // Messages older than 1 minute are considered historical

                if (event.kind === 20000) {
                    // Handle geohash channel messages
                    const nymTag = event.tags.find(t => t[0] === 'n');
                    const geohashTag = event.tags.find(t => t[0] === 'g');

                    const nym = nymTag ? nymTag[1] : this.getNymFromPubkey(event.pubkey);
                    const geohash = geohashTag ? geohashTag[1] : '';

                    // Check if user is blocked or message contains blocked keywords
                    if (this.blockedUsers.has(nym) || this.hasBlockedKeyword(event.content)) {
                        return;
                    }

                    // Check flooding only for non-historical messages
                    if (!isHistorical && this.isFlooding(event.pubkey)) {
                        return;
                    }

                    // Only track flood for new messages, not historical
                    if (!isHistorical) {
                        this.trackMessage(event.pubkey, false);
                    }

                    // Add channel if it's new
                    if (geohash && !this.channels.has(geohash)) {
                        this.addChannelToList(geohash, geohash);
                    }

                    const message = {
                        id: event.id,
                        author: nym,
                        pubkey: event.pubkey,
                        content: event.content,
                        timestamp: new Date(event.created_at * 1000),
                        channel: geohash ? geohash : 'unknown',
                        geohash: geohash,
                        isOwn: event.pubkey === this.pubkey
                    };

                    // Don't display duplicate of own messages
                    if (!this.isDuplicateMessage(message)) {
                        this.displayMessage(message);
                        this.updateUserPresence(nym, event.pubkey, message.channel, geohash);

                        // Show notification only if mentioned and not blocked
                        if (!message.isOwn && document.hidden && this.isMentioned(message.content) && !this.blockedUsers.has(nym)) {
                            this.showNotification(nym, message.content);
                        }
                    }
                } else if (event.kind === 23333) {
                    // Handle standard channel messages
                    const nymTag = event.tags.find(t => t[0] === 'n');
                    const channelTag = event.tags.find(t => t[0] === 'd');

                    const nym = nymTag ? nymTag[1] : this.getNymFromPubkey(event.pubkey);
                    const channel = channelTag ? channelTag[1] : 'bar';

                    // Check if user is blocked or message contains blocked keywords
                    if (this.blockedUsers.has(nym) || this.hasBlockedKeyword(event.content)) {
                        return;
                    }

                    // Check flooding only for non-historical messages
                    if (!isHistorical && this.isFlooding(event.pubkey)) {
                        return;
                    }

                    // Only track flood for new messages, not historical
                    if (!isHistorical) {
                        this.trackMessage(event.pubkey, false);
                    }

                    // Add channel if it's new
                    if (!this.channels.has(channel)) {
                        this.addChannelToList(channel, '');
                    }

                    const message = {
                        id: event.id,
                        author: nym,
                        pubkey: event.pubkey,
                        content: event.content,
                        timestamp: new Date(event.created_at * 1000),
                        channel: channel,
                        geohash: '',
                        isOwn: event.pubkey === this.pubkey
                    };

                    // Don't display duplicate of own messages
                    if (!this.isDuplicateMessage(message)) {
                        this.displayMessage(message);
                        this.updateUserPresence(nym, event.pubkey, channel, '');

                        // Show notification only if mentioned and not blocked
                        if (!message.isOwn && document.hidden && this.isMentioned(message.content) && !this.blockedUsers.has(nym)) {
                            this.showNotification(nym, message.content);
                        }
                    }
                } else if (event.kind === 7) {
                    // Handle reactions (NIP-25) - no flood protection for reactions
                    this.handleReaction(event);
                } else if (event.kind === 1059) {
                    // Handle NIP-17 gift wrap - no flood protection for PMs
                    await this.handleNIP17GiftWrap(event);
                } else if (event.kind === 4) {
                    // Handle legacy NIP-04 encrypted DMs - no flood protection for PMs
                    await this.handleEncryptedDM(event);
                } else if (event.kind === 30078) {
                    // Handle synced settings - no flood protection
                    this.handleSyncedSettings(event);
                }
            }

            handleSyncedSettings(event) {
                if (event.pubkey !== this.pubkey) return;

                try {
                    const settings = JSON.parse(event.content);

                    // Apply synced settings
                    if (settings.theme) {
                        this.settings.theme = settings.theme;
                        this.applyTheme(settings.theme);
                    }
                    if (settings.sound !== undefined) {
                        this.settings.sound = settings.sound;
                    }
                    if (settings.autoscroll !== undefined) {
                        this.settings.autoscroll = settings.autoscroll;
                    }
                    if (settings.showTimestamps !== undefined) {
                        this.settings.showTimestamps = settings.showTimestamps;
                    }
                    if (settings.pinnedChannels) {
                        this.pinnedChannels = new Set(settings.pinnedChannels);
                        this.updateChannelPins();
                    }
                    if (settings.blockedUsers) {
                        this.blockedUsers = new Set(settings.blockedUsers);
                        this.updateBlockedList();
                    }
                    if (settings.blockedKeywords) {
                        this.blockedKeywords = new Set(settings.blockedKeywords);
                        this.updateKeywordList();
                    }

                    this.saveSettings();
                    this.displaySystemMessage('Settings synced from Nostr');
                } catch (error) {
                    console.error('Failed to parse synced settings:', error);
                }
            }

            handleReaction(event) {
                const reactionContent = event.content;
                const eTag = event.tags.find(t => t[0] === 'e');

                if (!eTag) return;

                const messageId = eTag[1];
                const reactorNym = this.getNymFromPubkey(event.pubkey);

                // Store reaction with pubkey and nym
                if (!this.reactions.has(messageId)) {
                    this.reactions.set(messageId, new Map());
                }

                const messageReactions = this.reactions.get(messageId);
                if (!messageReactions.has(reactionContent)) {
                    messageReactions.set(reactionContent, new Map()); // Map of pubkey -> nym
                }

                // Store pubkey with nym
                messageReactions.get(reactionContent).set(event.pubkey, reactorNym);

                // Update UI if message is visible
                this.updateMessageReactions(messageId);
            }

            updateMessageReactions(messageId) {
                const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
                if (!messageEl) return;

                const reactions = this.reactions.get(messageId);
                if (!reactions || reactions.size === 0) return;

                // Remove existing reactions display
                let reactionsRow = messageEl.querySelector('.reactions-row');
                if (!reactionsRow) {
                    reactionsRow = document.createElement('div');
                    reactionsRow.className = 'reactions-row';
                    messageEl.appendChild(reactionsRow);
                }

                // Clear and rebuild reactions
                reactionsRow.innerHTML = '';
                reactions.forEach((reactors, emoji) => {
                    const badge = document.createElement('span');

                    // Check if current user has already reacted with this emoji
                    const hasReacted = reactors.has(this.pubkey);

                    // Set class based on reaction state
                    badge.className = hasReacted ? 'reaction-badge user-reacted' : 'reaction-badge';
                    badge.dataset.emoji = emoji;
                    badge.dataset.messageId = messageId;

                    badge.innerHTML = `${emoji} ${reactors.size}`;

                    // Create tooltip with user names
                    if (hasReacted) {
                        const otherUsers = Array.from(reactors.entries())
                            .filter(([pk, nym]) => pk !== this.pubkey)
                            .map(([pk, nym]) => nym);
                        badge.title = otherUsers.length > 0 ?
                            `You and ${otherUsers.join(', ')}` :
                            'You reacted with this';
                    } else {
                        const users = Array.from(reactors.values()).join(', ');
                        badge.title = `Click to also react with ${emoji} | ${users}`;
                    }

                    // Add click handler that updates badge immediately
                    badge.onclick = async (e) => {
                        e.stopPropagation();
                        if (!hasReacted) {
                            // Immediately update the badge visual state
                            badge.className = 'reaction-badge user-reacted';
                            badge.style.background = 'rgba(0, 255, 0, 0.2)';
                            badge.style.borderColor = 'var(--primary)';
                            badge.style.boxShadow = '0 0 5px rgba(0, 255, 0, 0.3)';

                            // Update count
                            const newCount = reactors.size + 1;
                            badge.innerHTML = `${emoji} ${newCount}`;

                            // Send the reaction
                            await this.sendReaction(messageId, emoji);
                        } else {
                            this.displaySystemMessage(`You already reacted with ${emoji}`);
                        }
                    };

                    reactionsRow.appendChild(badge);
                });
            }

            async sendReaction(messageId, emoji) {
                try {
                    // Find the original message element to get the pubkey
                    const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
                    if (!messageEl) {
                        console.error('Message element not found');
                        return;
                    }

                    const targetPubkey = messageEl.dataset.pubkey;
                    if (!targetPubkey) {
                        console.error('Could not find target pubkey');
                        return;
                    }

                    // Update local reactions state
                    if (!this.reactions.has(messageId)) {
                        this.reactions.set(messageId, new Map());
                    }
                    const messageReactions = this.reactions.get(messageId);
                    if (!messageReactions.has(emoji)) {
                        messageReactions.set(emoji, new Map());
                    }

                    // Check if already reacted
                    if (messageReactions.get(emoji).has(this.pubkey)) {
                        return; // Already reacted, badge was updated in onclick
                    }

                    // Add current user's reaction to state
                    messageReactions.get(emoji).set(this.pubkey, this.nym);

                    // Send to relay
                    const event = {
                        kind: 7,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['e', messageId],
                            ['p', targetPubkey],
                            ['k', '23333']
                        ],
                        content: emoji,
                        pubkey: this.pubkey
                    };

                    // Sign event
                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        signedEvent = await window.nostr.signEvent(event);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                    }

                    if (signedEvent) {
                        this.sendToRelay(["EVENT", signedEvent]);
                    } else {
                        // If signing failed, revert the visual update
                        messageReactions.get(emoji).delete(this.pubkey);
                        this.updateMessageReactions(messageId);
                        this.displaySystemMessage('Failed to sign reaction');
                    }
                } catch (error) {
                    console.error('Failed to send reaction:', error);
                    // Revert on error
                    const messageReactions = this.reactions.get(messageId);
                    if (messageReactions && messageReactions.has(emoji)) {
                        messageReactions.get(emoji).delete(this.pubkey);
                        this.updateMessageReactions(messageId);
                    }
                }
            }

            trackMessage(pubkey, isHistorical = false) {
                // Don't track historical messages or reactions
                if (isHistorical) return;

                const now = Date.now();

                if (!this.floodTracking.has(pubkey)) {
                    this.floodTracking.set(pubkey, {
                        count: 1,
                        firstMessageTime: now,
                        blocked: false
                    });
                    return;
                }

                const tracking = this.floodTracking.get(pubkey);

                // Reset if more than 2 seconds have passed
                if (now - tracking.firstMessageTime > 2000) {
                    tracking.count = 1;
                    tracking.firstMessageTime = now;
                    tracking.blocked = false;
                } else {
                    tracking.count++;

                    // Block if more than 10 messages in 2 seconds
                    if (tracking.count > 10 && !tracking.blocked) {
                        tracking.blocked = true;
                        tracking.blockedUntil = now + 900000; // 15 minutes

                        const nym = this.getNymFromPubkey(pubkey);
                        this.displaySystemMessage(`${nym} has been temporarily muted for flooding (15 minutes)`);
                    }
                }
            }

            isFlooding(pubkey) {
                const tracking = this.floodTracking.get(pubkey);
                if (!tracking) return false;

                if (tracking.blocked) {
                    const now = Date.now();
                    if (now < tracking.blockedUntil) {
                        return true;
                    } else {
                        // Unblock after timeout
                        tracking.blocked = false;
                        tracking.blockedUntil = null;
                    }
                }

                return false;
            }

            async handleNIP17GiftWrap(event) {
                try {
                    // Decrypt the gift wrap
                    let unwrapped;
                    if (window.nostr && !this.privkey) {
                        unwrapped = await window.nostr.nip44.decrypt(event.pubkey, event.content);
                    } else if (this.privkey) {
                        // Use NIP-44 decryption
                        unwrapped = await this.decryptNIP44(event.content, event.pubkey, this.privkey);
                    }

                    if (!unwrapped) return;

                    const innerEvent = JSON.parse(unwrapped);

                    // Process the inner event as a PM
                    const conversationPubkey = innerEvent.pubkey === this.pubkey ?
                        innerEvent.tags.find(t => t[0] === 'p')?.[1] :
                        innerEvent.pubkey;

                    if (!conversationPubkey) return;

                    const conversationKey = this.getPMConversationKey(conversationPubkey);
                    const senderNym = this.getNymFromPubkey(innerEvent.pubkey);

                    // Check if sender is blocked
                    if (this.blockedUsers.has(senderNym)) {
                        return;
                    }

                    if (!this.pmMessages.has(conversationKey)) {
                        this.pmMessages.set(conversationKey, []);
                    }

                    // Add PM conversation if not exists
                    if (!this.pmConversations.has(conversationPubkey)) {
                        this.addPMConversation(senderNym, conversationPubkey);
                    }

                    const pmMessage = {
                        id: innerEvent.id || event.id,
                        author: senderNym,
                        pubkey: innerEvent.pubkey,
                        content: innerEvent.content,
                        timestamp: new Date(innerEvent.created_at * 1000),
                        isOwn: innerEvent.pubkey === this.pubkey,
                        isPM: true,
                        conversationKey: conversationKey,
                        conversationPubkey: conversationPubkey
                    };

                    this.pmMessages.get(conversationKey).push(pmMessage);
                    this.pmMessages.get(conversationKey).sort((a, b) => a.timestamp - b.timestamp);

                    // Display if in PM mode with this user
                    if (this.inPMMode && this.currentPM === conversationPubkey) {
                        this.displayMessage(pmMessage);
                    } else if (!pmMessage.isOwn) {
                        // Update unread count for incoming messages
                        this.updateUnreadCount(conversationKey);
                        // Show notification
                        if (document.hidden || !this.inPMMode || this.currentPM !== conversationPubkey) {
                            this.showNotification(`PM from ${senderNym}`, innerEvent.content);
                        }
                    }

                } catch (error) {
                    console.error('Failed to handle NIP-17 gift wrap:', error);
                }
            }

            async decryptNIP44(content, pubkey, privkey) {
                try {
                    return null;
                } catch (error) {
                    console.error('NIP-44 decryption failed:', error);
                    return null;
                }
            }

            async handleEncryptedDM(event) {
                try {
                    // Only process kind 4 events
                    if (event.kind !== 4) return;

                    // Find the p tag to see who the message is for/from
                    const pTag = event.tags.find(t => t[0] === 'p');
                    if (!pTag) return;

                    const otherPubkey = pTag[1];

                    // Determine if this is a message TO us or FROM us
                    let conversationPubkey;
                    let isIncoming = false;

                    if (otherPubkey === this.pubkey && event.pubkey !== this.pubkey) {
                        // Message is TO us from someone else
                        isIncoming = true;
                        conversationPubkey = event.pubkey;
                    } else if (event.pubkey === this.pubkey && otherPubkey !== this.pubkey) {
                        // Message is FROM us to someone else
                        isIncoming = false;
                        conversationPubkey = otherPubkey;
                    } else {
                        // Message is not part of our conversations, ignore
                        return;
                    }

                    // Create conversation key for this PM pair
                    const conversationKey = this.getPMConversationKey(conversationPubkey);

                    // Check if we already have this exact message (prevent duplicates)
                    const existingMessages = this.pmMessages.get(conversationKey) || [];
                    const exists = existingMessages.some(m => m.id === event.id);
                    if (exists) return; // Skip if already processed

                    // For outgoing messages, check if we just sent this (within last 5 seconds)
                    if (!isIncoming) {
                        const recentlySent = existingMessages.some(m =>
                            m.isOwn &&
                            m.content === event.content &&
                            Math.abs(new Date(event.created_at * 1000) - m.timestamp) < 5000
                        );
                        if (recentlySent) return; // Skip our own recently sent message
                    }

                    // Decrypt the message
                    let decryptedContent;
                    try {
                        if (window.nostr && !this.privkey) {
                            // Use extension to decrypt
                            decryptedContent = await window.nostr.nip04.decrypt(
                                conversationPubkey,
                                event.content
                            );
                        } else if (this.privkey) {
                            // Use local keys to decrypt
                            decryptedContent = await this.decryptNIP04(
                                event.content,
                                conversationPubkey,
                                this.privkey
                            );
                        } else {
                            return;
                        }
                    } catch (err) {
                        console.error('Failed to decrypt PM:', err);
                        return;
                    }

                    if (!decryptedContent) return;

                    // Extract nym from the decrypted content if it contains a nym tag
                    let senderNym;
                    let actualContent = decryptedContent;
                    try {
                        // Check if the decrypted content has embedded nym info
                        const contentData = JSON.parse(decryptedContent);
                        if (contentData.nym) {
                            senderNym = contentData.nym;
                            actualContent = contentData.content;
                        } else {
                            senderNym = this.getNymFromPubkey(event.pubkey);
                        }
                    } catch {
                        // If not JSON, use the content as-is
                        senderNym = this.getNymFromPubkey(event.pubkey);
                    }

                    // For our own messages from relay, skip if we already have it locally
                    if (!isIncoming) {
                        const duplicateOwn = existingMessages.some(m =>
                            m.isOwn &&
                            m.content === actualContent
                        );
                        if (duplicateOwn) return; // Skip duplicate of our own message
                    }

                    // Update user tracking with the nym
                    if (!this.users.has(event.pubkey) || this.users.get(event.pubkey).nym.startsWith('anon-')) {
                        this.users.set(event.pubkey, {
                            nym: senderNym,
                            pubkey: event.pubkey,
                            lastSeen: Date.now(),
                            status: 'online',
                            channels: new Set()
                        });
                    }

                    // Check if sender is blocked
                    if (isIncoming && this.blockedUsers.has(senderNym)) {
                        return;
                    }

                    if (!this.pmMessages.has(conversationKey)) {
                        this.pmMessages.set(conversationKey, []);
                    }

                    // Add PM conversation if not exists
                    if (!this.pmConversations.has(conversationPubkey)) {
                        const otherNym = isIncoming ? senderNym : this.getNymFromPubkey(conversationPubkey);
                        this.addPMConversation(otherNym, conversationPubkey);
                    }

                    // Only add the message from relay if it's incoming OR if we don't have it yet
                    if (isIncoming) {
                        const pmMessage = {
                            id: event.id,
                            author: senderNym,
                            pubkey: event.pubkey,
                            content: actualContent,
                            timestamp: new Date(event.created_at * 1000),
                            isOwn: false,
                            isPM: true,
                            conversationKey: conversationKey,
                            conversationPubkey: conversationPubkey
                        };

                        this.pmMessages.get(conversationKey).push(pmMessage);

                        // Sort messages by timestamp
                        this.pmMessages.get(conversationKey).sort((a, b) => a.timestamp - b.timestamp);

                        // Display if in PM mode with this user
                        if (this.inPMMode && this.currentPM === conversationPubkey) {
                            this.displayMessage(pmMessage);
                        } else {
                            // Update unread count for incoming messages
                            this.updateUnreadCount(conversationKey);
                            // Show notification
                            if (document.hidden || !this.inPMMode || this.currentPM !== conversationPubkey) {
                                this.showNotification(`PM from ${senderNym}`, actualContent);
                            }
                        }
                    }

                } catch (error) {
                    console.error('Failed to handle encrypted DM:', error);
                }
            }

            async decryptNIP04(content, pubkey, privkey) {
                try {
                    // Use nostr-tools nip04 decrypt function
                    if (typeof window.NostrTools.nip04 !== 'undefined') {
                        const decrypted = await window.NostrTools.nip04.decrypt(privkey, pubkey, content);
                        return decrypted;
                    }

                    // Fallback: Parse the encrypted content
                    const [ciphertext, iv] = content.split('?iv=');
                    if (!iv) throw new Error('Invalid encrypted format');

                    // Convert hex privkey to Uint8Array if needed
                    let privkeyBytes;
                    if (typeof privkey === 'string') {
                        privkeyBytes = new Uint8Array(privkey.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    } else {
                        privkeyBytes = privkey;
                    }

                    // Convert hex pubkey to Uint8Array
                    const pubkeyBytes = new Uint8Array(pubkey.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

                    // Generate shared secret using secp256k1
                    // Since we're using nostr-tools, we can use its internal functions
                    const sharedPoint = window.NostrTools.getSharedSecret(privkeyBytes, '02' + pubkey);
                    const sharedSecret = sharedPoint.substring(2, 66);

                    // Derive key using SHA-256
                    const encoder = new TextEncoder();
                    const sharedSecretBytes = new Uint8Array(sharedSecret.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    const keyMaterial = await crypto.subtle.importKey(
                        'raw',
                        sharedSecretBytes,
                        { name: 'HKDF' },
                        false,
                        ['deriveKey']
                    );

                    // Derive AES key
                    const aesKey = await crypto.subtle.deriveKey(
                        {
                            name: 'HKDF',
                            salt: new Uint8Array(0),
                            info: encoder.encode('nip04-v1'),
                            hash: 'SHA-256'
                        },
                        keyMaterial,
                        { name: 'AES-CBC', length: 256 },
                        false,
                        ['decrypt']
                    );

                    // Decode base64 ciphertext and IV
                    const ciphertextBytes = Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0));
                    const ivBytes = Uint8Array.from(atob(iv), c => c.charCodeAt(0));

                    // Decrypt
                    const decryptedBytes = await crypto.subtle.decrypt(
                        { name: 'AES-CBC', iv: ivBytes },
                        aesKey,
                        ciphertextBytes
                    );

                    // Convert to string
                    const decoder = new TextDecoder();
                    return decoder.decode(decryptedBytes);

                } catch (error) {
                    console.error('NIP-04 decryption failed:', error);

                    // Try a simpler approach if nostr-tools methods are available
                    try {
                        if (window.NostrTools && window.NostrTools.nip04) {
                            return await window.NostrTools.nip04.decrypt(privkey, pubkey, content);
                        }
                    } catch (fallbackError) {
                        console.error('Fallback decryption also failed:', fallbackError);
                    }

                    return null;
                }
            }

            async encryptNIP04(content, pubkey, privkey) {
                try {
                    // Use nostr-tools nip04 encrypt function
                    if (typeof window.NostrTools.nip04 !== 'undefined') {
                        const encrypted = await window.NostrTools.nip04.encrypt(privkey, pubkey, content);
                        return encrypted;
                    }

                    // Fallback: Manual implementation
                    // Convert hex privkey to Uint8Array if needed
                    let privkeyBytes;
                    if (typeof privkey === 'string') {
                        privkeyBytes = new Uint8Array(privkey.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    } else {
                        privkeyBytes = privkey;
                    }

                    // Convert hex pubkey to Uint8Array
                    const pubkeyBytes = new Uint8Array(pubkey.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

                    // Generate shared secret using secp256k1
                    const sharedPoint = window.NostrTools.getSharedSecret(privkeyBytes, '02' + pubkey);
                    const sharedSecret = sharedPoint.substring(2, 66); // Remove '02' prefix and take x coordinate

                    // Derive key using SHA-256
                    const encoder = new TextEncoder();
                    const sharedSecretBytes = new Uint8Array(sharedSecret.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                    const keyMaterial = await crypto.subtle.importKey(
                        'raw',
                        sharedSecretBytes,
                        { name: 'HKDF' },
                        false,
                        ['deriveKey']
                    );

                    // Derive AES key
                    const aesKey = await crypto.subtle.deriveKey(
                        {
                            name: 'HKDF',
                            salt: new Uint8Array(0),
                            info: encoder.encode('nip04-v1'),
                            hash: 'SHA-256'
                        },
                        keyMaterial,
                        { name: 'AES-CBC', length: 256 },
                        false,
                        ['encrypt']
                    );

                    // Generate random IV
                    const iv = crypto.getRandomValues(new Uint8Array(16));

                    // Encrypt the content
                    const contentBytes = encoder.encode(content);
                    const ciphertext = await crypto.subtle.encrypt(
                        { name: 'AES-CBC', iv: iv },
                        aesKey,
                        contentBytes
                    );

                    // Convert to base64
                    const ciphertextBase64 = btoa(String.fromCharCode(...new Uint8Array(ciphertext)));
                    const ivBase64 = btoa(String.fromCharCode(...iv));

                    // Return in NIP-04 format
                    return `${ciphertextBase64}?iv=${ivBase64}`;

                } catch (error) {
                    console.error('NIP-04 encryption failed:', error);

                    // Try a simpler approach if nostr-tools methods are available
                    try {
                        if (window.NostrTools && window.NostrTools.nip04) {
                            return await window.NostrTools.nip04.encrypt(privkey, pubkey, content);
                        }
                    } catch (fallbackError) {
                        console.error('Fallback encryption also failed:', fallbackError);
                    }

                    return null;
                }
            }

            getPMConversationKey(otherPubkey) {
                // Create a unique key for this PM conversation between two users
                const keys = [this.pubkey, otherPubkey].sort();
                return `pm-${keys.join('-')}`;
            }

            async sendPM(content, recipientPubkey) {
                try {
                    if (!this.connected) {
                        throw new Error('Not connected to relay');
                    }

                    // Try NIP-17 first, fallback to NIP-04
                    const useNIP17 = true; // Can be made configurable

                    if (useNIP17) {
                        // NIP-17 implementation would go here
                        // For now, fallback to NIP-04
                        return await this.sendNIP04PM(content, recipientPubkey);
                    } else {
                        return await this.sendNIP04PM(content, recipientPubkey);
                    }
                } catch (error) {
                    console.error('Failed to send PM:', error);
                    this.displaySystemMessage('Failed to send PM: ' + error.message);
                    return false;
                }
            }

            async sendNIP04PM(content, recipientPubkey) {
                try {
                    // Create message payload with nym
                    const messagePayload = JSON.stringify({
                        nym: this.nym,
                        content: content
                    });

                    // Encrypt the message
                    let encryptedContent;
                    if (window.nostr && !this.privkey) {
                        // Use extension to encrypt
                        encryptedContent = await window.nostr.nip04.encrypt(recipientPubkey, messagePayload);
                    } else if (this.privkey) {
                        // Use local keys to encrypt
                        encryptedContent = await this.encryptNIP04(messagePayload, recipientPubkey, this.privkey);
                    } else {
                        throw new Error('No encryption method available');
                    }

                    // Create NIP-04 DM event
                    const event = {
                        kind: 4, // NIP-04 encrypted direct message
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['p', recipientPubkey] // Tag ONLY the recipient
                        ],
                        content: encryptedContent,
                        pubkey: this.pubkey
                    };

                    // Sign and send the event
                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        signedEvent = await window.nostr.signEvent(event);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                    } else {
                        throw new Error('No signing method available');
                    }

                    this.sendToRelay(["EVENT", signedEvent]);

                    return true;
                } catch (error) {
                    console.error('Failed to send NIP-04 PM:', error);
                    throw error;
                }
            }

            addPMConversation(nym, pubkey) {
                if (!this.pmConversations.has(pubkey)) {
                    this.pmConversations.set(pubkey, nym);

                    const pmList = document.getElementById('pmList');
                    const item = document.createElement('div');
                    item.className = 'pm-item';
                    item.dataset.pubkey = pubkey;
                    item.innerHTML = `
                                    <span class="pm-name">@${this.escapeHtml(nym)}</span>
                                    <div class="channel-badges">
                                        <span class="pm-badge">PM</span>
                                        <span class="delete-pm" onclick="event.stopPropagation(); nym.deletePM('${pubkey}')">✕</span>
                                        <span class="unread-badge" style="display:none">0</span>
                                    </div>
                                `;
                    item.onclick = () => this.openPM(nym, pubkey);
                    pmList.appendChild(item);
                }
            }

            deletePM(pubkey) {
                if (confirm('Delete this PM conversation?')) {
                    // Remove from conversations
                    this.pmConversations.delete(pubkey);

                    // Remove messages
                    const conversationKey = this.getPMConversationKey(pubkey);
                    this.pmMessages.delete(conversationKey);

                    // Remove from UI
                    const item = document.querySelector(`[data-pubkey="${pubkey}"]`);
                    if (item) item.remove();

                    // If currently viewing this PM, switch to bar
                    if (this.inPMMode && this.currentPM === pubkey) {
                        this.switchChannel('bar', '');
                    }

                    this.displaySystemMessage('PM conversation deleted');
                }
            }

            openPM(nym, pubkey) {
                this.inPMMode = true;
                this.currentPM = pubkey;
                this.currentChannel = null;
                this.currentGeohash = null;

                // Update UI
                document.getElementById('currentChannel').textContent = `@${nym} (PM)`;
                document.getElementById('channelMeta').textContent = 'Private message';
                document.getElementById('mobileTitle').textContent = `@${nym}`;

                // Update active states
                document.querySelectorAll('.channel-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelectorAll('.pm-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.pubkey === pubkey);
                });

                // Clear unread count
                const conversationKey = this.getPMConversationKey(pubkey);
                this.clearUnreadCount(conversationKey);

                // Load PM messages
                this.loadPMMessages(conversationKey);

                // Close mobile sidebar
                if (window.innerWidth <= 768) {
                    this.toggleSidebar();
                }
            }

            loadPMMessages(conversationKey) {
                const container = document.getElementById('messagesContainer');
                container.innerHTML = '';

                const pmMessages = this.pmMessages.get(conversationKey) || [];

                // Only show messages that are part of this specific conversation
                const filteredMessages = pmMessages.filter(msg => {
                    // Ensure the message is between the current user and the PM recipient only
                    return msg.conversationKey === conversationKey &&
                        (msg.pubkey === this.pubkey || msg.pubkey === this.currentPM);
                });

                // Sort messages by timestamp
                filteredMessages.sort((a, b) => a.timestamp - b.timestamp);

                // Display only these filtered messages
                filteredMessages.forEach(msg => {
                    // Double-check this is a PM before displaying
                    if (msg.isPM && msg.conversationKey === conversationKey) {
                        // Create the message element directly to ensure it's displayed
                        const messageEl = document.createElement('div');
                        const time = this.settings.showTimestamps ?
                            msg.timestamp.toLocaleTimeString('en-US', {
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: false
                            }) : '';

                        messageEl.className = 'message pm';
                        messageEl.dataset.messageId = msg.id;
                        messageEl.dataset.author = msg.author;

                        const authorClass = msg.isOwn ? 'self' : '';

                        messageEl.innerHTML = `
                            ${time ? `<span class="message-time">${time}</span>` : ''}
                            <span class="message-author ${authorClass}">${this.escapeHtml(msg.author)}:</span>
                            <span class="message-content">${this.formatMessage(msg.content)}</span>
                            <button class="reaction-btn" onclick="nym.showReactionPicker('${msg.id}', this)">
                                <svg viewBox="0 0 24 24">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                                    <circle cx="9" cy="9" r="1.5"></circle>
                                    <circle cx="15" cy="9" r="1.5"></circle>
                                </svg>
                            </button>
                        `;

                        // Add existing reactions if any
                        if (this.reactions.has(msg.id)) {
                            this.updateMessageReactions(msg.id);
                        }

                        container.appendChild(messageEl);
                    }
                });

                if (filteredMessages.length === 0) {
                    this.displaySystemMessage('Start of private message');
                }

                // Scroll to bottom
                if (this.settings.autoscroll) {
                    container.scrollTop = container.scrollHeight;
                }
            }

            openUserPM(nym, pubkey) {
                // Don't open PM with yourself
                if (pubkey === this.pubkey) {
                    this.displaySystemMessage("You can't send private messages to yourself");
                    return;
                }

                // Add to PM conversations if not exists
                this.addPMConversation(nym, pubkey);
                // Open the PM
                this.openPM(nym, pubkey);
            }

            isMentioned(content) {
                const lowerContent = content.toLowerCase();
                const lowerNym = this.nym.toLowerCase();
                return lowerContent.includes(`@${lowerNym}`) || lowerContent.includes(lowerNym);
            }

            async generateKeypair() {
                try {
                    // Generate ephemeral keys using nostr-tools bundle functions
                    const sk = window.NostrTools.generateSecretKey();
                    const pk = window.NostrTools.getPublicKey(sk);

                    this.privkey = sk;
                    this.pubkey = pk;

                    console.log('Generated ephemeral keypair');

                    return { privkey: sk, pubkey: pk };
                } catch (error) {
                    console.error('Failed to generate keypair:', error);
                    throw error;
                }
            }

            async useExtension() {
                if (!window.nostr) {
                    throw new Error('No Nostr extension detected. Please install Alby or nos2x.');
                }

                try {
                    const pk = await window.nostr.getPublicKey();
                    this.pubkey = pk;
                    this.usingExtension = true;

                    // Fetch profile from kind 0 event
                    await this.fetchProfileFromRelay(pk);

                    return { pubkey: pk };
                } catch (error) {
                    throw new Error('Failed to connect to Nostr extension');
                }
            }

            async fetchProfileFromRelay(pubkey) {
                return new Promise((resolve) => {
                    // Set a timeout in case profile doesn't exist
                    const timeout = setTimeout(() => {
                        console.log('No profile found, using default nym');
                        resolve();
                    }, 3000);

                    // Create a temporary subscription for profile
                    const subId = "profile-" + Math.random().toString(36).substring(7);

                    // Store original message handler
                    const originalHandler = this.handleRelayMessage.bind(this);

                    // Override handleRelayMessage temporarily
                    this.handleRelayMessage = (msg) => {
                        if (!Array.isArray(msg)) return;

                        const [type, ...data] = msg;

                        if (type === 'EVENT' && data[0] === subId) {
                            const event = data[1];
                            if (event && event.kind === 0 && event.pubkey === pubkey) {
                                try {
                                    const profile = JSON.parse(event.content);
                                    if (profile.name || profile.username || profile.display_name) {
                                        // Use the first available name field
                                        const profileName = profile.name || profile.username || profile.display_name;
                                        this.nym = profileName.substring(0, 20); // Limit to 20 chars
                                        document.getElementById('currentNym').textContent = this.nym;
                                        console.log('Profile loaded:', this.nym);
                                    }
                                } catch (e) {
                                    console.error('Failed to parse profile:', e);
                                }

                                clearTimeout(timeout);
                                // Restore original handler
                                this.handleRelayMessage = originalHandler;
                                resolve();
                            }
                        } else if (type === 'EOSE' && data[0] === subId) {
                            // End of stored events, no profile found
                            clearTimeout(timeout);
                            // Restore original handler
                            this.handleRelayMessage = originalHandler;
                            resolve();
                        }

                        // Also call original handler
                        originalHandler(msg);
                    };

                    // Request profile event
                    const subscription = [
                        "REQ",
                        subId,
                        {
                            kinds: [0],
                            authors: [pubkey],
                            limit: 1
                        }
                    ];

                    // If connected, send immediately, otherwise queue
                    if (this.connected) {
                        this.sendToRelay(subscription);

                        // Unsubscribe after getting the data
                        setTimeout(() => {
                            this.sendToRelay(["CLOSE", subId]);
                        }, 3500);
                    } else {
                        // Queue for when connected
                        this.messageQueue.push(JSON.stringify(subscription));
                    }
                });
            }

            async publishMessage(content, channel = this.currentChannel, geohash = this.currentGeohash) {
                try {
                    if (!this.connected) {
                        throw new Error('Not connected to relay');
                    }

                    const tags = [
                        ['n', this.nym], // nym tag
                        ['client', 'NYM']
                    ];

                    let kind;

                    // Use appropriate kind and tags based on channel type
                    if (geohash) {
                        kind = 20000; // Geohash channels use kind 20000
                        tags.push(['g', geohash]);
                    } else {
                        kind = 23333; // Standard channels use kind 23333
                        tags.push(['d', channel]);
                        tags.push(['relay', this.relayUrl]); // Add relay tag for standard channels
                    }

                    const event = {
                        kind: kind,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: tags,
                        content: content,
                        pubkey: this.pubkey
                    };

                    // Sign event
                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        // Use extension
                        signedEvent = await window.nostr.signEvent(event);
                    } else if (this.privkey) {
                        // Use finalizeEvent with ephemeral key
                        signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                    } else {
                        throw new Error('No signing method available');
                    }

                    // Send to relay
                    this.sendToRelay(["EVENT", signedEvent]);

                    return true;
                } catch (error) {
                    console.error('Failed to publish message:', error);
                    this.displaySystemMessage('Failed to send message: ' + error.message);
                    return false;
                }
            }

            async createChannel(channelName) {
                try {
                    if (!this.connected) {
                        throw new Error('Not connected to relay');
                    }

                    const event = {
                        kind: 23333, // Channel creation/joining
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['d', channelName],
                            ['relay', this.relayUrl], // Add relay tag
                            ['about', `Channel #${channelName} created via NYM`],
                            ['client', 'NYM']
                        ],
                        content: JSON.stringify({
                            name: channelName,
                            about: `Channel #${channelName}`,
                            picture: ''
                        }),
                        pubkey: this.pubkey
                    };

                    // Sign event
                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        signedEvent = await window.nostr.signEvent(event);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(event, this.privkey);
                    } else {
                        throw new Error('No signing method available');
                    }

                    // Send to relay
                    this.sendToRelay(["EVENT", signedEvent]);

                    return true;
                } catch (error) {
                    console.error('Failed to create channel:', error);
                    return false;
                }
            }

            async uploadImage(file) {
                const progress = document.getElementById('uploadProgress');
                const progressFill = document.getElementById('progressFill');

                try {
                    progress.classList.add('active');
                    progressFill.style.width = '20%';

                    // Compute SHA-256 hash
                    const arrayBuffer = await file.arrayBuffer();
                    const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                    const hashArray = Array.from(new Uint8Array(hashBuffer));
                    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                    progressFill.style.width = '40%';

                    // Create and sign Nostr event
                    const uploadEvent = {
                        kind: 24242,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: [
                            ['t', 'upload'],
                            ['x', hashHex]
                        ],
                        content: 'Uploading blob with SHA-256 hash',
                        pubkey: this.pubkey
                    };

                    let signedEvent;
                    if (window.nostr && !this.privkey) {
                        signedEvent = await window.nostr.signEvent(uploadEvent);
                    } else if (this.privkey) {
                        signedEvent = window.NostrTools.finalizeEvent(uploadEvent, this.privkey);
                    } else {
                        throw new Error('No signing method available');
                    }

                    progressFill.style.width = '60%';

                    // Prepare form data
                    const formData = new FormData();
                    formData.append('file', file);

                    // Convert signed event to base64
                    const eventString = JSON.stringify(signedEvent);
                    const eventBase64 = btoa(eventString);

                    progressFill.style.width = '80%';

                    // Upload to nostrmedia.com
                    const response = await fetch('https://nostrmedia.com/upload', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Nostr ${eventBase64}`
                        },
                        body: formData
                    });

                    progressFill.style.width = '100%';

                    if (response.ok) {
                        const data = await response.json();
                        if (data.url) {
                            const imageUrl = data.url;
                            const input = document.getElementById('messageInput');
                            input.value += imageUrl + ' ';
                            input.focus();
                            this.updateCharCounter(input.value.length);
                        } else {
                            throw new Error('No URL in response');
                        }
                    } else {
                        throw new Error(`Upload failed: ${response.status}`);
                    }
                } catch (error) {
                    console.error('Image upload failed:', error);
                    this.displaySystemMessage('Failed to upload image: ' + error.message);
                } finally {
                    setTimeout(() => {
                        progress.classList.remove('active');
                    }, 500);
                }
            }

            isDuplicateMessage(message) {
                const displayChannel = message.geohash ? `#${message.geohash}` : message.channel;
                const channelMessages = this.messages.get(displayChannel) || [];
                return channelMessages.some(m =>
                    m.id === message.id ||
                    (m.content === message.content &&
                        m.author === message.author &&
                        Math.abs(m.timestamp - message.timestamp) < 2000)
                );
            }

            getNymFromPubkey(pubkey) {
                const user = this.users.get(pubkey);
                if (user) return user.nym;

                // Check PM conversations for saved nyms
                if (this.pmConversations.has(pubkey)) {
                    return this.pmConversations.get(pubkey);
                }

                // Return shortened pubkey as fallback
                return 'anon-' + pubkey.substring(0, 6);
            }

            displayMessage(message) {
                // Handle PM messages differently
                if (message.isPM) {
                    // Only display if we're in PM mode with the correct user
                    if (!this.inPMMode || this.currentPM !== message.conversationPubkey) {
                        return;
                    }

                    // Don't display if it's not part of the current conversation
                    const currentConversationKey = this.getPMConversationKey(this.currentPM);
                    if (message.conversationKey !== currentConversationKey) {
                        return;
                    }
                } else {
                    // Regular channel message handling
                    // Don't display channel messages in PM mode
                    if (this.inPMMode) {
                        return;
                    }

                    // Store messages with consistent key format (no # for standard channels)
                    const storageKey = message.geohash ? `#${message.geohash}` : message.channel;

                    // Store message
                    if (!this.messages.has(storageKey)) {
                        this.messages.set(storageKey, []);
                    }

                    // Check if message already exists
                    const exists = this.messages.get(storageKey).some(m => m.id === message.id);
                    if (!exists) {
                        this.messages.get(storageKey).push(message);
                    }

                    // Check if this is for current channel
                    const currentKey = this.currentGeohash ? `#${this.currentGeohash}` : this.currentChannel;
                    if (storageKey !== currentKey) {
                        if (!message.isOwn && !exists) {
                            this.updateUnreadCount(storageKey);
                        }
                        return;
                    }
                }

                // Don't re-add if already displayed
                if (document.querySelector(`[data-message-id="${message.id}"]`)) {
                    return;
                }

                const container = document.getElementById('messagesContainer');
                const shouldScroll = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;

                const time = this.settings.showTimestamps ?
                    message.timestamp.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    }) : '';

                const messageEl = document.createElement('div');

                // Check if author is blocked or message contains blocked keywords
                if (this.blockedUsers.has(message.author) || this.hasBlockedKeyword(message.content)) {
                    messageEl.className = 'message blocked';
                    return;
                }

                // Check if author is flooding
                if (this.isFlooding(message.pubkey)) {
                    messageEl.className = 'message flooded';
                }

                // Check for action messages
                if (message.content.startsWith('/me ')) {
                    messageEl.className = 'action-message';
                    messageEl.innerHTML = `* ${this.escapeHtml(message.author)} ${this.formatMessage(message.content.substring(4))}`;
                } else {
                    messageEl.className = message.isPM ? 'message pm' : 'message';
                    messageEl.dataset.messageId = message.id;
                    messageEl.dataset.author = message.author;
                    messageEl.dataset.pubkey = message.pubkey;

                    const authorClass = message.isOwn ? 'self' : '';

                    // Only show reaction button if we have a valid 32-byte hex event ID
                    const isValidEventId = message.id && /^[0-9a-f]{64}$/i.test(message.id);
                    const reactionButton = message.isPM || !isValidEventId ? '' : `
            <button class="reaction-btn" onclick="nym.showReactionPicker('${message.id}', this)">
                <svg viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                    <circle cx="9" cy="9" r="1"></circle>
                    <circle cx="15" cy="9" r="1"></circle>
                </svg>
            </button>
        `;

                    messageEl.innerHTML = `
            ${time ? `<span class="message-time">${time}</span>` : ''}
            <span class="message-author ${authorClass}" onclick="${!message.isPM ? `nym.insertMention('${this.escapeHtml(message.author)}')` : ''}">${this.escapeHtml(message.author)}:</span>
            <span class="message-content">${this.formatMessage(message.content)}</span>
            ${reactionButton}
        `;

                    // Add existing reactions if any
                    if (this.reactions.has(message.id)) {
                        this.updateMessageReactions(message.id);
                    }
                }

                container.appendChild(messageEl);

                if (shouldScroll && this.settings.autoscroll) {
                    container.scrollTop = container.scrollHeight;
                }
            }

            showReactionPicker(messageId, button) {
                // Toggle if clicking same button
                if (this.activeReactionPicker && this.activeReactionPickerButton === button) {
                    this.closeReactionPicker();
                    return;
                }

                // Close any existing picker
                if (this.activeReactionPicker) {
                    this.activeReactionPicker.remove();
                }

                const picker = document.createElement('div');
                picker.className = 'reaction-picker active';
                picker.innerHTML = ['👍', '❤️', '😂', '🔥', '👎', '😮', '🤔', '💯', '🎉', '👏'].map(emoji =>
                    `<button class="reaction-emoji" onclick="nym.sendReaction('${messageId}', '${emoji}'); nym.closeReactionPicker();">${emoji}</button>`
                ).join('');

                button.parentElement.appendChild(picker);
                this.activeReactionPicker = picker;
                this.activeReactionPickerButton = button;

                // Close on click outside
                setTimeout(() => {
                    document.addEventListener('click', this.closeReactionPickerHandler.bind(this), { once: true });
                }, 100);
            }

            closeReactionPickerHandler(e) {
                if (this.activeReactionPicker && !this.activeReactionPicker.contains(e.target)) {
                    this.closeReactionPicker();
                }
            }

            closeReactionPicker() {
                if (this.activeReactionPicker) {
                    this.activeReactionPicker.remove();
                    this.activeReactionPicker = null;
                    this.activeReactionPickerButton = null;
                }
            }

            currentDisplayChannel() {
                // Return consistent key format for message storage
                return this.currentGeohash ? `#${this.currentGeohash}` : this.currentChannel;
            }

            formatMessage(content) {
                let formatted = content;

                // First, escape HTML entities
                formatted = formatted.replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;');

                // Code blocks with proper line break handling
                formatted = formatted.replace(/```([\s\S]*?)```/g, (match, code) => {
                    // Preserve line breaks in code blocks
                    const formattedCode = code.trim().replace(/\n/g, '<br>');
                    return `<pre><code>${formattedCode}</code></pre>`;
                });

                // Inline code
                formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');

                // Bold **text** or __text__
                formatted = formatted.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                formatted = formatted.replace(/__(.+?)__/g, '<strong>$1</strong>');

                // Italic *text* or _text_ (avoid URLs)
                formatted = formatted.replace(/(?<![:/])(\*|_)([^*_\s][^*_]*)\1/g, '<em>$2</em>');

                // Strikethrough ~~text~~
                formatted = formatted.replace(/~~(.+?)~~/g, '<del>$1</del>');

                // Blockquotes > text
                formatted = formatted.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');

                // Headers
                formatted = formatted.replace(/^### (.+)$/gm, '<h3>$1</h3>');
                formatted = formatted.replace(/^## (.+)$/gm, '<h2>$1</h2>');
                formatted = formatted.replace(/^# (.+)$/gm, '<h1>$1</h1>');

                // Convert image URLs to images
                formatted = formatted.replace(
                    /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp)(\?[^\s]*)?)/gi,
                    '<img src="$1" alt="Image" onclick="nym.expandImage(\'$1\')" />'
                );

                // Convert other URLs to links
                formatted = formatted.replace(
                    /(https?:\/\/[^\s]+)(?![^<]*>)/g,
                    '<a href="$1" target="_blank" rel="noopener">$1</a>'
                );

                // Highlight mentions
                formatted = formatted.replace(
                    /@(\w+)/g,
                    '<span style="color: var(--secondary)">@$1</span>'
                );

                // Channel references
                formatted = formatted.replace(
                    /#(\w+)/g,
                    (match, channel) => {
                        const type = this.getChannelType(channel);
                        const badge = type === 'geo' ? ' [GEO]' : ' [STD]';
                        return `<span class="channel-link" onclick="nym.quickJoinChannel('${channel}')">#${channel}${badge}</span>`;
                    }
                );

                return formatted;
            }

            expandImage(src) {
                document.getElementById('modalImage').src = src;
                document.getElementById('imageModal').classList.add('active');
            }

            quickJoinChannel(channel) {
                const type = this.getChannelType(channel);

                if (type === 'geo') {
                    this.addChannel(channel, channel);
                    this.switchChannel(channel, channel);
                } else {
                    this.addChannel(channel, '');
                    this.switchChannel(channel, '');
                    // Also create the channel with kind 23333
                    this.createChannel(channel);
                }
            }

            insertMention(nym) {
                const input = document.getElementById('messageInput');
                const currentValue = input.value;
                const mention = `@${nym} `;

                // Insert at cursor position or append
                const start = input.selectionStart;
                const end = input.selectionEnd;

                if (start !== undefined) {
                    input.value = currentValue.substring(0, start) + mention + currentValue.substring(end);
                    input.selectionStart = input.selectionEnd = start + mention.length;
                } else {
                    input.value = currentValue + mention;
                }

                input.focus();
                this.updateCharCounter(input.value.length);
            }

            displaySystemMessage(content, type = 'system') {
                const container = document.getElementById('messagesContainer');
                const messageEl = document.createElement('div');
                messageEl.className = type === 'action' ? 'action-message' : 'system-message';
                messageEl.innerHTML = content;
                container.appendChild(messageEl);

                if (this.settings.autoscroll) {
                    container.scrollTop = container.scrollHeight;
                }
            }

            updateUserPresence(nym, pubkey, channel, geohash) {
                const channelKey = geohash || channel;

                // Update or create user with deduplication by pubkey
                if (!this.users.has(pubkey)) {
                    this.users.set(pubkey, {
                        nym: nym,
                        pubkey: pubkey,
                        lastSeen: Date.now(),
                        status: 'online',
                        channels: new Set([channelKey])
                    });
                } else {
                    const user = this.users.get(pubkey);
                    user.lastSeen = Date.now();
                    user.nym = nym; // Update nym in case it changed
                    user.channels.add(channelKey);
                }

                // Track users per channel
                if (!this.channelUsers.has(channelKey)) {
                    this.channelUsers.set(channelKey, new Set());
                }
                this.channelUsers.get(channelKey).add(pubkey);

                this.updateUserList();
            }

            updateUserList() {
                const userListContent = document.getElementById('userListContent');
                const currentChannelKey = this.currentGeohash || this.currentChannel;

                // Get deduplicated active users (one entry per pubkey)
                const uniqueUsers = new Map();
                this.users.forEach((user, pubkey) => {
                    if (Date.now() - user.lastSeen < 300000 && !this.blockedUsers.has(user.nym)) {
                        // Only add if not already there (deduplication by pubkey)
                        if (!uniqueUsers.has(pubkey)) {
                            uniqueUsers.set(pubkey, user);
                        }
                    }
                });

                const allUsers = Array.from(uniqueUsers.values())
                    .sort((a, b) => a.nym.localeCompare(b.nym));

                // Filter users based on search term
                let displayUsers = allUsers;
                if (this.userSearchTerm) {
                    displayUsers = allUsers.filter(user =>
                        user.nym.toLowerCase().includes(this.userSearchTerm.toLowerCase())
                    );
                }

                // Get users in current channel for the count
                const channelUserSet = this.channelUsers.get(currentChannelKey) || new Set();
                const channelUserCount = Array.from(channelUserSet)
                    .filter(pubkey => {
                        const user = this.users.get(pubkey);
                        return user && Date.now() - user.lastSeen < 300000 && !this.blockedUsers.has(user.nym);
                    }).length;

                // Display deduplicated users in sidebar with click to open PM
                userListContent.innerHTML = displayUsers.map(user => `
                    <div class="user-item" onclick="nym.openUserPM('${this.escapeHtml(user.nym)}', '${user.pubkey}')" data-nym="${this.escapeHtml(user.nym)}">
                        <span class="user-status ${user.status}"></span>
                        <span>${this.escapeHtml(user.nym)}</span>
                    </div>
                `).join('');

                // Update active nyms count in title
                const userListTitle = document.querySelector('#userList .nav-title-text');
                if (userListTitle) {
                    userListTitle.textContent = `Active Nyms (${allUsers.length})`;
                }

                // Update channel meta with channel-specific count
                if (!this.inPMMode) {
                    document.getElementById('channelMeta').textContent = `${channelUserCount} online nyms`;
                }
            }

            filterChannels(searchTerm) {
                const items = document.querySelectorAll('.channel-item');
                const term = searchTerm.toLowerCase();

                items.forEach(item => {
                    const channelName = item.querySelector('.channel-name').textContent.toLowerCase();
                    if (channelName.includes(term)) {
                        item.style.display = 'flex';
                    } else {
                        item.style.display = 'none';
                    }
                });
            }

            filterPMs(searchTerm) {
                const items = document.querySelectorAll('.pm-item');
                const term = searchTerm.toLowerCase();

                items.forEach(item => {
                    const pmName = item.querySelector('.pm-name').textContent.toLowerCase();
                    if (pmName.includes(term)) {
                        item.style.display = 'flex';
                    } else {
                        item.style.display = 'none';
                    }
                });
            }

            filterUsers(searchTerm) {
                this.userSearchTerm = searchTerm;
                this.updateUserList();
            }

            togglePin(channel, geohash) {
                const key = geohash || channel;

                if (this.pinnedChannels.has(key)) {
                    this.pinnedChannels.delete(key);
                } else {
                    this.pinnedChannels.add(key);
                }

                this.savePinnedChannels();
                this.updateChannelPins();

                // Save to synced settings if using extension
                if (this.usingExtension) {
                    this.saveSyncedSettings();
                }
            }

            updateChannelPins() {
                document.querySelectorAll('.channel-item').forEach(item => {
                    const channel = item.dataset.channel;
                    const geohash = item.dataset.geohash;
                    const key = geohash || channel;
                    const pinBtn = item.querySelector('.pin-btn');

                    if (this.pinnedChannels.has(key)) {
                        item.classList.add('pinned');
                        if (pinBtn) pinBtn.classList.add('pinned');
                    } else {
                        item.classList.remove('pinned');
                        if (pinBtn) pinBtn.classList.remove('pinned');
                    }
                });
            }

            savePinnedChannels() {
                localStorage.setItem('nym_pinned_channels', JSON.stringify(Array.from(this.pinnedChannels)));
            }

            loadPinnedChannels() {
                const saved = localStorage.getItem('nym_pinned_channels');
                if (saved) {
                    this.pinnedChannels = new Set(JSON.parse(saved));
                    this.updateChannelPins();
                }
            }

            setupEventListeners() {
                const input = document.getElementById('messageInput');

                input.addEventListener('keydown', (e) => {
                    const autocomplete = document.getElementById('autocompleteDropdown');
                    const emojiAutocomplete = document.getElementById('emojiAutocomplete');
                    const commandPalette = document.getElementById('commandPalette');

                    if (autocomplete.classList.contains('active')) {
                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            this.navigateAutocomplete(1);
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            this.navigateAutocomplete(-1);
                        } else if (e.key === 'Enter' || e.key === 'Tab') {
                            e.preventDefault();
                            this.selectAutocomplete();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            this.hideAutocomplete();
                        }
                    } else if (emojiAutocomplete.classList.contains('active')) {
                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            this.navigateEmojiAutocomplete(1);
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            this.navigateEmojiAutocomplete(-1);
                        } else if (e.key === 'Enter' || e.key === 'Tab') {
                            e.preventDefault();
                            this.selectEmojiAutocomplete();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            this.hideEmojiAutocomplete();
                        }
                    } else if (commandPalette.classList.contains('active')) {
                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            this.navigateCommandPalette(1);
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            this.navigateCommandPalette(-1);
                        } else if (e.key === 'Enter' || e.key === 'Tab') {
                            e.preventDefault();
                            this.selectCommand();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            this.hideCommandPalette();
                        }
                    } else {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            this.sendMessage();
                        } else if (e.key === 'ArrowUp' && input.value === '') {
                            e.preventDefault();
                            this.navigateHistory(-1);
                        } else if (e.key === 'ArrowDown' && input.value === '') {
                            e.preventDefault();
                            this.navigateHistory(1);
                        }
                    }
                });

                input.addEventListener('input', (e) => {
                    this.handleInputChange(e.target.value);
                    this.updateCharCounter(e.target.value.length);
                    this.autoResizeTextarea(e.target);
                });

                // Channel switching
                document.addEventListener('click', (e) => {
                    if (e.target.closest('.channel-item')) {
                        const item = e.target.closest('.channel-item');
                        const channel = item.dataset.channel;
                        const geohash = item.dataset.geohash || '';

                        // Don't reload if already in channel
                        if (!this.inPMMode && channel === this.currentChannel && geohash === this.currentGeohash) {
                            return;
                        }

                        this.switchChannel(channel, geohash);
                    }

                    // Command palette click
                    if (e.target.closest('.command-item')) {
                        this.selectCommand(e.target.closest('.command-item'));
                    }
                });

                // File input
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    if (e.target.files && e.target.files[0]) {
                        this.uploadImage(e.target.files[0]);
                    }
                });

                // Modal controls
                document.getElementById('relaySelect').addEventListener('change', (e) => {
                    document.getElementById('customRelayGroup').style.display =
                        e.target.value === 'custom' ? 'block' : 'none';
                });

                document.getElementById('channelTypeSelect').addEventListener('change', (e) => {
                    document.getElementById('standardChannelGroup').style.display =
                        e.target.value === 'standard' ? 'block' : 'none';
                    document.getElementById('geohashGroup').style.display =
                        e.target.value === 'geohash' ? 'block' : 'none';
                });

                document.getElementById('connectedRelaySelect').addEventListener('change', (e) => {
                    document.getElementById('customConnectedRelay').style.display =
                        e.target.value === 'custom' ? 'block' : 'none';
                });
            }

            setupCommands() {
                this.commands = {
                    '/help': { desc: 'Show available commands', fn: () => this.showHelp() },
                    '/join': { desc: 'Join a channel', fn: (args) => this.cmdJoin(args) },
                    '/j': { desc: 'Shortcut for /join', fn: (args) => this.cmdJoin(args) },
                    '/pm': { desc: 'Send private message', fn: (args) => this.cmdPM(args) },
                    '/nick': { desc: 'Change your nym', fn: (args) => this.cmdNick(args) },
                    '/who': { desc: 'List online nyms', fn: () => this.cmdWho() },
                    '/w': { desc: 'Shortcut for /who', fn: () => this.cmdWho() },
                    '/clear': { desc: 'Clear chat messages', fn: () => this.cmdClear() },
                    '/block': { desc: 'Block a user', fn: (args) => this.cmdBlock(args) },
                    '/unblock': { desc: 'Unblock a user', fn: (args) => this.cmdUnblock(args) },
                    '/slap': { desc: 'Slap someone with a trout', fn: (args) => this.cmdSlap(args) },
                    '/me': { desc: 'Action message', fn: (args) => this.cmdMe(args) },
                    '/shrug': { desc: 'Send a shrug', fn: () => this.cmdShrug() },
                    '/bold': { desc: 'Send bold text (**text**)', fn: (args) => this.cmdBold(args) },
                    '/b': { desc: 'Shortcut for /bold', fn: (args) => this.cmdBold(args) },
                    '/italic': { desc: 'Send italic text (*text*)', fn: (args) => this.cmdItalic(args) },
                    '/i': { desc: 'Shortcut for /italic', fn: (args) => this.cmdItalic(args) },
                    '/strike': { desc: 'Send strikethrough text (~~text~~)', fn: (args) => this.cmdStrike(args) },
                    '/s': { desc: 'Shortcut for /strike', fn: (args) => this.cmdStrike(args) },
                    '/code': { desc: 'Send code block', fn: (args) => this.cmdCode(args) },
                    '/c': { desc: 'Shortcut for /code', fn: (args) => this.cmdCode(args) },
                    '/quote': { desc: 'Send quoted text', fn: (args) => this.cmdQuote(args) },
                    '/q': { desc: 'Shortcut for /quote', fn: (args) => this.cmdQuote(args) },
                    '/quit': { desc: 'Disconnect from NYM', fn: () => this.cmdQuit() }
                };
            }

            handleInputChange(value) {
                // Check for emoji autocomplete with :
                const colonIndex = value.lastIndexOf(':');
                if (colonIndex !== -1 && colonIndex === value.length - 1 ||
                    (colonIndex !== -1 && value.substring(colonIndex).match(/^:[a-z]*$/))) {
                    const search = value.substring(colonIndex + 1);
                    this.showEmojiAutocomplete(search);
                } else {
                    this.hideEmojiAutocomplete();
                }

                // Check for @ mentions
                const lastAtIndex = value.lastIndexOf('@');
                if (lastAtIndex !== -1 && lastAtIndex === value.length - 1 ||
                    (lastAtIndex !== -1 && value.substring(lastAtIndex).match(/^@\w*$/))) {
                    const search = value.substring(lastAtIndex + 1);
                    this.showAutocomplete(search);
                } else {
                    this.hideAutocomplete();
                }

                // Check for commands
                if (value.startsWith('/')) {
                    this.showCommandPalette(value);
                } else {
                    this.hideCommandPalette();
                }
            }

            showEmojiAutocomplete(search) {
                const dropdown = document.getElementById('emojiAutocomplete');

                const matches = Object.entries(this.emojiMap).filter(([name]) =>
                    name.toLowerCase().includes(search.toLowerCase())
                ).slice(0, 5);

                if (matches.length > 0) {
                    dropdown.innerHTML = matches.map(([name, emoji], index) => `
                        <div class="emoji-item ${index === 0 ? 'selected' : ''}" data-name="${name}" data-emoji="${emoji}">
                            <span class="emoji-item-emoji">${emoji}</span>
                            <span class="emoji-item-name">:${name}:</span>
                        </div>
                    `).join('');
                    dropdown.classList.add('active');
                    this.emojiAutocompleteIndex = 0;
                } else {
                    this.hideEmojiAutocomplete();
                }
            }

            hideEmojiAutocomplete() {
                document.getElementById('emojiAutocomplete').classList.remove('active');
                this.emojiAutocompleteIndex = -1;
            }

            navigateEmojiAutocomplete(direction) {
                const items = document.querySelectorAll('.emoji-item');
                if (items.length === 0) return;

                items[this.emojiAutocompleteIndex]?.classList.remove('selected');

                this.emojiAutocompleteIndex += direction;
                if (this.emojiAutocompleteIndex < 0) this.emojiAutocompleteIndex = items.length - 1;
                if (this.emojiAutocompleteIndex >= items.length) this.emojiAutocompleteIndex = 0;

                items[this.emojiAutocompleteIndex].classList.add('selected');
                items[this.emojiAutocompleteIndex].scrollIntoView({ block: 'nearest' });
            }

            selectEmojiAutocomplete() {
                const selected = document.querySelector('.emoji-item.selected');
                if (selected) {
                    const emoji = selected.dataset.emoji;
                    const input = document.getElementById('messageInput');
                    const value = input.value;
                    const colonIndex = value.lastIndexOf(':');

                    input.value = value.substring(0, colonIndex) + emoji + ' ';
                    input.focus();
                    this.updateCharCounter(input.value.length);
                    this.hideEmojiAutocomplete();
                }
            }

            showAutocomplete(search) {
                const dropdown = document.getElementById('autocompleteDropdown');

                // Show deduplicated active users for autocomplete
                const uniqueUsers = new Map();
                this.users.forEach((user, pubkey) => {
                    if (Date.now() - user.lastSeen < 300000 &&
                        !this.blockedUsers.has(user.nym) &&
                        user.nym.toLowerCase().includes(search.toLowerCase()) &&
                        !uniqueUsers.has(pubkey)) {
                        uniqueUsers.set(pubkey, user);
                    }
                });

                const users = Array.from(uniqueUsers.values()).slice(0, 5);

                if (users.length > 0) {
                    dropdown.innerHTML = users.map((user, index) => `
                        <div class="autocomplete-item ${index === 0 ? 'selected' : ''}" data-nym="${user.nym}">
                            <strong>@${this.escapeHtml(user.nym)}</strong>
                        </div>
                    `).join('');
                    dropdown.classList.add('active');
                    this.autocompleteIndex = 0;
                } else {
                    this.hideAutocomplete();
                }
            }

            hideAutocomplete() {
                document.getElementById('autocompleteDropdown').classList.remove('active');
                this.autocompleteIndex = -1;
            }

            navigateAutocomplete(direction) {
                const items = document.querySelectorAll('.autocomplete-item');
                if (items.length === 0) return;

                items[this.autocompleteIndex]?.classList.remove('selected');

                this.autocompleteIndex += direction;
                if (this.autocompleteIndex < 0) this.autocompleteIndex = items.length - 1;
                if (this.autocompleteIndex >= items.length) this.autocompleteIndex = 0;

                items[this.autocompleteIndex].classList.add('selected');
                items[this.autocompleteIndex].scrollIntoView({ block: 'nearest' });
            }

            selectAutocomplete() {
                const selected = document.querySelector('.autocomplete-item.selected');
                if (selected) {
                    const nym = selected.dataset.nym;
                    const input = document.getElementById('messageInput');
                    const value = input.value;
                    const lastAtIndex = value.lastIndexOf('@');

                    input.value = value.substring(0, lastAtIndex) + '@' + nym + ' ';
                    input.focus();
                    this.updateCharCounter(input.value.length);
                    this.hideAutocomplete();
                }
            }

            showCommandPalette(input) {
                const palette = document.getElementById('commandPalette');
                const matchingCommands = Object.entries(this.commands)
                    .filter(([cmd]) => cmd.startsWith(input.toLowerCase()));

                if (matchingCommands.length > 0) {
                    palette.innerHTML = matchingCommands.map(([cmd, info], index) => `
                        <div class="command-item ${index === 0 ? 'selected' : ''}" data-command="${cmd}">
                            <span class="command-name">${cmd}</span>
                            <span class="command-desc">${info.desc}</span>
                        </div>
                    `).join('');
                    palette.classList.add('active');
                    this.commandPaletteIndex = 0;
                } else {
                    this.hideCommandPalette();
                }
            }

            hideCommandPalette() {
                document.getElementById('commandPalette').classList.remove('active');
                this.commandPaletteIndex = -1;
            }

            navigateCommandPalette(direction) {
                const items = document.querySelectorAll('.command-item');
                if (items.length === 0) return;

                items[this.commandPaletteIndex]?.classList.remove('selected');

                this.commandPaletteIndex += direction;
                if (this.commandPaletteIndex < 0) this.commandPaletteIndex = items.length - 1;
                if (this.commandPaletteIndex >= items.length) this.commandPaletteIndex = 0;

                items[this.commandPaletteIndex].classList.add('selected');
                items[this.commandPaletteIndex].scrollIntoView({ block: 'nearest' });
            }

            selectCommand(element = null) {
                const selected = element || document.querySelector('.command-item.selected');
                if (selected) {
                    const cmd = selected.dataset.command;
                    const input = document.getElementById('messageInput');
                    input.value = cmd + ' ';
                    input.focus();
                    this.updateCharCounter(input.value.length);
                    this.hideCommandPalette();
                }
            }

            async sendMessage() {
                const input = document.getElementById('messageInput');
                const content = input.value.trim();

                if (!content) return;

                if (!this.connected) {
                    this.displaySystemMessage('Not connected to relay. Please wait...');
                    return;
                }

                // Add to history
                this.commandHistory.push(content);
                this.historyIndex = this.commandHistory.length;

                if (content.startsWith('/')) {
                    this.handleCommand(content);
                } else {
                    if (this.inPMMode && this.currentPM) {
                        // Send PM
                        const success = await this.sendPM(content, this.currentPM);

                        if (success) {
                            // Display own PM immediately
                            const conversationKey = this.getPMConversationKey(this.currentPM);
                            if (!this.pmMessages.has(conversationKey)) {
                                this.pmMessages.set(conversationKey, []);
                            }

                            const pmMessage = {
                                id: 'temp-' + Date.now().toString(), // Temporary ID for PMs
                                author: this.nym,
                                pubkey: this.pubkey,
                                content: content,
                                timestamp: new Date(),
                                isOwn: true,
                                isPM: true,
                                conversationKey: conversationKey,
                                conversationPubkey: this.currentPM
                            };

                            this.pmMessages.get(conversationKey).push(pmMessage);
                            this.displayMessage(pmMessage);
                        }
                    } else {
                        // Send regular message - this will get proper event ID from relay
                        const success = await this.publishMessage(content, this.currentChannel, this.currentGeohash);

                        // Don't display own message immediately since it will come back from relay with proper ID
                    }
                }

                input.value = '';
                this.updateCharCounter(0);
                this.autoResizeTextarea(input);
                this.hideCommandPalette();
                this.hideAutocomplete();
                this.hideEmojiAutocomplete();
            }

            handleCommand(command) {
                const parts = command.split(' ');
                const cmd = parts[0].toLowerCase();
                const args = parts.slice(1).join(' ');

                const commandInfo = this.commands[cmd];
                if (commandInfo) {
                    commandInfo.fn(args);
                } else {
                    this.displaySystemMessage(`Unknown command: ${cmd}`);
                }
            }

            // Command implementations
            showHelp() {
                const helpText = Object.entries(this.commands)
                    .map(([cmd, info]) => `${cmd} - ${info.desc}`)
                    .join('\n');
                this.displaySystemMessage(`Available commands:\n${helpText}\n\nMarkdown supported: **bold**, *italic*, ~~strikethrough~~, \`code\`, > quote\n\nType : to quickly pick an emoji`);
            }

            async cmdJoin(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /join channel or /join #geohash');
                    return;
                }

                let channel = args.trim().toLowerCase();

                // Check if it's a geohash
                if (channel.startsWith('#')) {
                    const geohash = channel.substring(1);
                    this.addChannel(geohash, geohash);
                    this.switchChannel(geohash, geohash);
                } else {
                    this.addChannel(channel, '');
                    this.switchChannel(channel, '');
                    // Create channel with kind 23333
                    await this.createChannel(channel);
                }
            }

            cmdPM(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /pm nym');
                    return;
                }

                const targetNym = args.trim();

                // Find user by nym
                let targetPubkey = null;
                this.users.forEach((user, pubkey) => {
                    if (user.nym === targetNym) {
                        targetPubkey = pubkey;
                    }
                });

                if (!targetPubkey) {
                    this.displaySystemMessage(`User ${targetNym} not found`);
                    return;
                }

                if (targetPubkey === this.pubkey) {
                    this.displaySystemMessage("You can't send private messages to yourself");
                    return;
                }

                this.openUserPM(targetNym, targetPubkey);
            }

            cmdNick(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /nick newnym');
                    return;
                }

                const oldNym = this.nym;
                this.nym = args.trim().substring(0, 20);
                document.getElementById('currentNym').textContent = this.nym;
                this.displaySystemMessage(`${oldNym} is now known as ${this.nym}`);
            }

            cmdWho() {
                const currentChannelKey = this.currentGeohash || this.currentChannel;
                const channelUserSet = this.channelUsers.get(currentChannelKey) || new Set();

                const users = Array.from(channelUserSet)
                    .map(pubkey => this.users.get(pubkey))
                    .filter(u => u && Date.now() - u.lastSeen < 300000)
                    .filter(u => !this.blockedUsers.has(u.nym))
                    .map(u => u.nym)
                    .join(', ');

                this.displaySystemMessage(`Online nyms in this channel: ${users || 'none'}`);
            }

            cmdClear() {
                document.getElementById('messagesContainer').innerHTML = '';
                this.displaySystemMessage('Chat cleared');
            }

            cmdBlock(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /block nym');
                    return;
                }

                const nym = args.trim();
                this.blockedUsers.add(nym);
                this.saveBlockedUsers();

                // Hide existing messages from this user
                document.querySelectorAll('.message').forEach(msg => {
                    if (msg.dataset.author === nym) {
                        msg.classList.add('blocked');
                    }
                });

                this.displaySystemMessage(`Blocked ${nym}`);
                this.updateUserList();
                this.updateBlockedList();

                // Save to synced settings if using extension
                if (this.usingExtension) {
                    this.saveSyncedSettings();
                }
            }

            cmdUnblock(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /unblock nym');
                    return;
                }

                const nym = args.trim();
                this.blockedUsers.delete(nym);
                this.saveBlockedUsers();

                // Show messages from this user (if not blocked by keywords)
                document.querySelectorAll('.message').forEach(msg => {
                    if (msg.dataset.author === nym) {
                        const content = msg.querySelector('.message-content');
                        if (!content || !this.hasBlockedKeyword(content.textContent)) {
                            msg.classList.remove('blocked');
                        }
                    }
                });

                this.displaySystemMessage(`Unblocked ${nym}`);
                this.updateUserList();
                this.updateBlockedList();

                // Save to synced settings if using extension
                if (this.usingExtension) {
                    this.saveSyncedSettings();
                }
            }

            async cmdSlap(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /slap nym');
                    return;
                }
                await this.publishMessage(`/me slaps ${args} around a bit with a large trout`);
            }

            async cmdMe(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /me action');
                    return;
                }
                await this.publishMessage(`/me ${args}`);
            }

            async cmdShrug() {
                await this.publishMessage('¯\\_(ツ)_/¯');
            }

            async cmdBold(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /bold text');
                    return;
                }
                await this.publishMessage(`**${args}**`);
            }

            async cmdItalic(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /italic text');
                    return;
                }
                await this.publishMessage(`*${args}*`);
            }

            async cmdCode(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /code text');
                    return;
                }
                await this.publishMessage(`\`\`\`\n${args}\n\`\`\``);
            }

            async cmdStrike(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /strike text');
                    return;
                }
                await this.publishMessage(`~~${args}~~`);
            }

            async cmdQuote(args) {
                if (!args) {
                    this.displaySystemMessage('Usage: /quote text');
                    return;
                }
                await this.publishMessage(`> ${args}`);
            }

            cmdQuit() {
                this.displaySystemMessage('Disconnecting from NYM...');
                // Clear saved connection preferences
                localStorage.removeItem('nym_connection_mode');
                localStorage.removeItem('nym_relay_url');
                if (this.ws) {
                    this.ws.close();
                }
                setTimeout(() => {
                    location.reload();
                }, 1000);
            }

            switchChannel(channel, geohash = '') {
                this.inPMMode = false;
                this.currentPM = null;
                this.currentChannel = channel;
                this.currentGeohash = geohash;

                const displayName = geohash ? `#${geohash}` : `#${channel}`;
                document.getElementById('currentChannel').textContent = displayName;
                document.getElementById('mobileTitle').textContent = displayName;

                // Update active state
                document.querySelectorAll('.channel-item').forEach(item => {
                    const isActive = item.dataset.channel === channel &&
                        item.dataset.geohash === geohash;
                    item.classList.toggle('active', isActive);
                });

                document.querySelectorAll('.pm-item').forEach(item => {
                    item.classList.remove('active');
                });

                // Clear unread count
                this.clearUnreadCount(displayName);

                // Load channel messages
                this.loadChannelMessages(displayName);

                // Update user list for this channel
                this.updateUserList();

                // Close mobile sidebar
                if (window.innerWidth <= 768) {
                    this.toggleSidebar();
                }
            }

            loadChannelMessages(displayName) {
                const container = document.getElementById('messagesContainer');
                container.innerHTML = '';

                // Use the storage key format (no # for standard channels)
                const storageKey = this.currentGeohash ? `#${this.currentGeohash}` : this.currentChannel;
                const channelMessages = this.messages.get(storageKey) || [];

                // Sort messages by timestamp
                channelMessages.sort((a, b) => a.timestamp - b.timestamp);

                // Display messages
                channelMessages.forEach(msg => this.displayMessage(msg));

                if (channelMessages.length === 0) {
                    this.displaySystemMessage(`Joined ${displayName}`);
                }
            }

            addChannel(channel, geohash = '') {
                const list = document.getElementById('channelList');
                const key = geohash || channel;

                if (!document.querySelector(`[data-channel="${channel}"][data-geohash="${geohash}"]`)) {
                    const item = document.createElement('div');
                    item.className = 'channel-item';
                    item.dataset.channel = channel;
                    item.dataset.geohash = geohash;

                    const displayName = geohash ? `#${geohash}` : `#${channel}`;
                    const badge = geohash ? '<span class="geohash-badge">GEO</span>' : '<span class="std-badge">STD</span>';

                    const isPinned = this.pinnedChannels.has(key);
                    if (isPinned) {
                        item.classList.add('pinned');
                    }

                    item.innerHTML = `
                        <span class="channel-name">${displayName}</span>
                        <div class="channel-badges">
                            <span class="pin-btn ${isPinned ? 'pinned' : ''}" onclick="event.stopPropagation(); nym.togglePin('${channel}', '${geohash}')">
                                <svg viewBox="0 0 24 24">
                                    <path d="M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z"/>
                                </svg>
                            </span>
                            ${badge}
                            <span class="unread-badge" style="display:none">0</span>
                        </div>
                    `;
                    list.appendChild(item);

                    this.channels.set(key, { channel, geohash });
                    this.updateChannelPins();
                }
            }

            addChannelToList(channel, geohash) {
                if (geohash && !this.channels.has(geohash)) {
                    this.addChannel(geohash, geohash);
                } else if (!geohash && !this.channels.has(channel)) {
                    this.addChannel(channel, '');
                }
            }

            updateUnreadCount(channel) {
                const count = (this.unreadCounts.get(channel) || 0) + 1;
                this.unreadCounts.set(channel, count);

                // Handle PM unread counts using conversation key
                if (channel.startsWith('pm-')) {
                    // Extract the other user's pubkey from conversation key
                    const keys = channel.substring(3).split('-');
                    const otherPubkey = keys.find(k => k !== this.pubkey);
                    if (otherPubkey) {
                        const badge = document.querySelector(`[data-pubkey="${otherPubkey}"] .unread-badge`);
                        if (badge) {
                            badge.textContent = count > 99 ? '99+' : count;
                            badge.style.display = count > 0 ? 'block' : 'none';
                        }
                    }
                } else {
                    // Regular channel unread counts
                    let selector;
                    if (channel.startsWith('#')) {
                        // Geohash channel
                        selector = `[data-geohash="${channel.substring(1)}"]`;
                    } else {
                        // Standard channel (no # prefix in data attribute)
                        selector = `[data-channel="${channel}"][data-geohash=""]`;
                    }

                    const badge = document.querySelector(`${selector} .unread-badge`);
                    if (badge) {
                        badge.textContent = count > 99 ? '99+' : count;
                        badge.style.display = count > 0 ? 'block' : 'none';
                    }
                }
            }

            clearUnreadCount(channel) {
                this.unreadCounts.set(channel, 0);

                // Handle PM unread counts using conversation key
                if (channel.startsWith('pm-')) {
                    // Extract the other user's pubkey from conversation key
                    const keys = channel.substring(3).split('-');
                    const otherPubkey = keys.find(k => k !== this.pubkey);
                    if (otherPubkey) {
                        const badge = document.querySelector(`[data-pubkey="${otherPubkey}"] .unread-badge`);
                        if (badge) {
                            badge.style.display = 'none';
                        }
                    }
                } else {
                    // Regular channel unread counts
                    const isGeohash = channel.startsWith('#') && channel.length <= 13;
                    const selector = isGeohash ?
                        `[data-geohash="${channel.substring(1)}"]` :
                        `[data-channel="${channel.replace('#', '')}"][data-geohash=""]`;

                    const badge = document.querySelector(`${selector} .unread-badge`);
                    if (badge) {
                        badge.style.display = 'none';
                    }
                }
            }

            navigateHistory(direction) {
                const input = document.getElementById('messageInput');

                if (direction === -1 && this.historyIndex > 0) {
                    this.historyIndex--;
                    input.value = this.commandHistory[this.historyIndex];
                } else if (direction === 1 && this.historyIndex < this.commandHistory.length - 1) {
                    this.historyIndex++;
                    input.value = this.commandHistory[this.historyIndex];
                } else if (direction === 1 && this.historyIndex === this.commandHistory.length - 1) {
                    this.historyIndex = this.commandHistory.length;
                    input.value = '';
                }

                this.autoResizeTextarea(input);
            }

            updateCharCounter(length) {
                const counter = document.getElementById('charCounter');
                const sendBtn = document.getElementById('sendBtn');

                counter.textContent = `${length}`;
                counter.classList.remove('warning', 'danger');

                sendBtn.disabled = !this.connected;
            }

            autoResizeTextarea(textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
            }

            updateConnectionStatus(status) {
                document.getElementById('connectionStatus').textContent = status;
                const dot = document.getElementById('statusDot');

                if (status === 'Connected') {
                    dot.style.background = 'var(--primary)';
                } else if (status.includes('Connecting')) {
                    dot.style.background = 'var(--warning)';
                } else {
                    dot.style.background = 'var(--danger)';
                }
            }

            setupEmojiPicker() {
                const emojis = ['😊', '😂', '🤣', '❤️', '👍', '🔥', '✨', '🎉', '💯', '🤔', '😎', '🚀',
                    '💻', '🌟', '⚡', '🎯', '💡', '🤖', '👻', '🎭', '🌈', '🍕', '☕', '🎮'];
                const picker = document.getElementById('emojiPicker');

                emojis.forEach(emoji => {
                    const btn = document.createElement('button');
                    btn.className = 'emoji-btn';
                    btn.textContent = emoji;
                    btn.onclick = () => this.insertEmoji(emoji);
                    picker.appendChild(btn);
                });
            }

            insertEmoji(emoji) {
                const input = document.getElementById('messageInput');
                const start = input.selectionStart;
                const end = input.selectionEnd;
                const text = input.value;

                input.value = text.substring(0, start) + emoji + text.substring(end);
                input.selectionStart = input.selectionEnd = start + emoji.length;
                input.focus();

                this.updateCharCounter(input.value.length);
                this.toggleEmojiPicker();
            }

            toggleEmojiPicker() {
                document.getElementById('emojiPicker').classList.toggle('active');
            }

            toggleSidebar() {
                document.getElementById('sidebar').classList.toggle('open');
            }

            showNotification(title, body) {
                if (this.settings.sound !== 'none') {
                    this.playSound(this.settings.sound);
                }

                // Check if Notification API is available
                if (typeof Notification !== 'undefined' && Notification.permission === 'granted') {
                    new Notification(title, {
                        body: body,
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23000"/><text x="50" y="55" font-size="40" fill="%230ff" text-anchor="middle" font-family="monospace">NYM</text></svg>'
                    });
                }

                // In-app notification (always show this as fallback)
                const notifEl = document.createElement('div');
                notifEl.className = 'notification';
                notifEl.innerHTML = `
                    <div class="notification-title">${this.escapeHtml(title)}</div>
                    <div class="notification-body">${this.escapeHtml(body)}</div>
                    <div class="notification-time">${new Date().toLocaleTimeString()}</div>
                `;
                document.body.appendChild(notifEl);

                setTimeout(() => {
                    notifEl.style.animation = 'slideIn 0.3s reverse';
                    setTimeout(() => notifEl.remove(), 300);
                }, 3000);
            }

            playSound(type) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                switch (type) {
                    case 'beep':
                        oscillator.frequency.value = 800;
                        gainNode.gain.value = 0.1;
                        break;
                    case 'icq':
                        oscillator.frequency.value = 600;
                        gainNode.gain.value = 0.15;
                        break;
                    case 'msn':
                        oscillator.frequency.value = 1000;
                        gainNode.gain.value = 0.1;
                        break;
                }

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            }

            applyTheme(theme) {
                const root = document.documentElement;
                document.body.classList.remove('theme-ghost');

                const themes = {
                    matrix: {
                        primary: '#00ff00',
                        secondary: '#00ffff',
                        text: '#00ff00',
                        textDim: '#008800',
                        textBright: '#00ffaa'
                    },
                    amber: {
                        primary: '#ffb000',
                        secondary: '#ffd700',
                        text: '#ffb000',
                        textDim: '#cc8800',
                        textBright: '#ffcc00'
                    },
                    cyber: {
                        primary: '#ff00ff',
                        secondary: '#00ffff',
                        text: '#ff00ff',
                        textDim: '#aa00aa',
                        textBright: '#ff66ff'
                    },
                    hacker: {
                        primary: '#00ffff',
                        secondary: '#00ff00',
                        text: '#00ffff',
                        textDim: '#008888',
                        textBright: '#66ffff'
                    },
                    ghost: {
                        primary: '#ffffff',
                        secondary: '#cccccc',
                        text: '#ffffff',
                        textDim: '#666666',
                        textBright: '#ffffff'
                    }
                };

                if (theme === 'ghost') {
                    document.body.classList.add('theme-ghost');
                }

                const selectedTheme = themes[theme];
                if (selectedTheme) {
                    Object.entries(selectedTheme).forEach(([key, value]) => {
                        const cssVar = `--${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
                        root.style.setProperty(cssVar, value);
                    });
                }
            }

            loadSettings() {
                return {
                    theme: localStorage.getItem('nym_theme') || 'matrix',
                    sound: localStorage.getItem('nym_sound') || 'beep',
                    autoscroll: localStorage.getItem('nym_autoscroll') !== 'false',
                    showTimestamps: localStorage.getItem('nym_timestamps') !== 'false'
                };
            }

            saveSettings() {
                localStorage.setItem('nym_theme', this.settings.theme);
                localStorage.setItem('nym_sound', this.settings.sound);
                localStorage.setItem('nym_autoscroll', this.settings.autoscroll);
                localStorage.setItem('nym_timestamps', this.settings.showTimestamps);
            }

            loadBlockedUsers() {
                const blocked = localStorage.getItem('nym_blocked');
                if (blocked) {
                    this.blockedUsers = new Set(JSON.parse(blocked));
                }
                this.updateBlockedList();
            }

            saveBlockedUsers() {
                localStorage.setItem('nym_blocked', JSON.stringify(Array.from(this.blockedUsers)));
            }

            updateBlockedList() {
                const list = document.getElementById('blockedList');
                if (this.blockedUsers.size === 0) {
                    list.innerHTML = '<div style="color: var(--text-dim); font-size: 12px;">No blocked users</div>';
                } else {
                    list.innerHTML = Array.from(this.blockedUsers).map(nym => `
                        <div class="blocked-item">
                            <span>${this.escapeHtml(nym)}</span>
                            <button class="unblock-btn" onclick="nym.cmdUnblock('${this.escapeHtml(nym)}')">Unblock</button>
                        </div>
                    `).join('');
                }
            }

            escapeHtml(text) {
                const map = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                };
                return String(text).replace(/[&<>"]/g, m => map[m]);
            }
        }

        // Global instance
        const nym = new NYM();

        // Global functions for onclick handlers
        function toggleSidebar() {
            nym.toggleSidebar();
        }

        function toggleSearch(inputId) {
            const search = document.getElementById(inputId);
            search.classList.toggle('active');
            if (search.classList.contains('active')) {
                search.focus();
            }
        }

        function sendMessage() {
            nym.sendMessage();
        }

        function selectImage() {
            document.getElementById('fileInput').click();
        }

        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
        }

        function closeImageModal() {
            document.getElementById('imageModal').classList.remove('active');
        }

        function editNick() {
            document.getElementById('newNickInput').value = nym.nym;
            document.getElementById('nickEditModal').classList.add('active');
        }

        function changeNick() {
            const newNick = document.getElementById('newNickInput').value.trim();
            if (newNick && newNick !== nym.nym) {
                nym.cmdNick(newNick);
            }
            closeModal('nickEditModal');
        }

        async function changeRelay() {
            const relaySelect = document.getElementById('connectedRelaySelect').value;
            const customRelay = document.getElementById('customConnectedRelay').value;

            const newRelayUrl = relaySelect === 'custom' ? customRelay : relaySelect;

            if (!newRelayUrl) {
                alert('Please select or enter a relay URL');
                return;
            }

            nym.displaySystemMessage('Switching relay...');
            await nym.connectToRelay(newRelayUrl);
        }

        function showSettings() {
            // Set current relay
            if (nym.relayUrl) {
                const select = document.getElementById('connectedRelaySelect');
                const option = Array.from(select.options).find(opt => opt.value === nym.relayUrl);

                if (option) {
                    select.value = nym.relayUrl;
                } else {
                    select.value = 'custom';
                    document.getElementById('customConnectedRelay').value = nym.relayUrl;
                    document.getElementById('customConnectedRelay').style.display = 'block';
                }
            }

            document.getElementById('themeSelect').value = nym.settings.theme;
            document.getElementById('soundSelect').value = nym.settings.sound;
            document.getElementById('autoscrollSelect').value = nym.settings.autoscroll;
            document.getElementById('timestampSelect').value = nym.settings.showTimestamps;
            nym.updateBlockedList();
            nym.updateKeywordList();
            document.getElementById('settingsModal').classList.add('active');
        }

        function saveSettings() {
            nym.settings.theme = document.getElementById('themeSelect').value;
            nym.settings.sound = document.getElementById('soundSelect').value;
            nym.settings.autoscroll = document.getElementById('autoscrollSelect').value === 'true';
            nym.settings.showTimestamps = document.getElementById('timestampSelect').value === 'true';

            nym.applyTheme(nym.settings.theme);
            nym.saveSettings();

            // Save to synced settings if using extension
            if (nym.usingExtension) {
                nym.saveSyncedSettings();
            }

            closeModal('settingsModal');
        }

        function showAbout() {
            nym.displaySystemMessage(`
                ═══ NYM - Nostr Ynstant Messenger v1.1.2 ═══<br>
                Protocol: Nostr (kind 20000/23333 channels)<br>
                Relay: ${nym.relayUrl || 'Not connected'}<br>
                Your nym: ${nym.nym || 'Not set'}<br>
                <br>
                Created for ephemeral, anonymous communication.<br>
                Your identity exists only for this session.<br>
                No accounts. No persistence. Just nyms.<br>
                <br>
                Inspired by and bridged with Jack Dorsey's <a href="https://bitchat.free" target="_blank" rel="noopener" style="color: var(--secondary)">Bitchat</a><br>
                <br>
                NYM is FOSS code on <a href="https://github.com/Spl0itable/NYM" target="_blank" rel="noopener" style="color: var(--secondary)">GitHub</a><br>
                Made with ♥ by <a href="https://nostr.band/npub16jdfqgazrkapk0yrqm9rdxlnys7ck39c7zmdzxtxqlmmpxg04r0sd733sv" target="_blank" rel="noopener" style="color: var(--secondary)">Luxas</a>
            `);
        }

        function showChannelModal() {
            document.getElementById('channelModal').classList.add('active');
        }

        async function joinChannel() {
            const channelType = document.getElementById('channelTypeSelect').value;

            if (channelType === 'standard') {
                const name = document.getElementById('channelNameInput').value.trim();
                if (name) {
                    await nym.cmdJoin(name);
                }
            } else {
                const geohash = document.getElementById('geohashInput').value.trim();
                if (geohash) {
                    await nym.cmdJoin('#' + geohash);
                }
            }

            closeModal('channelModal');
            document.getElementById('channelNameInput').value = '';
            document.getElementById('geohashInput').value = '';
        }

        // Function to check for saved connection on page load
        async function checkSavedConnection() {
            const savedMode = localStorage.getItem('nym_connection_mode');
            const savedRelay = localStorage.getItem('nym_relay_url');

            if (savedMode === 'extension' && savedRelay && window.nostr) {
                try {
                    // Hide setup modal properly by removing active class
                    const setupModal = document.getElementById('setupModal');
                    setupModal.classList.remove('active');

                    nym.displaySystemMessage('Reconnecting with Nostr extension...');

                    // Use extension
                    await nym.useExtension();

                    // Connect to saved relay
                    await nym.connectToRelay(savedRelay);

                    // Fetch profile after connection
                    if (nym.connected) {
                        await nym.fetchProfileFromRelay(nym.pubkey);
                    }

                    // Request notification permission
                    if (typeof Notification !== 'undefined' && Notification.permission === 'default') {
                        Notification.requestPermission();
                    }

                    // Show welcome back message
                    nym.displaySystemMessage(`Welcome back to NYM, ${nym.nym}!`);
                    nym.displaySystemMessage(`Your Nostr identity has been restored.`);
                    nym.displaySystemMessage(`Type /help for available commands.`);

                } catch (error) {
                    console.error('Failed to restore connection:', error);
                    // Show setup modal if auto-connect fails - ensure it has active class
                    localStorage.removeItem('nym_connection_mode');
                    localStorage.removeItem('nym_relay_url');
                    document.getElementById('setupModal').classList.add('active');
                }
            }
            // If no saved connection, modal already has 'active' class from HTML
        }

        async function initializeNym() {
            try {
                const mode = document.getElementById('connectionMode').value;

                // Get or generate nym first
                const nymInput = document.getElementById('nymInput').value.trim();

                // Generate or use extension
                if (mode === 'ephemeral') {
                    // For ephemeral mode, use input or generate random
                    nym.nym = nymInput || nym.generateRandomNym();
                    document.getElementById('currentNym').textContent = nym.nym;
                    await nym.generateKeypair();

                    // Clear any saved connection for ephemeral mode
                    localStorage.removeItem('nym_connection_mode');
                    localStorage.removeItem('nym_relay_url');

                } else if (mode === 'extension') {
                    // For extension mode, set temporary nym first
                    nym.nym = nymInput || 'Loading profile...';
                    document.getElementById('currentNym').textContent = nym.nym;
                    await nym.useExtension();

                    // If no profile was found and no input, generate random
                    if (nym.nym === 'Loading profile...' && !nymInput) {
                        nym.nym = nym.generateRandomNym();
                        document.getElementById('currentNym').textContent = nym.nym;
                    } else if (nymInput && nym.nym === 'Loading profile...') {
                        // Use input if profile wasn't found
                        nym.nym = nymInput;
                        document.getElementById('currentNym').textContent = nym.nym;
                    }
                }

                // Get relay URL
                const relaySelect = document.getElementById('relaySelect').value;
                const relayUrl = relaySelect === 'custom' ?
                    document.getElementById('customRelayInput').value :
                    relaySelect;

                if (!relayUrl) {
                    alert('Please select or enter a relay URL');
                    return;
                }

                // Save connection preferences if using extension
                if (mode === 'extension') {
                    localStorage.setItem('nym_connection_mode', mode);
                    localStorage.setItem('nym_relay_url', relayUrl);
                }

                // Connect to relay
                await nym.connectToRelay(relayUrl);

                // For extension mode, try fetching profile again after connection
                if (mode === 'extension' && nym.connected) {
                    await nym.fetchProfileFromRelay(nym.pubkey);
                }

                // Request notification permission
                if (typeof Notification !== 'undefined' && Notification.permission === 'default') {
                    Notification.requestPermission();
                }

                // Close setup modal
                closeModal('setupModal');

                // Show welcome message
                nym.displaySystemMessage(`Welcome to NYM, ${nym.nym}! Type /help for available commands.`);
                nym.displaySystemMessage(`Your ${mode === 'extension' ? 'Nostr' : 'ephemeral'} identity is active for this session${mode === 'extension' ? '' : ' only'}.`);
                nym.displaySystemMessage(`Click on any user to send them a private message.`);

            } catch (error) {
                console.error('Initialization failed:', error);
                alert('Failed to initialize: ' + error.message);
            }
        }

        // Disconnect/logout function
        function disconnectNym() {
            // Clear saved connection
            localStorage.removeItem('nym_connection_mode');
            localStorage.removeItem('nym_relay_url');

            // Disconnect from relay
            if (nym && nym.ws) {
                nym.disconnect();
            }

            // Reload page to start fresh
            window.location.reload();
        }

        // Sign-out button
        function signOut() {
            if (confirm('Sign out and disconnect from NYM?')) {
                nym.cmdQuit();
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            nym.initialize();

            // Auto-focus nickname input
            document.getElementById('nymInput').focus();

            // Connection mode change listener
            document.getElementById('connectionMode').addEventListener('change', (e) => {
                const hint = document.getElementById('nymHint');
                if (e.target.value === 'extension') {
                    hint.textContent = 'Will use your Nostr profile name if available';
                    document.getElementById('nymInput').placeholder = 'Override profile name (optional)';
                } else {
                    hint.textContent = 'Your ephemeral pseudonym for this session';
                    document.getElementById('nymInput').placeholder = 'Leave empty for random nym';
                }
            });

            // Relay selection listener
            document.getElementById('relaySelect').addEventListener('change', (e) => {
                document.getElementById('customRelayGroup').style.display =
                    e.target.value === 'custom' ? 'block' : 'none';
            });

            // Check for saved connection AFTER initialization is complete
            setTimeout(() => {
                checkSavedConnection();
            }, 100);

            // Periodically update user list
            setInterval(() => {
                if (nym.connected) {
                    nym.updateUserList();
                }
            }, 30000);
        });
    </script>
</body>

</html>